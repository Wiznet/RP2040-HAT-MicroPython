diff --git a/drivers/wiznet5k/ethernet/socket.c b/drivers/wiznet5k/ethernet/socket.c
<<<<<<< HEAD
index 3ffda3a72..777fe1df5 100644
=======
index 3ffda3a72..43ac18292 100644
>>>>>>> dev
--- a/drivers/wiznet5k/ethernet/socket.c
+++ b/drivers/wiznet5k/ethernet/socket.c
@@ -53,20 +53,32 @@
 #include <string.h>
 
 #include "py/mpthread.h"
+#include "py/stream.h"
+#include "py/runtime.h"
 #include "socket.h"
 
-#define SOCK_ANY_PORT_NUM  0xC000;
+#include "py/mphal.h"
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
+//M20150401 : Typing Error
+//#define SOCK_ANY_PORT_NUM  0xC000;
+#define SOCK_ANY_PORT_NUM  0xC000
 
 static uint16_t sock_any_port = SOCK_ANY_PORT_NUM;
 static uint16_t sock_io_mode = 0;
 static uint16_t sock_is_sending = 0;
 static uint16_t sock_remained_size[_WIZCHIP_SOCK_NUM_] = {0,0,};
-static uint8_t  sock_pack_info[_WIZCHIP_SOCK_NUM_] = {0,};
+//static uint8_t  sock_pack_info[_WIZCHIP_SOCK_NUM_] = {0,};
+uint8_t  sock_pack_info[_WIZCHIP_SOCK_NUM_] = {0,};
 
 #if _WIZCHIP_ == 5200
    static uint16_t sock_next_rd[_WIZCHIP_SOCK_NUM_] ={0,};
 #endif
 
+//A20150601 : For integrating with W5300
+#if _WIZCHIP_ == 5300
+   uint8_t sock_remained_byte[_WIZCHIP_SOCK_NUM_] = {0,}; // set by wiz_recv_data()
+#endif
+
 #define CHECK_SOCKNUM()   \
    do{                    \
       if(sn > _WIZCHIP_SOCK_NUM_) return SOCKERR_SOCKNUM;   \
@@ -107,6 +119,17 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
 	switch(protocol)
 	{
       case Sn_MR_TCP :
+         {
+            //M20150601 : Fixed the warning - taddr will never be NULL
+		    /*
+            uint8_t taddr[4];
+            getSIPR(taddr);
+            */
+            uint32_t taddr;
+            getSIPR((uint8_t*)&taddr);
+            if(taddr == 0) return SOCKERR_SOCKINIT;
+	    break;
+         }
       case Sn_MR_UDP :
       case Sn_MR_MACRAW :
          break;
@@ -118,7 +141,9 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
       default :
          return SOCKERR_SOCKMODE;
 	}
-	if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
+	//M20150601 : For SF_TCP_ALIGN & W5300
+	//if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
+	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
 #if _WIZCHIP_ == 5200
    if(flag & 0x10) return SOCKERR_SOCKFLAG;
 #endif
@@ -128,7 +153,12 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
    	switch(protocol)
    	{
    	   case Sn_MR_TCP:
-   	      if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
+   		  //M20150601 :  For SF_TCP_ALIGN & W5300
+          #if _WIZCHIP_ == 5300
+   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK|SF_TCP_ALIGN))==0) return SOCKERR_SOCKFLAG;
+          #else
+   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
+          #endif
    	      break;
    	   case Sn_MR_UDP:
    	      if(flag & SF_IGMP_VER2)
@@ -147,7 +177,12 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
    	}
    }
 	WIZCHIP_EXPORT(close)(sn);
-	setSn_MR(sn, (protocol | (flag & 0xF0)));
+	//M20150601
+	#if _WIZCHIP_ == 5300
+	   setSn_MR(sn, ((uint16_t)(protocol | (flag & 0xF0))) | (((uint16_t)(flag & 0x02)) << 7) );
+    #else
+	   setSn_MR(sn, (protocol | (flag & 0xF0)));
+    #endif
 	if(!port)
 	{
 	   port = sock_any_port++;
@@ -156,10 +191,14 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
    setSn_PORT(sn,port);	
    setSn_CR(sn,Sn_CR_OPEN);
    while(getSn_CR(sn));
+   //A20150401 : For release the previous sock_io_mode
+   sock_io_mode &= ~(1 <<sn);
    sock_io_mode |= ((flag & SF_IO_NONBLOCK) << sn);
    sock_is_sending &= ~(1<<sn);
    sock_remained_size[sn] = 0;
-   sock_pack_info[sn] = 0;
+   //M20150601 : repalce 0 with PACK_COMPLETED
+   //sock_pack_info[sn] = 0;
+   sock_pack_info[sn] = PACK_COMPLETED;
    while(getSn_SR(sn) == SOCK_CLOSED);
    return (int8_t)sn;
 }	   
@@ -167,12 +206,39 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
 int8_t WIZCHIP_EXPORT(close)(uint8_t sn)
 {
 	CHECK_SOCKNUM();
-	
+//A20160426 : Applied the erratum 1 of W5300
+#if   (_WIZCHIP_ == 5300) 
+   //M20160503 : Wrong socket parameter. s -> sn 
+   //if( ((getSn_MR(s)& 0x0F) == Sn_MR_TCP) && (getSn_TX_FSR(s) != getSn_TxMAX(s)) ) 
+   if( ((getSn_MR(sn)& 0x0F) == Sn_MR_TCP) && (getSn_TX_FSR(sn) != getSn_TxMAX(sn)) ) 
+   { 
+      uint8_t destip[4] = {0, 0, 0, 1};
+      // TODO
+      // You can wait for completing to sending data;
+      // wait about 1 second;
+      // if you have completed to send data, skip the code of erratum 1
+      // ex> wait_1s();
+      //     if (getSn_TX_FSR(s) == getSn_TxMAX(s)) continue;
+      // 
+      //M20160503 : The socket() of close() calls close() itself again. It occures a infinite loop - close()->socket()->close()->socket()-> ~
+      //socket(s,Sn_MR_UDP,0x3000,0);
+      //sendto(s,destip,1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0.1).
+      setSn_MR(sn,Sn_MR_UDP);
+      setSn_PORTR(sn, 0x3000);
+      setSn_CR(sn,Sn_CR_OPEN);
+      while(getSn_CR(sn) != 0);
+      while(getSn_SR(sn) != SOCK_UDP);
+      sendto(sn,destip,1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0.1).
+   };   
+#endif 
 	setSn_CR(sn,Sn_CR_CLOSE);
    /* wait to process the command... */
 	while( getSn_CR(sn) );
 	/* clear all interrupt of the socket. */
 	setSn_IR(sn, 0xFF);
+	//A20150401 : Release the sock_io_mode of socket n.
+	sock_io_mode &= ~(1<<sn);
+	//
 	sock_is_sending &= ~(1<<sn);
 	sock_remained_size[sn] = 0;
 	sock_pack_info[sn] = 0;
@@ -189,12 +255,9 @@ int8_t WIZCHIP_EXPORT(listen)(uint8_t sn)
 	while(getSn_CR(sn));
    while(getSn_SR(sn) != SOCK_LISTEN)
    {
-      if(getSn_CR(sn) == SOCK_CLOSED)
-      {
-         WIZCHIP_EXPORT(close)(sn);
+       	WIZCHIP_EXPORT(close)(sn);
          return SOCKERR_SOCKCLOSED;
       }
-   }
    return SOCK_OK;
 }
 
@@ -286,12 +349,14 @@ int32_t WIZCHIP_EXPORT(send)(uint8_t sn, uint8_t * buf, uint16_t len)
       if(tmp & Sn_IR_SENDOK)
       {
          setSn_IR(sn, Sn_IR_SENDOK);
-         #if _WZICHIP_ == 5200
+         //M20150401 : Typing Error
+         //#if _WZICHIP_ == 5200
+         #if _WIZCHIP_ == 5200
             if(getSn_TX_RD(sn) != sock_next_rd[sn])
             {
                setSn_CR(sn,Sn_CR_SEND);
                while(getSn_CR(sn));
-               return SOCKERR_BUSY;
+               return SOCK_BUSY;
             }
          #endif
          sock_is_sending &= ~(1<<sn);         
@@ -326,7 +391,9 @@ int32_t WIZCHIP_EXPORT(send)(uint8_t sn, uint8_t * buf, uint16_t len)
    /* wait to process the command... */
    while(getSn_CR(sn));
    sock_is_sending |= (1 << sn);
-   return len;
+   //M20150409 : Explicit Type Casting
+   //return len;
+   return (int32_t)len;
 }
 
 
@@ -334,12 +401,26 @@ int32_t WIZCHIP_EXPORT(recv)(uint8_t sn, uint8_t * buf, uint16_t len)
 {
    uint8_t  tmp = 0;
    uint16_t recvsize = 0;
+//A20150601 : For integarating with W5300
+#if   _WIZCHIP_ == 5300
+   uint8_t head[2];
+   uint16_t mr;
+#endif
+//
    CHECK_SOCKNUM();
    CHECK_SOCKMODE(Sn_MR_TCP);
    CHECK_SOCKDATA();
    
    recvsize = getSn_RxMAX(sn);
    if(recvsize < len) len = recvsize;
+      
+//A20150601 : For Integrating with W5300
+#if _WIZCHIP_ == 5300
+   //sock_pack_info[sn] = PACK_COMPLETED;    // for clear      
+   if(sock_remained_size[sn] == 0)
+   {
+#endif
+//
    while(1)
    {
       recvsize = getSn_RX_RSR(sn);
@@ -357,8 +438,8 @@ int32_t WIZCHIP_EXPORT(recv)(uint8_t sn, uint8_t * buf, uint16_t len)
                //  formed an orderly shutdown, recv() shall return 0".
                // TODO this return value clashes with SOCK_BUSY in non-blocking mode.
                WIZCHIP_EXPORT(close)(sn);
-               return 0;
-            }
+                  return SOCKERR_SOCKSTATUS;
+               }
          }
          else
          {
@@ -370,17 +451,62 @@ int32_t WIZCHIP_EXPORT(recv)(uint8_t sn, uint8_t * buf, uint16_t len)
       if(recvsize != 0) break;
       MICROPY_THREAD_YIELD();
    };
-   if(recvsize < len) len = recvsize;
+//A20150601 : For integrating with W5300
+#if _WIZCHIP_ == 5300
+   if((sock_remained_size[sn] == 0) || (getSn_MR(sn) & Sn_MR_ALIGN))
+   {
+      mr = getMR();
+      if((getSn_MR(sn) & Sn_MR_ALIGN)==0)
+      {
+         wiz_recv_data(sn,head,2);
+         if(mr & MR_FS)
+            recvsize = (((uint16_t)head[1]) << 8) | ((uint16_t)head[0]);
+         else
+            recvsize = (((uint16_t)head[0]) << 8) | ((uint16_t)head[1]);
+         sock_pack_info[sn] = PACK_FIRST;
+      }
+      sock_remained_size[sn] = recvsize;
+   }
+   if(len > sock_remained_size[sn]) len = sock_remained_size[sn];
+   recvsize = len;   
+   if(sock_pack_info[sn] & PACK_FIFOBYTE)
+   {
+      *buf = sock_remained_byte[sn];
+      buf++;
+      sock_pack_info[sn] &= ~(PACK_FIFOBYTE);
+      recvsize -= 1;
+      sock_remained_size[sn] -= 1;
+   }
+   if(recvsize != 0)
+   {
+      wiz_recv_data(sn, buf, recvsize);
+      setSn_CR(sn,Sn_CR_RECV);
+      while(getSn_CR(sn));
+   }
+   sock_remained_size[sn] -= recvsize;
+   if(sock_remained_size[sn] != 0)
+   {
+      sock_pack_info[sn] |= PACK_REMAINED;
+      if(recvsize & 0x1) sock_pack_info[sn] |= PACK_FIFOBYTE;
+   }
+   else sock_pack_info[sn] = PACK_COMPLETED;
+   if(getSn_MR(sn) & Sn_MR_ALIGN) sock_remained_size[sn] = 0;
+   //len = recvsize;
+#else   
+   if(recvsize < len) len = recvsize;   
    wiz_recv_data(sn, buf, len);
    setSn_CR(sn,Sn_CR_RECV);
    while(getSn_CR(sn));
-   return len;
+#endif
+   return (int32_t)len;
 }
 
 int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port)
 {
    uint8_t tmp = 0;
    uint16_t freesize = 0;
+   uint32_t taddr;
+
    CHECK_SOCKNUM();
    switch(getSn_MR(sn) & 0x0F)
    {
@@ -393,18 +519,23 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
    CHECK_SOCKDATA();
    //M20140501 : For avoiding fatal error on memory align mismatched
    //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
-   {
-      uint32_t taddr;
+   
+      //uint32_t taddr;
       taddr = ((uint32_t)addr[0]) & 0x000000FF;
       taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
       taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
       taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
-      if (taddr == 0xFFFFFFFF || taddr == 0) return SOCKERR_IPINVALID;
-   }
+   //}
    //
-   if(port == 0)               return SOCKERR_PORTZERO;
+   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
+   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
+   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    tmp = getSn_SR(sn);
-   if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
+//#if ( _WIZCHIP_ < 5200 )
+   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
+//#else
+//   if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
+//#endif
       
    setSn_DIPR(sn,addr);
    setSn_DPORT(sn,port);      
@@ -412,6 +543,7 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
    if (len > freesize) len = freesize; // check size not to exceed MAX size.
    while(1)
    {
+      mp_hal_delay_ms(500);
       freesize = getSn_TX_FSR(sn);
       if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
       if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
@@ -419,11 +551,21 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
       MICROPY_THREAD_YIELD();
    };
 	wiz_send_data(sn, buf, len);
-
-   #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
-      setSUBR(wizchip_getsubn());
+   #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
+      getSIPR((uint8_t*)&taddr);
+      if(taddr == 0)
+      {
+         getSUBR((uint8_t*)&taddr);
+         setSUBR((uint8_t*)"\x00\x00\x00\x00");
+      }
+      else taddr = 0;
    #endif
 
+//A20150601 : For W5300
+#if _WIZCHIP_ == 5300
+   setSn_TX_WRSR(sn, len);
+#endif
+//   
 	setSn_CR(sn,Sn_CR_SEND);
 	/* wait to process the command... */
 	while(getSn_CR(sn));
@@ -440,37 +513,54 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
       else if(tmp & Sn_IR_TIMEOUT)
       {
          setSn_IR(sn, Sn_IR_TIMEOUT);
-   #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
-      setSUBR((uint8_t*)"\x00\x00\x00\x00");
-   #endif
+         //M20150409 : Fixed the lost of sign bits by type casting.
+         //len = (uint16_t)SOCKERR_TIMEOUT;
+         //break;
+         #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
+            if(taddr) setSUBR((uint8_t*)&taddr);
+         #endif
          return SOCKERR_TIMEOUT;
       }
       ////////////
       MICROPY_THREAD_YIELD();
    }
-   #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
-      setSUBR((uint8_t*)"\x00\x00\x00\x00");
+   #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
+      if(taddr) setSUBR((uint8_t*)&taddr);
    #endif
-	return len;
+   //M20150409 : Explicit Type Casting
+   //return len;
+   return (int32_t)len;
 }
 
 
 
 int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port)
 {
+//M20150601 : For W5300   
+#if _WIZCHIP_ == 5300
+   uint16_t mr;
+   uint16_t mr1;
+#else   
    uint8_t  mr;
+#endif
    uint8_t  head[8];
 	uint16_t pack_len=0;
 
    CHECK_SOCKNUM();
    //CHECK_SOCKMODE(Sn_MR_UDP);
+//A20150601
+#if _WIZCHIP_ == 5300
+   mr1 = getMR();
+#endif   
    switch((mr=getSn_MR(sn)) & 0x0F)
    {
       case Sn_MR_UDP:
+    #if ( _WIZCHIP_ != 5500 )
+	   case Sn_MR_IPRAW:
+    #endif
       case Sn_MR_MACRAW:
          break;
    #if ( _WIZCHIP_ < 5200 )         
-      case Sn_MR_IPRAW:
       case Sn_MR_PPPoE:
          break;
    #endif
<<<<<<< HEAD
@@ -489,7 +579,8 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -489,7 +646,8 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
          MICROPY_THREAD_YIELD();
       };
    }
-   sock_pack_info[sn] = PACK_COMPLETED;
+//D20150601 : Move it to bottom
+// sock_pack_info[sn] = PACK_COMPLETED;
 	switch (mr & 0x07)
 	{
 	   case Sn_MR_UDP :
<<<<<<< HEAD
@@ -499,6 +590,22 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -499,6 +657,22 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			setSn_CR(sn,Sn_CR_RECV);
    			while(getSn_CR(sn));
    			// read peer's IP address, port number & packet length
+   	   //A20150601 : For W5300
+   		#if _WIZCHIP_ == 5300
+   		   if(mr1 & MR_FS)
+   		   {
+   		      addr[0] = head[1];
+   		      addr[1] = head[0];
+   		      addr[2] = head[3];
+   		      addr[3] = head[2];
+   		      *port = head[5];
+   		      *port = (*port << 8) + head[4];
+      			sock_remained_size[sn] = head[7];
+      			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[6];
+   		   }
+            else
+            {
+         #endif
     			addr[0] = head[0];
    			addr[1] = head[1];
    			addr[2] = head[2];
<<<<<<< HEAD
@@ -507,10 +614,24 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -507,10 +681,24 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			*port = (*port << 8) + head[5];
    			sock_remained_size[sn] = head[6];
    			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[7];
+         #if _WIZCHIP_ == 5300
+            }
+         #endif
    			sock_pack_info[sn] = PACK_FIRST;
    	   }
 			if(len < sock_remained_size[sn]) pack_len = len;
 			else pack_len = sock_remained_size[sn];
+			//A20150601 : For W5300
+			len = pack_len;
+			#if _WIZCHIP_ == 5300
+			   if(sock_pack_info[sn] & PACK_FIFOBYTE)
+			   {
+			      *buf++ = sock_remained_byte[sn];
+			      pack_len -= 1;
+			      sock_remained_size[sn] -= 1;
+			      sock_pack_info[sn] &= ~PACK_FIFOBYTE;
+			   }
+			#endif
 			//
 			// Need to packet length check (default 1472)
 			//
<<<<<<< HEAD
@@ -524,8 +645,13 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -524,8 +712,13 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			while(getSn_CR(sn));
    			// read peer's IP address, port number & packet length
     			sock_remained_size[sn] = head[0];
-   			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1];
-   			sock_remained_size[sn] -= 2; // len includes 2 len bytes
+   			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1] -2;
+   			#if _WIZCHIP_ == W5300
+   			if(sock_remained_size[sn] & 0x01)
+   				sock_remained_size[sn] = sock_remained_size[sn] + 1 - 4;
+   			else
+   				sock_remained_size[sn] -= 4;
+			#endif
    			if(sock_remained_size[sn] > 1514) 
    			{
    			   WIZCHIP_EXPORT(close)(sn);
<<<<<<< HEAD
@@ -549,7 +675,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -537,7 +730,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
 			else pack_len = sock_remained_size[sn];
 			wiz_recv_data(sn,buf,pack_len);
 		   break;
-   #if ( _WIZCHIP_ < 5200 )
+   //#if ( _WIZCHIP_ < 5200 )
 		case Sn_MR_IPRAW:
 		   if(sock_remained_size[sn] == 0)
 		   {
@@ -549,7 +742,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			addr[2] = head[2];
    			addr[3] = head[3];
    			sock_remained_size[sn] = head[4];
-   			sock_remaiend_size[sn] = (sock_remained_size[sn] << 8) + head[5];
+   			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[5];
    			sock_pack_info[sn] = PACK_FIRST;
          }
 			//
<<<<<<< HEAD
@@ -569,11 +695,23 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -559,7 +752,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
 			else pack_len = sock_remained_size[sn];
    		wiz_recv_data(sn, buf, pack_len); // data copy.
 			break;
-   #endif
+   //#endif
       default:
          wiz_recv_ignore(sn, pack_len); // data copy.
          sock_remained_size[sn] = pack_len;
@@ -569,11 +762,23 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
 	/* wait to process the command... */
 	while(getSn_CR(sn)) ;
 	sock_remained_size[sn] -= pack_len;
-	//M20140501 : replace 0x01 with PACK_REMAINED
+	//M20150601 : 
 	//if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= 0x01;
-	if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= PACK_REMAINED;
+	if(sock_remained_size[sn] != 0)
+	{
+	   sock_pack_info[sn] |= PACK_REMAINED;
+   #if _WIZCHIP_ == 5300	   
+	   if(pack_len & 0x01) sock_pack_info[sn] |= PACK_FIFOBYTE;
+   #endif	      
+	}
+	else sock_pack_info[sn] = PACK_COMPLETED;
+#if _WIZCHIP_ == 5300	   
+   pack_len = len;
+#endif
    //
- 	return pack_len;
+   //M20150409 : Explicit Type Casting
+   //return pack_len;
+   return (int32_t)pack_len;
 }
 
 
<<<<<<< HEAD
@@ -608,12 +746,15 @@ int8_t  WIZCHIP_EXPORT(ctlsocket)(uint8_t sn, ctlsock_type cstype, void* arg)
=======
@@ -608,12 +813,15 @@ int8_t  WIZCHIP_EXPORT(ctlsocket)(uint8_t sn, ctlsock_type cstype, void* arg)
>>>>>>> dev
       case CS_GET_INTERRUPT:
          *((uint8_t*)arg) = getSn_IR(sn);
          break;
-      case CS_SET_INTMASK:  
+    #if _WIZCHIP_ !=5100
+     case CS_SET_INTMASK:  
          if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
          setSn_IMR(sn,*(uint8_t*)arg);
          break;
       case CS_GET_INTMASK:   
          *((uint8_t*)arg) = getSn_IMR(sn);
+         break;
+   #endif
       default:
          return SOCKERR_ARG;
    }
<<<<<<< HEAD
@@ -660,7 +801,7 @@ int8_t  WIZCHIP_EXPORT(setsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
=======
@@ -660,7 +868,7 @@ int8_t  WIZCHIP_EXPORT(setsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
>>>>>>> dev
          		}
             }
          break;
-   #if _WIZCHIP_ > 5200
+   #if !( (_WIZCHIP_ == 5100) || (_WIZCHIP_ == 5200) )
       case SO_KEEPALIVEAUTO:
          CHECK_SOCKMODE(Sn_MR_TCP);
          setSn_KPALVTR(sn,*(uint8_t*)arg);
<<<<<<< HEAD
@@ -688,7 +829,8 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
=======
@@ -688,7 +896,8 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
>>>>>>> dev
          *(uint8_t*) arg = getSn_TOS(sn);
          break;
       case SO_MSS:   
-         *(uint8_t*) arg = getSn_MSSR(sn);
+         *(uint16_t*) arg = getSn_MSSR(sn);
+         break;
       case SO_DESTIP:
          getSn_DIPR(sn, (uint8_t*)arg);
          break;
<<<<<<< HEAD
@@ -703,19 +845,25 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
=======
@@ -703,19 +912,25 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
>>>>>>> dev
    #endif      
       case SO_SENDBUF:
          *(uint16_t*) arg = getSn_TX_FSR(sn);
+         break;
       case SO_RECVBUF:
          *(uint16_t*) arg = getSn_RX_RSR(sn);
+         break;
       case SO_STATUS:
          *(uint8_t*) arg = getSn_SR(sn);
          break;
       case SO_REMAINSIZE:
-         if(getSn_MR(sn) == Sn_MR_TCP)
+         if(getSn_MR(sn) & Sn_MR_TCP)
             *(uint16_t*)arg = getSn_RX_RSR(sn);
          else
             *(uint16_t*)arg = sock_remained_size[sn];
          break;
       case SO_PACKINFO:
-         CHECK_SOCKMODE(Sn_MR_TCP);
+         //CHECK_SOCKMODE(Sn_MR_TCP);
+#if _WIZCHIP_ != 5300
+         if((getSn_MR(sn) == Sn_MR_TCP))
+             return SOCKERR_SOCKMODE;
+#endif
          *(uint8_t*)arg = sock_pack_info[sn];
          break;
       default:
diff --git a/drivers/wiznet5k/ethernet/socket.h b/drivers/wiznet5k/ethernet/socket.h
index 2f03a34eb..2857277e5 100644
--- a/drivers/wiznet5k/ethernet/socket.h
+++ b/drivers/wiznet5k/ethernet/socket.h
@@ -124,6 +124,11 @@
    #define SF_UNI_BLOCK           (Sn_MR_UCASTB)   ///< In \ref Sn_MR_UDP with \ref SF_MULTI_ENABLE. Valid only in W5500
 #endif
 
+//A201505 : For W5300
+#if _WIZCHIP_ == 5300
+   #define SF_TCP_ALIGN		     0x02			   ///< Valid only \ref Sn_MR_TCP and W5300, refer to \ref Sn_MR_ALIGN
+#endif
+
 #define SF_IO_NONBLOCK           0x01              ///< Socket nonblock io mode. It used parameter in \ref socket().
 
 /*
@@ -132,6 +137,8 @@
 #define PACK_FIRST               0x80              ///< In Non-TCP packet, It indicates to start receiving a packet.
 #define PACK_REMAINED            0x01              ///< In Non-TCP packet, It indicates to remain a packet to be received.
 #define PACK_COMPLETED           0x00              ///< In Non-TCP packet, It indicates to complete to receive a packet.
+//A20150601 : For Integrating with W5300
+#define PACK_FIFOBYTE            0x02              ///< Valid only W5300, It indicate to have read already the Sn_RX_FIFOR.
 
 // resets all global state associated with the socket interface
 void WIZCHIP_EXPORT(socket_reset)(void);
@@ -343,7 +350,9 @@ typedef enum
    SIK_RECEIVED      = (1 << 2),    ///< data received
    SIK_TIMEOUT       = (1 << 3),    ///< timeout occurred
    SIK_SENT          = (1 << 4),    ///< send ok
-   SIK_ALL           = 0x1F,        ///< all interrupt
+   //M20150410 : Remove the comma of last member
+   //SIK_ALL           = 0x1F,        ///< all interrupt
+   SIK_ALL           = 0x1F         ///< all interrupt
 }sockint_kind;
 
 /**
@@ -358,8 +367,10 @@ typedef enum
    CS_GET_MAXRXBUF,        ///< get the size of socket buffer allocated in RX memory
    CS_CLR_INTERRUPT,       ///< clear the interrupt of socket with @ref sockint_kind
    CS_GET_INTERRUPT,       ///< get the socket interrupt. refer to @ref sockint_kind
-   CS_SET_INTMASK,         ///< set the interrupt mask of socket with @ref sockint_kind
-   CS_GET_INTMASK          ///< get the masked interrupt of socket. refer to @ref sockint_kind
+#if _WIZCHIP_ > 5100
+   CS_SET_INTMASK,         ///< set the interrupt mask of socket with @ref sockint_kind, Not supported in W5100
+   CS_GET_INTMASK          ///< get the masked interrupt of socket. refer to @ref sockint_kind, Not supported in W5100
+#endif
 }ctlsock_type;
 
 
@@ -376,9 +387,9 @@ typedef enum
    SO_DESTIP,           ///< Set/Get the destination IP address. @ref Sn_DIPR ( @ref setSn_DIPR(), @ref getSn_DIPR() )
    SO_DESTPORT,         ///< Set/Get the destination Port number. @ref Sn_DPORT ( @ref setSn_DPORT(), @ref getSn_DPORT() )
 #if _WIZCHIP_ != 5100   
-   SO_KEEPALIVESEND,    ///< Valid only in setsockopt. Manually send keep-alive packet in TCP mode
-   #if _WIZCHIP_ > 5200   
-      SO_KEEPALIVEAUTO, ///< Set/Get keep-alive auto transmission timer in TCP mode
+   SO_KEEPALIVESEND,    ///< Valid only in setsockopt. Manually send keep-alive packet in TCP mode, Not supported in W5100
+   #if !( (_WIZCHIP_ == 5100) || (_WIZCHIP_ == 5200) )
+      SO_KEEPALIVEAUTO, ///< Set/Get keep-alive auto transmission timer in TCP mode, Not supported in W5100, W5200
    #endif      
 #endif
    SO_SENDBUF,          ///< Valid only in getsockopt. Get the free data size of Socekt TX buffer. @ref Sn_TX_FSR, @ref getSn_TX_FSR()
diff --git a/drivers/wiznet5k/ethernet/w5500/w5500.c b/drivers/wiznet5k/ethernet/w5500/w5500.c
index 3107b1b71..014cd4445 100644
--- a/drivers/wiznet5k/ethernet/w5500/w5500.c
+++ b/drivers/wiznet5k/ethernet/w5500/w5500.c
@@ -86,7 +86,6 @@ uint8_t  WIZCHIP_READ(uint32_t AddrSel)
    spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
    Chip_SSP_ReadFrames_Blocking(LPC_SSP0, &ret, 1);
-
    WIZCHIP.CS._deselect();
    WIZCHIP_CRITICAL_EXIT();
    return ret;
diff --git a/drivers/wiznet5k/ethernet/w5500/w5500.h b/drivers/wiznet5k/ethernet/w5500/w5500.h
index c2afb180e..faab9e95a 100644
--- a/drivers/wiznet5k/ethernet/w5500/w5500.h
+++ b/drivers/wiznet5k/ethernet/w5500/w5500.h
@@ -834,7 +834,7 @@
  */
 #define Sn_MR_MACRAW                 0x04
 
-//#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
+#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
 
 /**
  * @brief UDP
@@ -1124,7 +1124,7 @@
  */
 #define SOCK_UDP                     0x22
 
-//#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
+#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
 
 /**
  * @brief MAC raw mode socket
diff --git a/drivers/wiznet5k/ethernet/wizchip_conf.c b/drivers/wiznet5k/ethernet/wizchip_conf.c
<<<<<<< HEAD
index 3e54d2c90..9f6182f98 100644
=======
index 3e54d2c90..9e6633671 100644
>>>>>>> dev
--- a/drivers/wiznet5k/ethernet/wizchip_conf.c
+++ b/drivers/wiznet5k/ethernet/wizchip_conf.c
@@ -5,8 +5,12 @@
 //! \version 1.0.1
 //! \date 2013/10/21
 //! \par  Revision history
+//!       <2015/02/05> Notice
+//!        The version history is not updated after this point.
+//!        Download the latest version directly from GitHub. Please visit the our GitHub repository for ioLibrary.
+//!        >> https://github.com/Wiznet/ioLibrary_Driver
 //!       <2014/05/01> V1.0.1  Refer to M20140501
-//!        1. Explicit type casting in wizchip_bus_readbyte() & wizchip_bus_writebyte()
+//!        1. Explicit type casting in wizchip_bus_readdata() & wizchip_bus_writedata()
 //            Issued by Mathias ClauBen.
 //!           uint32_t type converts into ptrdiff_t first. And then recoverting it into uint8_t*
 //!           For remove the warning when pointer type size is not 32bit.
@@ -47,68 +51,110 @@
 //A20140501 : for use the type - ptrdiff_t
 #include <stddef.h>
 //
+#include "py/objlist.h"
+#include "py/runtime.h"
+#include "py/stream.h"
+#include "py/mperrno.h"
+#include "py/mphal.h"
+
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
 
 #include "wizchip_conf.h"
-#include "socket.h"
+
+/////////////
+//M20150401 : Remove ; in the default callback function such as wizchip_cris_enter(), wizchip_cs_select() and etc.
+/////////////
 
 /**
  * @brief Default function to enable interrupt.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	  wizchip_cris_enter(void)           {};
+//void 	  wizchip_cris_enter(void)           {};
+void 	  wizchip_cris_enter(void)           {}
+
 /**
  * @brief Default function to disable interrupt.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	  wizchip_cris_exit(void)          {};
+//void 	  wizchip_cris_exit(void)          {};
+void 	  wizchip_cris_exit(void)          {}
+
 /**
  * @brief Default function to select chip.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	wizchip_cs_select(void)            {};
+//void 	wizchip_cs_select(void)            {};
+void 	wizchip_cs_select(void)            {}
+
 /**
  * @brief Default function to deselect chip.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	wizchip_cs_deselect(void)          {};
+//void 	wizchip_cs_deselect(void)          {};
+void 	wizchip_cs_deselect(void)          {}
+
 /**
  * @brief Default function to read in direct or indirect interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
- //M20140501 : Explict pointer type casting
-//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *) AddrSel); };
-uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); };
+ //M20150601 : Rename the function for integrating with 5300
+//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); }
+iodata_t wizchip_bus_readdata(uint32_t AddrSel) { return * ((volatile iodata_t *)((ptrdiff_t) AddrSel)); }
+
 /**
  * @brief Default function to write in direct or indirect interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
- 
-//M20140501 : Explict pointer type casting
-//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*) AddrSel) = wb; };
-void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; };
+//M20150601 : Rename the function for integrating with 5300
+//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; }
+void 	wizchip_bus_writedata(uint32_t AddrSel, iodata_t wb)  { *((volatile iodata_t*)((ptrdiff_t)AddrSel)) = wb; }
 
 /**
  * @brief Default function to read in SPI interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void wizchip_spi_readbytes(uint8_t *buf, uint32_t len) {}
+//uint8_t wizchip_spi_readbyte(void)        {return 0;};
+void wizchip_spi_readbyte(uint8_t *buf, uint32_t len) {}
+
 /**
  * @brief Default function to write in SPI interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void wizchip_spi_writebytes(const uint8_t *buf, uint32_t len) {}
+//void 	wizchip_spi_writebyte(uint8_t wb) {};
+void 	wizchip_spi_writebyte(const uint8_t *buf, uint32_t len) {}
+
+/**
+ * @brief Default function to burst read in SPI interface.
+ * @note This function help not to access wrong address. If you do not describe this function or register any functions,
+ * null function is called.
+ */
+//void 	wizchip_spi_readburst(uint8_t* pBuf, uint16_t len) 	{}; 
+void 	wizchip_spi_readburst(uint8_t* pBuf, uint16_t len) 	{}
+
+/**
+ * @brief Default function to burst write in SPI interface.
+ * @note This function help not to access wrong address. If you do not describe this function or register any functions,
+ * null function is called.
+ */
+//void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {};
+void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {}
 
 /**
  * @\ref _WIZCHIP instance
  */
+//
+//M20150401 : For a compiler didnot support a member of structure
+//            Replace the assignment of struct members with the assingment of array
+//
+/*
 _WIZCHIP  WIZCHIP =
       {
       .id                  = _WIZCHIP_ID_,
@@ -122,10 +168,32 @@ _WIZCHIP  WIZCHIP =
 //    .IF.SPI._read_byte   = wizchip_spi_readbyte,
 //    .IF.SPI._write_byte  = wizchip_spi_writebyte
       };
+*/      
+_WIZCHIP  WIZCHIP =
+{
+    _WIZCHIP_IO_MODE_,
+    _WIZCHIP_ID_ ,
+    {
+        wizchip_cris_enter,
+        wizchip_cris_exit
+    },
+    {
+        wizchip_cs_select,
+        wizchip_cs_deselect
+    },
+    {
+        {
+            //M20150601 : Rename the function 
+            //wizchip_bus_readbyte,
+            //wizchip_bus_writebyte
+            wizchip_bus_readdata,
+            wizchip_bus_writedata
+        },
+
+    }
+};
+
 
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-static uint8_t    _SUBN_[4];     // subnet
-#endif
 static uint8_t    _DNS_[4];      // DNS server ip address
 static dhcp_mode  _DHCP_;        // DHCP mode
 
@@ -157,10 +225,13 @@ void reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void))
    }
 }
 
-void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb))
+//M20150515 : For integrating with 5300
+//void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb))
+void reg_wizchip_bus_cbfunc(iodata_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, iodata_t wb))
 {
    while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_BUS_));
-   
+   //M20150601 : Rename call back function for integrating with 5300
+   /*
    if(!bus_rb || !bus_wb)
    {
       WIZCHIP.IF.BUS._read_byte   = wizchip_bus_readbyte;
@@ -171,6 +242,17 @@ void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint
       WIZCHIP.IF.BUS._read_byte   = bus_rb;
       WIZCHIP.IF.BUS._write_byte  = bus_wb;
    }
+   */
+   if(!bus_rb || !bus_wb)
+   {
+      WIZCHIP.IF.BUS._read_data   = wizchip_bus_readdata;
+      WIZCHIP.IF.BUS._write_data  = wizchip_bus_writedata;
+   }
+   else
+   {
+      WIZCHIP.IF.BUS._read_data   = bus_rb;
+      WIZCHIP.IF.BUS._write_data  = bus_wb;
+   }
 }
 
 void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(const uint8_t *, uint32_t))
<<<<<<< HEAD
@@ -179,8 +254,8 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
=======
@@ -179,8 +261,8 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
>>>>>>> dev
    
    if(!spi_rb || !spi_wb)
    {
-      WIZCHIP.IF.SPI._read_bytes   = wizchip_spi_readbytes;
-      WIZCHIP.IF.SPI._write_bytes  = wizchip_spi_writebytes;
+      WIZCHIP.IF.SPI._read_bytes   = wizchip_spi_readbyte;
+      WIZCHIP.IF.SPI._write_bytes  = wizchip_spi_writebyte;
    }
    else
    {
<<<<<<< HEAD
@@ -188,10 +263,29 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
=======
@@ -188,10 +270,29 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
>>>>>>> dev
       WIZCHIP.IF.SPI._write_bytes  = spi_wb;
    }
 }
+/*
+// 20140626 Eric Added for SPI burst operations
+void reg_wizchip_spiburst_cbfunc(void (*spi_rb)(uint8_t* pBuf, uint16_t len), void (*spi_wb)(uint8_t* pBuf, uint16_t len))
+{
+   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
 
+   if(!spi_rb || !spi_wb)
+   {
+      WIZCHIP.IF.SPI._read_burst   = wizchip_spi_readburst;
+      WIZCHIP.IF.SPI._write_burst  = wizchip_spi_writeburst;
+   }
+   else
+   {
+      WIZCHIP.IF.SPI._read_burst   = spi_rb;
+      WIZCHIP.IF.SPI._write_burst  = spi_wb;
+   }
+}
+*/
 int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
 {
+#if	_WIZCHIP_ == 5105 || _WIZCHIP_ == 5200 || _WIZCHIP_ == 5500
    uint8_t tmp = 0;
+#endif
    uint8_t* ptmp[2] = {0,0};
    switch(cwtype)
    {
@@ -217,7 +318,9 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
       case CW_GET_INTRMASK:
          *((intr_kind*)arg) = wizchip_getinterruptmask();
          break;
-   #if _WIZCHIP_ > 5100
+   //M20150601 : This can be supported by 5200, 5500
+   //#if _WIZCHIP_ > 5100
+   #if (_WIZCHIP_ == 5200 || _WIZCHIP_ == 5500)
       case CW_SET_INTRTIME:
          setINTLEVEL(*(uint16_t*)arg);
          break;
@@ -231,9 +334,10 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
          ((uint8_t*)arg)[2] = WIZCHIP.id[2];
          ((uint8_t*)arg)[3] = WIZCHIP.id[3];
          ((uint8_t*)arg)[4] = WIZCHIP.id[4];
-         ((uint8_t*)arg)[5] = 0;
+         ((uint8_t*)arg)[5] = WIZCHIP.id[5];
+         ((uint8_t*)arg)[6] = 0;
          break;
-   #if _WIZCHIP_ ==  5500
+   #if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5500
       case CW_RESET_PHY:
          wizphy_reset();
          break;
@@ -248,6 +352,7 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
       case CW_SET_PHYPOWMODE:
          return wizphy_setphypmode(*(uint8_t*)arg);
    #endif
+   #if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5200 || _WIZCHIP_ == 5500
       case CW_GET_PHYPOWMODE:
          tmp = wizphy_getphypmode();
          if((int8_t)tmp == -1) return -1;
@@ -258,6 +363,7 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
          if((int8_t)tmp == -1) return -1;
          *(uint8_t*)arg = tmp;
          break;
+   #endif      
       default:
          return -1;
    }
@@ -297,10 +403,21 @@ void wizchip_sw_reset(void)
 {
    uint8_t gw[4], sn[4], sip[4];
    uint8_t mac[6];
+//A20150601
+#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
+   uint16_t mr = (uint16_t)getMR();
+   setMR(mr | MR_IND);
+#endif
+//
    getSHAR(mac);
    getGAR(gw);  getSUBR(sn);  getSIPR(sip);
    setMR(MR_RST);
    getMR(); // for delay
+//A2015051 : For indirect bus mode 
+#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
+   setMR(mr | MR_IND);
+#endif
+//
    setSHAR(mac);
    setGAR(gw);
    setSUBR(sn);
@@ -310,29 +427,82 @@ void wizchip_sw_reset(void)
 int8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize)
 {
    int8_t i;
+#if _WIZCHIP_ < 5200
+   int8_t j;
+#endif
    int8_t tmp = 0;
    wizchip_sw_reset();
    if(txsize)
    {
       tmp = 0;
-      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         tmp += txsize[i];
-      if(tmp > 16) return -1;
-      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         setSn_TXBUF_SIZE(i, txsize[i]);
+   //M20150601 : For integrating with 5300
+   #if _WIZCHIP_ == 5300
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+			if(txsize[i] >= 64) return -1;   //No use 64KB even if 5300 support max 64KB memory allocation
+			tmp += txsize[i];
+			if(tmp > 128) return -1;
+		}
+		if(tmp % 8) return -1;
+   #else
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+			tmp += txsize[i];
+
+		#if _WIZCHIP_ < 5200	//2016.10.28 peter add condition for 5100 and 5105
+			if(tmp > 8) return -1;
+		#else
+			if(tmp > 16) return -1;
+		#endif
+		}
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+		#if _WIZCHIP_ < 5200	//2016.10.28 peter add condition for 5100
+			j = 0;
+			while((txsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
+			setSn_TXBUF_SIZE(i, j);
+		#else
+			setSn_TXBUF_SIZE(i, txsize[i]);
+		#endif
+		}
+
+	#endif
    }
+
    if(rxsize)
    {
       tmp = 0;
+   #if _WIZCHIP_ == 5300
       for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         tmp += rxsize[i];
-      if(tmp > 16) return -1;
-      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         setSn_RXBUF_SIZE(i, rxsize[i]);
+		{
+			if(rxsize[i] >= 64) return -1;   //No use 64KB even if 5300 support max 64KB memory allocation
+			tmp += rxsize[i];
+			if(tmp > 128) return -1;
+		}
+		if(tmp % 8) return -1;
+   #else
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+			tmp += rxsize[i];
+		#if _WIZCHIP_ < 5200	//2016.10.28 peter add condition for 5100 and 5105
+			if(tmp > 8) return -1;
+		#else
+			if(tmp > 16) return -1;
+		#endif
+		}
+
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+		#if _WIZCHIP_ < 5200	// add condition for 5100
+			j = 0;
+			while((rxsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
+			setSn_RXBUF_SIZE(i, j);
+		#else
+			setSn_RXBUF_SIZE(i, rxsize[i]);
+		#endif
+		}
+	#endif
    }
-
-   WIZCHIP_EXPORT(socket_reset)();
-
    return 0;
 }
 
@@ -351,12 +521,20 @@ void wizchip_clrinterrupt(intr_kind intr)
    sir &= 0x0F;
 #endif
 
-#if _WIZCHIP_ == 5100
+#if _WIZCHIP_ <= 5105
    ir |= sir;
    setIR(ir);
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_ == 5300
+   setIR( ((((uint16_t)ir) << 8) | (((uint16_t)sir) & 0x00FF)) );
 #else
    setIR(ir);
-   setSIR(sir);
+//M20200227 : For clear
+   //setSIR(sir);
+   for(ir=0; ir<8; ir++){
+       if(sir & (0x01 <<ir) ) setSn_IR(ir, 0xff);
+   }
+
 #endif   
 }
 
@@ -365,15 +543,22 @@ intr_kind wizchip_getinterrupt(void)
    uint8_t ir  = 0;
    uint8_t sir = 0;
    uint16_t ret = 0;
-#if _WIZCHIP_ == 5100
+#if _WIZCHIP_ <= 5105
    ir = getIR();
-   sir = ir 0x0F;
+   sir = ir & 0x0F;
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_  == 5300
+   ret = getIR();
+   ir = (uint8_t)(ret >> 8);
+   sir = (uint8_t)ret;
 #else
    ir  = getIR();
    sir = getSIR();
 #endif         
 
-#if _WIZCHIP_ < 5500
+//M20150601 : For Integrating with 5300
+//#if _WIZCHIP_ < 5500
+#if _WIZCHIP_ < 5200
    ir &= ~(1<<4); // IK_WOL
 #endif
 #if _WIZCHIP_ == 5200
@@ -397,11 +582,11 @@ void wizchip_setinterruptmask(intr_kind intr)
    
 #if _WIZCHIP_ < 5200
    simr &= 0x0F;
-#endif
-
-#if _WIZCHIP_ == 5100
    imr |= simr;
    setIMR(imr);
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_ == 5300
+   setIMR( ((((uint16_t)imr) << 8) | (((uint16_t)simr) & 0x00FF)) );
 #else
    setIMR(imr);
    setSIMR(simr);
@@ -413,9 +598,14 @@ intr_kind wizchip_getinterruptmask(void)
    uint8_t imr  = 0;
    uint8_t simr = 0;
    uint16_t ret = 0;
-#if _WIZCHIP_ == 5100
+#if _WIZCHIP_ < 5200
    imr  = getIMR();
-   simr = imr 0x0F;
+   simr = imr & 0x0F;
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_ == 5300
+   ret = getIMR();
+   imr = (uint8_t)(ret >> 8);
+   simr = (uint8_t)ret;
 #else
    imr  = getIMR();
    simr = getSIMR();
@@ -434,17 +624,17 @@ intr_kind wizchip_getinterruptmask(void)
 
 int8_t wizphy_getphylink(void)
 {
-   int8_t tmp;
-#if   _WIZCHIP_ == 5200
+   int8_t tmp = PHY_LINK_OFF;
+#if _WIZCHIP_ == 5105
+   if(getPHYSR() & PHYSR_LNK)
+	   tmp = PHY_LINK_ON;
+#elif   _WIZCHIP_ ==5200
    if(getPHYSTATUS() & PHYSTATUS_LINK)
       tmp = PHY_LINK_ON;
-   else
-      tmp = PHY_LINK_OFF;
 #elif _WIZCHIP_ == 5500
    if(getPHYCFGR() & PHYCFGR_LNK_ON)
       tmp = PHY_LINK_ON;
-   else
-      tmp = PHY_LINK_OFF;
+
 #else
    tmp = -1;
 #endif
@@ -462,7 +652,7 @@ int8_t wizphy_getphypmode(void)
       else          
          tmp = PHY_POWER_NORM;
    #elif _WIZCHIP_ == 5500
-      if(getPHYCFGR() & PHYCFGR_OPMDC_PDOWN)
+      if((getPHYCFGR() & PHYCFGR_OPMDC_ALLA) == PHYCFGR_OPMDC_PDOWN)
          tmp = PHY_POWER_DOWN;
       else 
          tmp = PHY_POWER_NORM;
@@ -473,13 +663,95 @@ int8_t wizphy_getphypmode(void)
 }
 #endif
 
+#if _WIZCHIP_ == 5105
+void wizphy_reset(void)
+{
+	uint16_t tmp = wiz_mdio_read(PHYMDIO_BMCR);
+	tmp |= BMCR_RESET;
+	wiz_mdio_write(PHYMDIO_BMCR, tmp);
+	while(wiz_mdio_read(PHYMDIO_BMCR)&BMCR_RESET){}
+}
+
+void wizphy_setphyconf(wiz_PhyConf* phyconf)
+{
+   uint16_t tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   if(phyconf->mode == PHY_MODE_AUTONEGO)
+      tmp |= BMCR_AUTONEGO;
+   else
+   {
+	  tmp &= ~BMCR_AUTONEGO;
+      if(phyconf->duplex == PHY_DUPLEX_FULL)
+      {
+    	  tmp |= BMCR_DUP;
+      }
+      else
+      {
+    	  tmp &= ~BMCR_DUP;
+      }
+      if(phyconf->speed == PHY_SPEED_100)
+      {
+    	  tmp |= BMCR_SPEED;
+      }
+      else
+      {
+    	  tmp &= ~BMCR_SPEED;
+      }
+   }
+   wiz_mdio_write(PHYMDIO_BMCR, tmp);
+}
+
+void wizphy_getphyconf(wiz_PhyConf* phyconf)
+{
+   uint16_t tmp = 0;
+   tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   phyconf->by   = PHY_CONFBY_SW;
+   if(tmp & BMCR_AUTONEGO)
+   {
+	   phyconf->mode = PHY_MODE_AUTONEGO;
+   }
+   else
+   {
+	   phyconf->mode = PHY_MODE_MANUAL;
+	   if(tmp&BMCR_DUP) phyconf->duplex = PHY_DUPLEX_FULL;
+	   else phyconf->duplex = PHY_DUPLEX_HALF;
+	   if(tmp&BMCR_SPEED) phyconf->speed = PHY_SPEED_100;
+	   else phyconf->speed = PHY_SPEED_10;
+   }
+}
+
+int8_t wizphy_setphypmode(uint8_t pmode)
+{
+   uint16_t tmp = 0;
+   tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   if( pmode == PHY_POWER_DOWN)
+   {
+      tmp |= BMCR_PWDN;
+   }
+   else
+   {
+	   tmp &= ~BMCR_PWDN;
+   }
+   wiz_mdio_write(PHYMDIO_BMCR, tmp);
+   tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   if( pmode == PHY_POWER_DOWN)
+   {
+      if(tmp & BMCR_PWDN) return 0;
+   }
+   else
+   {
+      if((tmp & BMCR_PWDN) != BMCR_PWDN) return 0;
+   }
+   return -1;
+}
+
+#endif
 #if _WIZCHIP_ == 5500
 void wizphy_reset(void)
 {
    uint8_t tmp = getPHYCFGR();
    tmp &= PHYCFGR_RST;
    setPHYCFGR(tmp);
-   tmp = getPHYCFGR(); 
+   tmp = getPHYCFGR();
    tmp |= ~PHYCFGR_RST;
    setPHYCFGR(tmp);
 }
@@ -592,12 +864,6 @@ void wizchip_setnetinfo(wiz_NetInfo* pnetinfo)
    setGAR(pnetinfo->gw);
    setSUBR(pnetinfo->sn);
    setSIPR(pnetinfo->ip);
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-   _SUBN_[0] = pnetinfo->sn[0];
-   _SUBN_[1] = pnetinfo->sn[1];
-   _SUBN_[2] = pnetinfo->sn[2];
-   _SUBN_[3] = pnetinfo->sn[3];
-#endif
    _DNS_[0] = pnetinfo->dns[0];
    _DNS_[1] = pnetinfo->dns[1];
    _DNS_[2] = pnetinfo->dns[2];
@@ -611,12 +877,6 @@ void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
    getGAR(pnetinfo->gw);
    getSUBR(pnetinfo->sn);
    getSIPR(pnetinfo->ip);
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-   pnetinfo->sn[0] = _SUBN_[0];
-   pnetinfo->sn[1] = _SUBN_[1];
-   pnetinfo->sn[2] = _SUBN_[2];
-   pnetinfo->sn[3] = _SUBN_[3];
-#endif
    pnetinfo->dns[0]= _DNS_[0];
    pnetinfo->dns[1]= _DNS_[1];
    pnetinfo->dns[2]= _DNS_[2];
@@ -624,16 +884,10 @@ void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
    pnetinfo->dhcp  = _DHCP_;
 }
 
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-uint8_t *wizchip_getsubn(void) {
-    return _SUBN_;
-}
-#endif
-
 int8_t wizchip_setnetmode(netmode_type netmode)
 {
    uint8_t tmp = 0;
-#if _WIZCHIP_ != 5500   
+#if _WIZCHIP_ != 5500
    if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
 #else
    if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
@@ -659,4 +913,4 @@ void wizchip_gettimeout(wiz_NetTimeout* nettime)
 {
    nettime->retry_cnt = getRCR();
    nettime->time_100us = getRTR();
-}
+}
\ No newline at end of file
diff --git a/drivers/wiznet5k/ethernet/wizchip_conf.h b/drivers/wiznet5k/ethernet/wizchip_conf.h
index 4a7a7bd69..350b34f10 100644
--- a/drivers/wiznet5k/ethernet/wizchip_conf.h
+++ b/drivers/wiznet5k/ethernet/wizchip_conf.h
@@ -5,6 +5,10 @@
 //! \version 1.0.0
 //! \date 2013/10/21
 //! \par  Revision history
+//!       <2015/02/05> Notice
+//!        The version history is not updated after this point.
+//!        Download the latest version directly from GitHub. Please visit the our GitHub repository for ioLibrary.
+//!        >> https://github.com/Wiznet/ioLibrary_Driver
 //!       <2013/10/21> 1st Release
 //! \author MidnightCow
 //! \copyright
@@ -32,7 +36,7 @@
 //! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 //! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 //! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 //! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 //! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
 //! THE POSSIBILITY OF SUCH DAMAGE.
@@ -50,14 +54,21 @@
 #ifndef  _WIZCHIP_CONF_H_
 #define  _WIZCHIP_CONF_H_
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #include <stdint.h>
 /**
  * @brief Select WIZCHIP.
- * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
- *       ex> <code> #define \_WIZCHIP_      5500 </code>
+ * @todo You should select one, \b 5100, \b 5105, \b 5200, \b 5300, \b 5500 or etc. \n\n
+ *       ex> <code> #define \_WIZCHIP_      W5500 </code>
  */
+
+
+
 #ifndef _WIZCHIP_
-#define _WIZCHIP_                      5200   // 5100, 5200, 5500
+#define _WIZCHIP_                      5200   // 5100, 5200, 5500,5105(w5100s)
 #endif
 
 #define _WIZCHIP_IO_MODE_NONE_         0x0000
@@ -73,7 +84,7 @@
 
 #define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
 #define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
-
+#define _WIZCHIP_IO_MODE_SPI_5500_     (_WIZCHIP_IO_MODE_SPI_ + 3) /**< SPI interface mode for fixed length data mode*/
 
 #if   (_WIZCHIP_ == 5100)
    #define _WIZCHIP_ID_                "W5100\0"
@@ -81,19 +92,41 @@
  * @brief Define interface mode.
  * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
  */
+// 	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
+//	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
+   	   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
 
-// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
-// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
-   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
+//A20150601 : Define the unit of IO DATA.   
+   typedef   uint8_t   iodata_t;
+//A20150401 : Indclude W5100.h file
+   #include "W5100/w5100.h"
 
+#elif (_WIZCHIP_ == 5105)
+#define _WIZCHIP_ID_                "W5100S\0"
+/**
+* @brief Define interface mode.
+* @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
+*/
+//	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
+	//#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_5500_
+	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
+
+//A20150601 : Define the unit of IO DATA.
+   typedef   uint8_t   iodata_t;
+//A20150401 : Indclude W5100.h file
+	#include "w5105/w5105.h"
 #elif (_WIZCHIP_ == 5200)
    #define _WIZCHIP_ID_                "W5200\0"
 /**
  * @brief Define interface mode.
- * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
+ * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \	_WIZCHIP_IO_MODE_BUS_INDIR_
  */
+#ifndef _WIZCHIP_IO_MODE_
 // #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
    #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
+#endif
+//A20150601 : Define the unit of IO DATA.   
+   typedef   uint8_t   iodata_t;
    #include "w5200/w5200.h"
 #elif (_WIZCHIP_ == 5500)
   #define _WIZCHIP_ID_                 "W5500\0"
@@ -102,8 +135,8 @@
  * @brief Define interface mode. \n
  * @todo Should select interface mode as chip. 
  *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
- *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
- *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
+ *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == W5500 \n
+ *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == W5500 \n
  *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
  *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
  *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
@@ -111,10 +144,42 @@
  *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
  *       
  */
+#ifndef _WIZCHIP_IO_MODE_
    //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
    #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
+#endif
+//A20150601 : Define the unit of IO DATA.   
+   typedef   uint8_t   iodata_t;
    #include "w5500/w5500.h"
-#else 
+#elif ( _WIZCHIP_ == W5300)
+   #define _WIZCHIP_ID_                 "W5300\0"
+/**
+ * @brief Define interface mode.
+ * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
+ */
+#ifndef _WIZCHIP_IO_MODE_
+   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
+// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
+#endif
+
+//A20150601 : Define the unit and bus width of IO DATA. 
+   /**
+    * @brief Select the data width 8 or 16 bits.
+    * @todo you should select the bus width. Select one of 8 or 16.
+    */
+   #ifndef _WIZCHIP_IO_BUS_WIDTH_
+   #define _WIZCHIP_IO_BUS_WIDTH_       16  // 8
+   #endif
+   #if _WIZCHIP_IO_BUS_WIDTH_ == 8
+      typedef   uint8_t   iodata_t;
+   #elif _WIZCHIP_IO_BUS_WIDTH_ == 16
+      typedef   uint16_t   iodata_t;
+   #else
+      #error "Unknown _WIZCHIP_IO_BUS_WIDTH_. It should be 8 or 16."	
+   #endif
+//
+   #include "W5300/w5300.h"
+#else
    #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
 #endif
 
@@ -128,9 +193,20 @@
  *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
  *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
  */
-#define _WIZCHIP_IO_BASE_              0x00000000  // 
+#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_
+//	#define _WIZCHIP_IO_BASE_				0x60000000	// for 5100S IND
+	#define _WIZCHIP_IO_BASE_				0x68000000	// for W5300
+#elif _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_
+	#define _WIZCHIP_IO_BASE_				0x00000000	// for 5100S SPI
+#endif
+
+#ifndef _WIZCHIP_IO_BASE_
+#define _WIZCHIP_IO_BASE_              0x00000000  // 0x8000
+#endif
 
-#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
+//M20150401 : Typing Error
+//#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
+#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_
    #ifndef _WIZCHIP_IO_BASE_
       #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
    #endif
@@ -153,7 +229,7 @@
 typedef struct __WIZCHIP
 {
    uint16_t  if_mode;               ///< host interface mode
-   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
+   uint8_t   id[8];                 ///< @b WIZCHIP ID such as @b 5100, @b 5100S, @b 5200, @b 5500, and so on.
    /**
     * The set of critical section callback func.
     */
@@ -163,7 +239,7 @@ typedef struct __WIZCHIP
       void (*_exit) (void);         ///< critial section exit  
    }CRIS;  
    /**
-    *  The set of @ref\_WIZCHIP_ select control callback func.
+    *  The set of @ref \_WIZCHIP_ select control callback func.
     */
    struct _CS
    {
@@ -177,12 +253,19 @@ typedef struct __WIZCHIP
    {	 
       /**
        * For BUS interface IO
-       */  
+       */
+      //M20156501 : Modify the function name for integrating with W5300
+      //struct
+      //{
+      //   uint8_t  (*_read_byte)  (uint32_t AddrSel);
+      //   void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
+      //}BUS;      
       struct
       {
-         uint8_t  (*_read_byte)  (uint32_t AddrSel);
-         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
+         iodata_t  (*_read_data)   (uint32_t AddrSel);
+         void      (*_write_data)  (uint32_t AddrSel, iodata_t wb);
       }BUS;      
+
       /**
        * For SPI interface IO
        */
@@ -190,6 +273,8 @@ typedef struct __WIZCHIP
       {
          void (*_read_bytes)  (uint8_t *buf, uint32_t len);
          void (*_write_bytes) (const uint8_t *buf, uint32_t len);
+       //  void    (*_read_burst)  (uint8_t* pBuf, uint16_t len);
+       //  void    (*_write_burst) (uint8_t* pBuf, uint16_t len);
       }SPI;
       // To be added
       //
@@ -205,7 +290,7 @@ extern _WIZCHIP  WIZCHIP;
 typedef enum
 {
    CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
-   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
+   CW_INIT_WIZCHIP,    ///< Initializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
    CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
    CW_CLR_INTERRUPT,   ///< Clears interrupt
    CW_SET_INTRMASK,    ///< Masks interrupt
@@ -214,15 +299,19 @@ typedef enum
    CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
    CW_GET_ID,          ///< Gets WIZCHIP name.
 
-#if _WIZCHIP_ ==  5500
-   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
-   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
-   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
-   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
-   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
-#endif
-   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
-   CW_GET_PHYLINK      ///< Get PHY Link status
+//D20150601 : For no modification your application code
+//#if _WIZCHIP_ ==  W5500
+   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5500
+   CW_SET_PHYCONF,     ///< When PHY configured by internal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000
+   CW_GET_PHYCONF,     ///< Get PHY operation mode in internal register. Valid Only W5500
+   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5500
+   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as normal and down when PHYSTATUS.OPMD == 1. Valid Only W5500
+//#endif
+//D20150601 : For no modification your application code
+//#if _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
+   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal, Valid Only W5100, W5200
+   CW_GET_PHYLINK      ///< Get PHY Link status, Valid Only W5100, W5200
+//#endif
 }ctlwizchip_type;
 
 /**
@@ -247,14 +336,16 @@ typedef enum
  */
 typedef enum
 {
-#if _WIZCHIP_ > 5200
+#if   _WIZCHIP_ == 5500
    IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
+#elif _WIZCHIP_ == 5300
+   IK_FMTU              = (1 << 4),   ///< Received a ICMP message (Fragment MTU)   
 #endif   
 
    IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
 
 #if _WIZCHIP_ != 5200
-   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
+   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreachable, No use in W5200
 #endif   
 
    IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
@@ -263,17 +354,17 @@ typedef enum
    IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
    IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
    IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
-#if _WIZCHIP_ > 5100   
+#if _WIZCHIP_ > 5105
    IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
    IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
    IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
    IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
 #endif   
 
-#if _WIZCHIP_ > 5100
-   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
+#if _WIZCHIP_ > 5105
+   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrupt
 #else
-   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
+   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrupt
 #endif      
 }intr_kind;
 
@@ -291,7 +382,7 @@ typedef enum
 #define PHY_POWER_DOWN           1     ///< PHY power down mode 
 
 
-#if _WIZCHIP_ == 5500 
+#if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5500
 /**
  * @ingroup DATA_TYPE
  *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
@@ -339,7 +430,7 @@ typedef struct wiz_NetInfo_t
  */
 typedef enum
 {
-#if _WIZCHIP_ == 5500   
+#if _WIZCHIP_ == 5500
    NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
 #endif   
    NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
@@ -385,18 +476,30 @@ void reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
  *or register your functions.
  *@note If you do not describe or register, null function is called.
  */
-void reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
+//M20150601 : For integrating with W5300
+//void reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
+void reg_wizchip_bus_cbfunc(iodata_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, iodata_t wb));
 
 /**
  *@brief Registers call back function for SPI interface.
- *@param spi_rb : callback function to read byte usig SPI 
- *@param spi_wb : callback function to write byte usig SPI 
+ *@param spi_rb : callback function to read byte using SPI
+ *@param spi_wb : callback function to write byte using SPI
  *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
  *or register your functions.
  *@note If you do not describe or register, null function is called.
  */
 void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(const uint8_t *, uint32_t));
 
+/**
+ *@brief Registers call back function for SPI interface.
+ *@param spi_rb : callback function to burst read using SPI
+ *@param spi_wb : callback function to burst write using SPI
+ *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
+ *or register your functions.
+ *@note If you do not describe or register, null function is called.
+ */
+void reg_wizchip_spiburst_cbfunc(void (*spi_rb)(uint8_t* pBuf, uint16_t len), void (*spi_wb)(uint8_t* pBuf, uint16_t len));
+
 /**
  * @ingroup extra_functions
  * @brief Controls to the WIZCHIP.
@@ -470,12 +573,13 @@ void wizchip_setinterruptmask(intr_kind intr);
  */
 intr_kind wizchip_getinterruptmask(void);
 
+//todo
 #if _WIZCHIP_ > 5100
    int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
    int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
 #endif
 
-#if _WIZCHIP_ == 5500
+#if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5500
    void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
 /**
  * @ingroup extra_functions
@@ -517,10 +621,6 @@ void wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
  */
 void wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
 
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-uint8_t *wizchip_getsubn(void);
-#endif
-
 /**
  * @ingroup extra_functions
  * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
@@ -537,18 +637,21 @@ netmode_type wizchip_getnetmode(void);
 
 /**
  * @ingroup extra_functions
- * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
- * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
- * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
+ * @brief Set retry time value(@ref _RTR_) and retry count(@ref _RCR_).
+ * @details @ref _RTR_ configures the retransmission timeout period and @ref _RCR_ configures the number of time of retransmission.  
+ * @param nettime @ref _RTR_ value and @ref _RCR_ value. Refer to @ref wiz_NetTimeout. 
  */
 void wizchip_settimeout(wiz_NetTimeout* nettime);
 
 /**
  * @ingroup extra_functions
- * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
- * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
- * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
+ * @brief Get retry time value(@ref _RTR_) and retry count(@ref _RCR_).
+ * @details @ref _RTR_ configures the retransmission timeout period and @ref _RCR_ configures the number of time of retransmission.  
+ * @param nettime @ref _RTR_ value and @ref _RCR_ value. Refer to @ref wiz_NetTimeout. 
  */
 void wizchip_gettimeout(wiz_NetTimeout* nettime);
+#ifdef __cplusplus
+ }
+#endif
 
-#endif   // _WIZCHIP_CONF_H_
+#endif   // _WIZCHIP_CONF_H_
\ No newline at end of file
diff --git a/drivers/wiznet5k/internet/dhcp/dhcp.c b/drivers/wiznet5k/internet/dhcp/dhcp.c
index 574758259..dfc057bb8 100644
--- a/drivers/wiznet5k/internet/dhcp/dhcp.c
+++ b/drivers/wiznet5k/internet/dhcp/dhcp.c
@@ -51,13 +51,15 @@
 
 //#include "Ethernet/socket.h"
 //#include "Internet/DHCP/dhcp.h"
-#include "../../Ethernet/socket.h"
+#include "../../ethernet/socket.h"
 #include "dhcp.h"
-
+#include "py/mphal.h"
+//#include "py/runtime.h"
 /* If you want to display debug & processing message, Define _DHCP_DEBUG_ in dhcp.h */
 
 #ifdef _DHCP_DEBUG_
    #include <stdio.h>
+
 #endif   
 
 /* DHCP state machine. */
@@ -258,6 +260,8 @@ void default_ip_assign(void)
    setSIPR(DHCP_allocated_ip);
    setSUBR(DHCP_allocated_sn);
    setGAR (DHCP_allocated_gw);
+   setSHAR(DHCP_CHADDR);
+
 }
 
 /* The default handler of ip changed */
@@ -403,12 +407,12 @@ void send_DHCP_DISCOVER(void)
 	ip[1] = 255;
 	ip[2] = 255;
 	ip[3] = 255;
-
+    
 #ifdef _DHCP_DEBUG_
 	printf("> Send DHCP_DISCOVER\r\n");
 #endif
+	WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 
-	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 }
 
 /* SEND DHCP REQUEST */
@@ -503,7 +507,7 @@ void send_DHCP_REQUEST(void)
 	printf("> Send DHCP_REQUEST\r\n");
 #endif
 	
-	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
+	WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 
 }
 
@@ -564,7 +568,7 @@ void send_DHCP_DECLINE(void)
 	printf("\r\n> Send DHCP_DECLINE\r\n");
 #endif
 
-	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
+	WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 }
 
 /* PARSE REPLY pDHCPMSG */
@@ -576,17 +580,20 @@ int8_t parseDHCPMSG(void)
 
 	uint8_t * p;
 	uint8_t * e;
-	uint8_t type;
+	int8_t type=0;
 	uint8_t opt_len;
    
    if((len = getSn_RX_RSR(DHCP_SOCKET)) > 0)
    {
-   	len = recvfrom(DHCP_SOCKET, (uint8_t *)pDHCPMSG, len, svr_addr, &svr_port);
+   	len = WIZCHIP_EXPORT(recvfrom)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, len, svr_addr, &svr_port);
    #ifdef _DHCP_DEBUG_   
       printf("DHCP message : %d.%d.%d.%d(%d) %d received. \r\n",svr_addr[0],svr_addr[1],svr_addr[2], svr_addr[3],svr_port, len);
    #endif   
    }
-   else return 0;
+   else 
+   {
+	   return 0;
+   }
 	if (svr_port == DHCP_SERVER_PORT) {
       // compare mac address
 		if ( (pDHCPMSG->chaddr[0] != DHCP_CHADDR[0]) || (pDHCPMSG->chaddr[1] != DHCP_CHADDR[1]) ||
@@ -673,11 +680,10 @@ uint8_t DHCP_run(void)
 {
 	uint8_t  type;
 	uint8_t  ret;
-
 	if(dhcp_state == STATE_DHCP_STOP) return DHCP_STOPPED;
 
 	if(getSn_SR(DHCP_SOCKET) != SOCK_UDP)
-	   socket(DHCP_SOCKET, Sn_MR_UDP, DHCP_CLIENT_PORT, 0x00);
+	   WIZCHIP_EXPORT(socket)(DHCP_SOCKET, Sn_MR_UDP, DHCP_CLIENT_PORT, 0x00);
 
 	ret = DHCP_RUNNING;
 	type = parseDHCPMSG();
@@ -692,7 +698,7 @@ uint8_t DHCP_run(void)
    		dhcp_state = STATE_DHCP_DISCOVER;
    		break;
 		case STATE_DHCP_DISCOVER :
-			if (type == DHCP_OFFER){
+		if (type == DHCP_OFFER){
 #ifdef _DHCP_DEBUG_
 				printf("> Receive DHCP_OFFER\r\n");
 #endif
@@ -801,32 +807,36 @@ uint8_t DHCP_run(void)
 
 void    DHCP_stop(void)
 {
-   close(DHCP_SOCKET);
+   WIZCHIP_EXPORT(close)(DHCP_SOCKET);
    dhcp_state = STATE_DHCP_STOP;
 }
 
 uint8_t check_DHCP_timeout(void)
 {
 	uint8_t ret = DHCP_RUNNING;
-	
+	DHCP_time_handler();
 	if (dhcp_retry_count < MAX_DHCP_RETRY) {
 		if (dhcp_tick_next < dhcp_tick_1s) {
 
 			switch ( dhcp_state ) {
 				case STATE_DHCP_DISCOVER :
-//					printf("<<timeout>> state : STATE_DHCP_DISCOVER\r\n");
+				#ifdef _DHCP_DEBUG_
+					printf("<<timeout>> state : STATE_DHCP_DISCOVER\r\n");
+				#endif
 					send_DHCP_DISCOVER();
 				break;
 		
 				case STATE_DHCP_REQUEST :
-//					printf("<<timeout>> state : STATE_DHCP_REQUEST\r\n");
-
+				#ifdef _DHCP_DEBUG_
+					printf("<<timeout>> state : STATE_DHCP_REQUEST\r\n");
+				#endif
 					send_DHCP_REQUEST();
 				break;
 
 				case STATE_DHCP_REREQUEST :
-//					printf("<<timeout>> state : STATE_DHCP_REREQUEST\r\n");
-					
+				#ifdef _DHCP_DEBUG_
+					printf("<<timeout>> state : STATE_DHCP_REREQUEST\r\n");
+				#endif
 					send_DHCP_REQUEST();
 				break;
 		
@@ -837,6 +847,7 @@ uint8_t check_DHCP_timeout(void)
 			dhcp_tick_1s = 0;
 			dhcp_tick_next = dhcp_tick_1s + DHCP_WAIT_TIME;
 			dhcp_retry_count++;
+			
 		}
 	} else { // timeout occurred
 
@@ -869,7 +880,7 @@ int8_t check_DHCP_leasedIP(void)
 
 	// IP conflict detection : ARP request - ARP reply
 	// Broadcasting ARP Request for check the IP conflict using UDP sendto() function
-	ret = sendto(DHCP_SOCKET, (uint8_t *)"CHECK_IP_CONFLICT", 17, DHCP_allocated_ip, 5000);
+	ret = WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)"CHECK_IP_CONFLICT", 17, DHCP_allocated_ip, 5000);
 
 	// RCR value restore
 	setRCR(tmp);
@@ -896,6 +907,7 @@ int8_t check_DHCP_leasedIP(void)
 void DHCP_init(uint8_t s, uint8_t * buf)
 {
    uint8_t zeroip[4] = {0,0,0,0};
+   
    getSHAR(DHCP_CHADDR);
    if((DHCP_CHADDR[0] | DHCP_CHADDR[1]  | DHCP_CHADDR[2] | DHCP_CHADDR[3] | DHCP_CHADDR[4] | DHCP_CHADDR[5]) == 0x00)
    {
@@ -933,6 +945,7 @@ void reset_DHCP_timeout(void)
 
 void DHCP_time_handler(void)
 {
+	mp_hal_delay_ms(100);
 	dhcp_tick_1s++;
 }
 
diff --git a/drivers/wiznet5k/internet/dns/dns.c b/drivers/wiznet5k/internet/dns/dns.c
index c0ad570c0..397620070 100644
--- a/drivers/wiznet5k/internet/dns/dns.c
+++ b/drivers/wiznet5k/internet/dns/dns.c
@@ -56,11 +56,10 @@
 //#include "Internet/DNS/dns.h"
 #include "../../ethernet/socket.h"
 #include "dns.h"
-
+#include "py/mphal.h"
 #ifdef _DNS_DEBUG_
-   #include <stdio.h>
+   //#include <stdio.h>
 #endif
-
 #define	INITRTT		2000L	/* Initial smoothed response time */
 #define	MAXCNAME	   (MAX_DOMAIN_NAME + (MAX_DOMAIN_NAME>>1))	   /* Maximum amount of cname recursion */
 
@@ -121,9 +120,9 @@ uint8_t* pDNSMSG;       // DNS message buffer
 uint8_t  DNS_SOCKET;    // SOCKET number for DNS
 uint16_t DNS_MSGID;     // DNS message ID
 
-extern uint32_t HAL_GetTick(void);
+//extern uint32_t HAL_GetTick(void);
 uint32_t hal_sys_tick;
-
+volatile uint32_t dns_tick_1s      = 0;   
 /* converts uint16_t from network buffer to a host byte order integer. */
 uint16_t get16(uint8_t * s)
 {
@@ -470,6 +469,11 @@ int16_t dns_makequery(uint16_t op, char * name, uint8_t * buf, uint16_t len)
 
 	return ((int16_t)((uint32_t)(cp) - (uint32_t)(buf)));
 }
+void DNS_time_handler(void)
+{
+	mp_hal_delay_ms(100);
+	dns_tick_1s++;
+}
 
 /*
  *              CHECK DNS TIMEOUT
@@ -483,13 +487,15 @@ int16_t dns_makequery(uint16_t op, char * name, uint8_t * buf, uint16_t len)
 int8_t check_DNS_timeout(void)
 {
 	static uint8_t retry_count;
-
-    uint32_t tick = HAL_GetTick();
-	if(tick - hal_sys_tick >= DNS_WAIT_TIME * 1000)
+    // TEST
+//uint32_t tick = HAL_GetTick();
+	DNS_time_handler();
+	if(dns_tick_1s - hal_sys_tick >= DNS_WAIT_TIME * 1000)
 	{
-		hal_sys_tick = tick;
+		hal_sys_tick = dns_tick_1s;
 		if(retry_count >= MAX_DNS_RETRY) {
 			retry_count = 0;
+			dns_tick_1s = 0;
 			return -1; // timeout occurred
 		}
 		retry_count++;
@@ -517,9 +523,11 @@ int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns)
 	uint8_t ip[4];
 	uint16_t len, port;
 	int8_t ret_check_timeout;
-
-        hal_sys_tick = HAL_GetTick();
-   
+    // TEST
+       // hal_sys_tick = HAL_GetTick();
+	    DNS_time_handler();
+        hal_sys_tick = dns_tick_1s;
+	
    // Socket open
    WIZCHIP_EXPORT(socket)(DNS_SOCKET, Sn_MR_UDP, 0, 0);
 
@@ -529,7 +537,6 @@ int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns)
 
 	len = dns_makequery(0, (char *)name, pDNSMSG, MAX_DNS_BUF_SIZE);
 	WIZCHIP_EXPORT(sendto)(DNS_SOCKET, pDNSMSG, len, dns_ip, IPPORT_DOMAIN);
-
 	while (1)
 	{
 		if ((len = getSn_RX_RSR(DNS_SOCKET)) > 0)
@@ -545,14 +552,12 @@ int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns)
 		// Check Timeout
 		ret_check_timeout = check_DNS_timeout();
 		if (ret_check_timeout < 0) {
-
 #ifdef _DNS_DEBUG_
 			printf("> DNS Server is not responding : %d.%d.%d.%d\r\n", dns_ip[0], dns_ip[1], dns_ip[2], dns_ip[3]);
 #endif
 			return 0; // timeout occurred
 		}
 		else if (ret_check_timeout == 0) {
-
 #ifdef _DNS_DEBUG_
 			printf("> DNS Timeout\r\n");
 #endif
diff --git a/drivers/wiznet5k/internet/dns/dns.h b/drivers/wiznet5k/internet/dns/dns.h
index de0039515..d9c507611 100644
--- a/drivers/wiznet5k/internet/dns/dns.h
+++ b/drivers/wiznet5k/internet/dns/dns.h
@@ -65,7 +65,7 @@
  * @todo SHOULD BE defined it equal as or greater than your Domain name length + null character(1)
  * @note SHOULD BE careful to stack overflow because it is allocated 1.5 times as MAX_DOMAIN_NAME in stack.
  */
-#define  MAX_DOMAIN_NAME   32       // for example "www.google.com"
+#define  MAX_DOMAIN_NAME   100       // for example "www.google.com"
 
 #define	MAX_DNS_RETRY     2        ///< Requery Count
 #define	DNS_WAIT_TIME     4        ///< Wait response time. unit 1s.
@@ -92,5 +92,6 @@ void DNS_init(uint8_t s, uint8_t * buf);
  * @note This function blocks until success or fail. max time = @ref MAX_DNS_RETRY * @ref DNS_WAIT_TIME
  */
 int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns);
+void DNS_time_handler(void);
 
 #endif	/* _DNS_H_ */
diff --git a/extmod/axtls-include/axtls_os_port.h b/extmod/axtls-include/axtls_os_port.h
index ef2683acf..836609940 100644
--- a/extmod/axtls-include/axtls_os_port.h
+++ b/extmod/axtls-include/axtls_os_port.h
@@ -51,5 +51,5 @@
 // For esp8266 port: use the hardware RNG.
 #define PLATFORM_RNG_U8()               (*WDEV_HWRNG)
 #endif
-
+void gettimeofday(struct timeval* t, void* timezone);
 #endif // AXTLS_OS_PORT_H
diff --git a/extmod/extmod.cmake b/extmod/extmod.cmake
index 67f7d8fd3..d1c257215 100644
--- a/extmod/extmod.cmake
+++ b/extmod/extmod.cmake
@@ -2,6 +2,8 @@
 
 set(MICROPY_EXTMOD_DIR "${MICROPY_DIR}/extmod")
 set(MICROPY_OOFATFS_DIR "${MICROPY_DIR}/lib/oofatfs")
+set(MICROPY_AXTLS_DIR "${MICROPY_DIR}/lib/axtls")
+INCLUDE_DIRECTORIES(${MICROPY_AXTLS_DIR}  ${MICROPY_AXTLS_DIR}/crypto ${MICROPY_AXTLS_DIR}/ssl ${MICROPY_EXTMOD_DIR}/axtls-include)
 
 set(MICROPY_SOURCE_EXTMOD
     ${MICROPY_DIR}/shared/libc/abort_.c
diff --git a/extmod/modnetwork.c b/extmod/modnetwork.c
index 1f242de86..4567746ef 100644
--- a/extmod/modnetwork.c
+++ b/extmod/modnetwork.c
@@ -71,7 +71,7 @@ mp_obj_t mod_network_find_nic(const uint8_t *ip) {
     for (mp_uint_t i = 0; i < MP_STATE_PORT(mod_network_nic_list).len; i++) {
         mp_obj_t nic = MP_STATE_PORT(mod_network_nic_list).items[i];
         // TODO check IP suitability here
-        // mod_network_nic_type_t *nic_type = (mod_network_nic_type_t*)mp_obj_get_type(nic);
+        //mod_network_nic_type_t *nic_type = (mod_network_nic_type_t*)mp_obj_get_type(nic);
         return nic;
     }
 
@@ -89,10 +89,14 @@ STATIC const mp_rom_map_elem_t mp_module_network_globals_table[] = {
 
     // Defined per port in mpconfigport.h
     MICROPY_PORT_NETWORK_INTERFACES
-
+#if MICROPY_PY_WIZNET5K
+    { MP_ROM_QSTR(MP_QSTR_WIZNET5K), MP_ROM_PTR(&mod_network_nic_type_wiznet5k) },
+#endif
     // Constants
+#if MICROPY_PY_NETWORK_CYW43
     { MP_ROM_QSTR(MP_QSTR_STA_IF), MP_ROM_INT(MOD_NETWORK_STA_IF) },
     { MP_ROM_QSTR(MP_QSTR_AP_IF), MP_ROM_INT(MOD_NETWORK_AP_IF) },
+#endif
 };
 
 STATIC MP_DEFINE_CONST_DICT(mp_module_network_globals, mp_module_network_globals_table);
@@ -149,7 +153,7 @@ mp_obj_t mod_network_nic_ifconfig(struct netif *netif, size_t n_args, const mp_o
         netutils_parse_ipv4_addr(items[2], (uint8_t *)&netif->gw, NETUTILS_BIG);
         ip_addr_t dns;
         netutils_parse_ipv4_addr(items[3], (uint8_t *)&dns, NETUTILS_BIG);
-        dns_setserver(0, &dns);
+        //dns_setserver(0, &dns);
         return mp_const_none;
     }
 }
diff --git a/extmod/modusocket.c b/extmod/modusocket.c
index a42b3213f..5c9c67355 100644
--- a/extmod/modusocket.c
+++ b/extmod/modusocket.c
@@ -36,7 +36,6 @@
 #include "modnetwork.h"
 
 #if MICROPY_PY_NETWORK && MICROPY_PY_USOCKET && !MICROPY_PY_LWIP
-
 /******************************************************************************/
 // socket class
 
@@ -458,20 +457,41 @@ STATIC const mp_obj_type_t socket_type = {
 
 /******************************************************************************/
 // usocket module
-
 // function usocket.getaddrinfo(host, port)
-STATIC mp_obj_t mod_usocket_getaddrinfo(mp_obj_t host_in, mp_obj_t port_in) {
+STATIC mp_obj_t mod_usocket_getaddrinfo(size_t n_args, const mp_obj_t *args) {
     size_t hlen;
-    const char *host = mp_obj_str_get_data(host_in, &hlen);
-    mp_int_t port = mp_obj_get_int(port_in);
+    const char *host = mp_obj_str_get_data(args[0], &hlen);
+    mp_int_t port = mp_obj_get_int(args[1]);
     uint8_t out_ip[MOD_NETWORK_IPADDR_BUF_SIZE];
     bool have_ip = false;
 
+    // if constraints were passed then check they are compatible with the supported params
+    if (n_args > 2) {
+        mp_int_t family = mp_obj_get_int(args[2]);
+        mp_int_t type = 0;
+        mp_int_t proto = 0;
+        mp_int_t flags = 0;
+        if (n_args > 3) {
+            type = mp_obj_get_int(args[3]);
+            if (n_args > 4) {
+                proto = mp_obj_get_int(args[4]);
+                if (n_args > 5) {
+                    flags = mp_obj_get_int(args[5]);
+                }
+            }
+        }
+        if (!((family == 0 || family == MOD_NETWORK_AF_INET)
+              && (type == 0 || type == MOD_NETWORK_SOCK_STREAM)
+              && proto == 0
+              && flags == 0)) {
+            mp_warning(MP_WARN_CAT(RuntimeWarning), "unsupported getaddrinfo constraints");
+        }
+    }
     if (hlen > 0) {
         // check if host is already in IP form
         nlr_buf_t nlr;
         if (nlr_push(&nlr) == 0) {
-            netutils_parse_ipv4_addr(host_in, out_ip, NETUTILS_BIG);
+            netutils_parse_ipv4_addr(args[0], out_ip, NETUTILS_BIG);
             have_ip = true;
             nlr_pop();
         } else {
@@ -494,7 +514,6 @@ STATIC mp_obj_t mod_usocket_getaddrinfo(mp_obj_t host_in, mp_obj_t port_in) {
             }
         }
     }
-
     if (!have_ip) {
         mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT("no available NIC"));
     }
@@ -507,7 +526,7 @@ STATIC mp_obj_t mod_usocket_getaddrinfo(mp_obj_t host_in, mp_obj_t port_in) {
     tuple->items[4] = netutils_format_inet_addr(out_ip, port, NETUTILS_BIG);
     return mp_obj_new_list(1, (mp_obj_t *)&tuple);
 }
-STATIC MP_DEFINE_CONST_FUN_OBJ_2(mod_usocket_getaddrinfo_obj, mod_usocket_getaddrinfo);
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_usocket_getaddrinfo_obj, 2, 6, mod_usocket_getaddrinfo);
 
 STATIC const mp_rom_map_elem_t mp_module_usocket_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_usocket) },
diff --git a/extmod/modussl_axtls.c b/extmod/modussl_axtls.c
index 9d5934206..4aaa9c997 100644
--- a/extmod/modussl_axtls.c
+++ b/extmod/modussl_axtls.c
@@ -32,9 +32,7 @@
 #include "py/objstr.h"
 
 #if MICROPY_PY_USSL && MICROPY_SSL_AXTLS
-
 #include "ssl.h"
-
 typedef struct _mp_obj_ssl_socket_t {
     mp_obj_base_t base;
     mp_obj_t sock;
@@ -87,8 +85,7 @@ STATIC const char *const ssl_error_tab2[] = {
 STATIC NORETURN void ussl_raise_error(int err) {
     MP_STATIC_ASSERT(SSL_NOT_OK - 3 == SSL_EAGAIN);
     MP_STATIC_ASSERT(SSL_ERROR_CONN_LOST - 18 == SSL_ERROR_NOT_SUPPORTED);
-
-    // Check if err corresponds to something in one of the error string tables.
+    // Check if err corresponds to something in one of the error string tables .
     const char *errstr = NULL;
     if (SSL_NOT_OK >= err && err >= SSL_EAGAIN) {
         errstr = ssl_error_tab1[SSL_NOT_OK - err];
@@ -128,26 +125,27 @@ STATIC mp_obj_ssl_socket_t *ussl_socket_new(mp_obj_t sock, struct ssl_args *args
     o->bytes_left = 0;
     o->sock = sock;
     o->blocking = true;
-
     uint32_t options = SSL_SERVER_VERIFY_LATER;
     if (!args->do_handshake.u_bool) {
         options |= SSL_CONNECT_IN_PARTS;
     }
+    
     if (args->key.u_obj != mp_const_none) {
         options |= SSL_NO_DEFAULT_KEY;
+        
     }
+    
     if ((o->ssl_ctx = ssl_ctx_new(options, SSL_DEFAULT_CLNT_SESS)) == NULL) {
         mp_raise_OSError(MP_EINVAL);
     }
-
     if (args->key.u_obj != mp_const_none) {
         size_t len;
         const byte *data = (const byte *)mp_obj_str_get_data(args->key.u_obj, &len);
         int res = ssl_obj_memory_load(o->ssl_ctx, SSL_OBJ_RSA_KEY, data, len, NULL);
         if (res != SSL_OK) {
+            
             mp_raise_ValueError(MP_ERROR_TEXT("invalid key"));
         }
-
         data = (const byte *)mp_obj_str_get_data(args->cert.u_obj, &len);
         res = ssl_obj_memory_load(o->ssl_ctx, SSL_OBJ_X509_CERT, data, len, NULL);
         if (res != SSL_OK) {
@@ -159,16 +157,15 @@ STATIC mp_obj_ssl_socket_t *ussl_socket_new(mp_obj_t sock, struct ssl_args *args
         o->ssl_sock = ssl_server_new(o->ssl_ctx, (long)sock);
     } else {
         SSL_EXTENSIONS *ext = ssl_ext_new();
-
-        if (args->server_hostname.u_obj != mp_const_none) {
+    
+    if (args->server_hostname.u_obj != mp_const_none) {
             ext->host_name = (char *)mp_obj_str_get_str(args->server_hostname.u_obj);
         }
-
+    
         o->ssl_sock = ssl_client_new(o->ssl_ctx, (long)sock, NULL, 0, ext);
-
         if (args->do_handshake.u_bool) {
             int r = ssl_handshake_status(o->ssl_sock);
-
+        
             if (r != SSL_OK) {
                 if (r == SSL_CLOSE_NOTIFY) { // EOF
                     r = MP_ENOTCONN;
@@ -241,7 +238,7 @@ STATIC mp_uint_t ussl_socket_read(mp_obj_t o_in, void *buf, mp_uint_t size, int
 
 STATIC mp_uint_t ussl_socket_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {
     mp_obj_ssl_socket_t *o = MP_OBJ_TO_PTR(o_in);
-
+    
     if (o->ssl_sock == NULL) {
         *errcode = EBADF;
         return MP_STREAM_ERROR;
@@ -340,8 +337,7 @@ STATIC mp_obj_t mod_ssl_wrap_socket(size_t n_args, const mp_obj_t *pos_args, mp_
 
     struct ssl_args args;
     mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,
-        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args);
-
+    MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args);
     return MP_OBJ_FROM_PTR(ussl_socket_new(sock, &args));
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_KW(mod_ssl_wrap_socket_obj, 1, mod_ssl_wrap_socket);
diff --git a/lib/axtls b/lib/axtls
--- a/lib/axtls
+++ b/lib/axtls
@@ -1 +1 @@
-Subproject commit 531cab9c278c947d268bd4c94ecab9153a961b43
+Subproject commit 531cab9c278c947d268bd4c94ecab9153a961b43-dirty
diff --git a/ports/rp2/CMakeLists.txt b/ports/rp2/CMakeLists.txt
index 0009ab2cd..3024fd781 100644
--- a/ports/rp2/CMakeLists.txt
+++ b/ports/rp2/CMakeLists.txt
@@ -53,6 +53,10 @@ pico_sdk_init()
 
 include(${MICROPY_DIR}/py/usermod.cmake)
 
+if (MICROPY_PY_WIZNET5K)
+   INCLUDE_DIRECTORIES(${MICROPY_DIR}/drivers/wiznet5k/ ${MICROPY_DIR}/drivers/wiznet5k/ethernet/w${MICROPY_PY_WIZNET5K}) 
+endif()
+
 add_executable(${MICROPY_TARGET})
 
 set(MICROPY_QSTRDEFS_PORT
@@ -75,19 +79,52 @@ set(MICROPY_SOURCE_LIB
     ${MICROPY_DIR}/shared/runtime/stdout_helpers.c
     ${MICROPY_DIR}/shared/runtime/sys_stdio_mphal.c
     ${MICROPY_DIR}/shared/timeutils/timeutils.c
-)
+    # axtls
+    ${MICROPY_DIR}/lib/axtls/ssl/loader.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/tls1.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/tls1_svr.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/tls1_clnt.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/x509.c
+    ${MICROPY_DIR}/lib/axtls/ssl/openssl.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/os_port.c
+    ${MICROPY_DIR}/lib/axtls/ssl/asn1.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/aes.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/bigint.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/crypto_misc.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/md5.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/rsa.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/sha1.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/hmac.c 
 
-set(MICROPY_SOURCE_DRIVERS
-    ${MICROPY_DIR}/drivers/bus/softspi.c
-    ${MICROPY_DIR}/drivers/dht/dht.c
 )
 
+
+if (MICROPY_PY_WIZNET5K)
+    set(MICROPY_SOURCE_DRIVERS
+        ${MICROPY_DIR}/drivers/bus/softspi.c
+    	${MICROPY_DIR}/drivers/wiznet5k/ethernet/w${MICROPY_PY_WIZNET5K}/w${MICROPY_PY_WIZNET5K}.c
+        ${MICROPY_DIR}/drivers/wiznet5k/ethernet/socket.c
+        ${MICROPY_DIR}/drivers/wiznet5k/ethernet/wizchip_conf.c
+        ${MICROPY_DIR}/drivers/wiznet5k/internet/dns/dns.c
+        ${MICROPY_DIR}/drivers/wiznet5k/internet/dhcp/dhcp.c
+        ${MICROPY_DIR}/extmod/modnetwork.c
+        ${MICROPY_DIR}/extmod/modusocket.c
+        ${PROJECT_SOURCE_DIR}/modnwwiznet5k.c
+#        ${MICROPY_DIR}/drivers/dht/dht.c
+      )
+else()
+    set(MICROPY_SOURCE_DRIVERS
+        ${MICROPY_DIR}/drivers/bus/softspi.c
+#        ${MICROPY_DIR}/drivers/dht/dht.c
+       )
+	
+endif()
 set(MICROPY_SOURCE_PORT
     fatfs_port.c
     machine_adc.c
-    machine_bitstream.c
+ #   machine_bitstream.c
     machine_i2c.c
-    machine_i2s.c
+ #   machine_i2s.c
     machine_pin.c
     machine_rtc.c
     machine_spi.c
@@ -113,9 +150,12 @@ set(MICROPY_SOURCE_QSTR
     ${MICROPY_SOURCE_USERMOD}
     ${MICROPY_DIR}/shared/runtime/mpirq.c
     ${MICROPY_DIR}/shared/runtime/sys_stdio_mphal.c
+    ${MICROPY_DIR}/extmod/modnetwork.c
+    ${MICROPY_DIR}/extmod/modusocket.c
+    ${MICROPY_DIR}/extmod/modussl_axtls.c
     ${PROJECT_SOURCE_DIR}/machine_adc.c
     ${PROJECT_SOURCE_DIR}/machine_i2c.c
-    ${PROJECT_SOURCE_DIR}/machine_i2s.c
+ #   ${PROJECT_SOURCE_DIR}/machine_i2s.c
     ${PROJECT_SOURCE_DIR}/machine_pin.c
     ${PROJECT_SOURCE_DIR}/machine_rtc.c
     ${PROJECT_SOURCE_DIR}/machine_spi.c
@@ -123,6 +163,7 @@ set(MICROPY_SOURCE_QSTR
     ${PROJECT_SOURCE_DIR}/machine_uart.c
     ${PROJECT_SOURCE_DIR}/machine_wdt.c
     ${PROJECT_SOURCE_DIR}/modmachine.c
+    ${PROJECT_SOURCE_DIR}/modnwwiznet5k.c
     ${PROJECT_SOURCE_DIR}/modrp2.c
     ${PROJECT_SOURCE_DIR}/moduos.c
     ${PROJECT_SOURCE_DIR}/modutime.c
@@ -191,30 +232,30 @@ if(MICROPY_BLUETOOTH_NIMBLE)
     list(APPEND MICROPY_INC_CORE ${NIMBLE_INCLUDE})
 endif()
 
-if (MICROPY_PY_NETWORK_NINAW10)
-    target_compile_definitions(${MICROPY_TARGET} PRIVATE
-        MICROPY_PY_NETWORK_NINAW10=1
-    )
-
-    target_include_directories(${MICROPY_TARGET} PRIVATE
-        ${MICROPY_DIR}/drivers/ninaw10/
-    )
-
-    # Enable NINA-W10 WiFi and Bluetooth drivers.
-    list(APPEND MICROPY_SOURCE_DRIVERS
-        ${MICROPY_DIR}/drivers/ninaw10/nina_bt_hci.c
-        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_drv.c
-        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_bsp.c
-    )
-
-    list(APPEND MICROPY_SOURCE_EXTMOD
-        ${MICROPY_DIR}/extmod/network_ninaw10.c
-    )
-
-    list(APPEND MICROPY_SOURCE_QSTR
-        ${MICROPY_DIR}/extmod/network_ninaw10.c
-    )
-endif()
+#if (MICROPY_PY_NETWORK_NINAW10)
+#    target_compile_definitions(${MICROPY_TARGET} PRIVATE
+#        MICROPY_PY_NETWORK_NINAW10=1
+#    )
+#
+#    target_include_directories(${MICROPY_TARGET} PRIVATE
+#        ${MICROPY_DIR}/drivers/ninaw10/
+#    )
+#
+#    # Enable NINA-W10 WiFi and Bluetooth drivers.
+#    list(APPEND MICROPY_SOURCE_DRIVERS
+#        ${MICROPY_DIR}/drivers/ninaw10/nina_bt_hci.c
+#        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_drv.c
+#        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_bsp.c
+#    )
+#
+#    list(APPEND MICROPY_SOURCE_EXTMOD
+#        ${MICROPY_DIR}/extmod/network_ninaw10.c
+#    )
+#
+#    list(APPEND MICROPY_SOURCE_QSTR
+#        ${MICROPY_DIR}/extmod/network_ninaw10.c
+#    )
+#endif()
 
 # Define mpy-cross flags and frozen manifest
 set(MICROPY_CROSS_FLAGS -march=armv7m)
@@ -231,14 +272,26 @@ target_sources(${MICROPY_TARGET} PRIVATE
 )
 
 target_link_libraries(${MICROPY_TARGET} usermod)
-
-target_include_directories(${MICROPY_TARGET} PRIVATE
-    ${MICROPY_INC_CORE}
-    ${MICROPY_INC_USERMOD}
-    ${MICROPY_BOARD_DIR}
-    "${PROJECT_SOURCE_DIR}"
-    "${CMAKE_BINARY_DIR}"
-)
+if (MICROPY_PY_WIZNET5K) 
+    target_include_directories(${MICROPY_TARGET} PRIVATE
+       ${MICROPY_INC_CORE}
+       ${MICROPY_INC_USERMOD}
+       ${MICROPY_BOARD_DIR}
+       "${PROJECT_SOURCE_DIR}"
+       "${CMAKE_BINARY_DIR}"
+       "${MICROPY_DIR}/driver/wiznet5k"
+       "${MICROPY_AXTLS_DIR}"
+    )
+else()
+    target_include_directories(${MICROPY_TARGET} PRIVATE
+        ${MICROPY_INC_CORE}
+        ${MICROPY_INC_USERMOD}
+        ${MICROPY_BOARD_DIR}
+        "${PROJECT_SOURCE_DIR}"
+        "${CMAKE_BINARY_DIR}"
+    )  
+endif()
+target_link_libraries(${MICROPY_TARGET} )
 
 target_compile_options(${MICROPY_TARGET} PRIVATE
     -Wall
@@ -258,20 +311,37 @@ set_source_files_properties(
     PROPERTIES
     COMPILE_OPTIONS "-Wno-error=array-bounds;-Wno-error=unused-but-set-variable"
 )
-
-target_compile_definitions(${MICROPY_TARGET} PRIVATE
-    FFCONF_H=\"${MICROPY_OOFATFS_DIR}/ffconf.h\"
-    LFS1_NO_MALLOC LFS1_NO_DEBUG LFS1_NO_WARN LFS1_NO_ERROR LFS1_NO_ASSERT
-    LFS2_NO_MALLOC LFS2_NO_DEBUG LFS2_NO_WARN LFS2_NO_ERROR LFS2_NO_ASSERT
-    PICO_FLOAT_PROPAGATE_NANS=1
-    PICO_STACK_SIZE=0x2000
-    PICO_CORE1_STACK_SIZE=0
-    PICO_PROGRAM_NAME="MicroPython"
-    PICO_NO_PROGRAM_VERSION_STRING=1 # do it ourselves in main.c
-    MICROPY_BUILD_TYPE="${CMAKE_C_COMPILER_ID} ${CMAKE_C_COMPILER_VERSION} ${CMAKE_BUILD_TYPE}"
-    PICO_NO_BI_STDIO_UART=1 # we call it UART REPL
-    PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1
-)
+if (MICROPY_PY_WIZNET5K)
+    target_compile_definitions(${MICROPY_TARGET} PRIVATE
+        FFCONF_H=\"${MICROPY_OOFATFS_DIR}/ffconf.h\"
+        LFS1_NO_MALLOC LFS1_NO_DEBUG LFS1_NO_WARN LFS1_NO_ERROR LFS1_NO_ASSERT
+        LFS2_NO_MALLOC LFS2_NO_DEBUG LFS2_NO_WARN LFS2_NO_ERROR LFS2_NO_ASSERT
+        PICO_FLOAT_PROPAGATE_NANS=1
+        PICO_STACK_SIZE=0x2000
+        PICO_CORE1_STACK_SIZE=0
+        PICO_PROGRAM_NAME="MicroPython"
+        PICO_NO_PROGRAM_VERSION_STRING=1 # do it ourselves in main.c
+        MICROPY_BUILD_TYPE="${CMAKE_C_COMPILER_ID} ${CMAKE_C_COMPILER_VERSION} ${CMAKE_BUILD_TYPE}"
+        PICO_NO_BI_STDIO_UART=1 # we call it UART REPL
+        PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1
+        -D_WIZCHIP_=${MICROPY_PY_WIZNET5K}
+        -DMICROPY_PY_WIZNET5K=${MICROPY_PY_WIZNET5K}
+   )
+else()
+    target_compile_definitions(${MICROPY_TARGET} PRIVATE
+        FFCONF_H=\"${MICROPY_OOFATFS_DIR}/ffconf.h\"
+        LFS1_NO_MALLOC LFS1_NO_DEBUG LFS1_NO_WARN LFS1_NO_ERROR LFS1_NO_ASSERT
+        LFS2_NO_MALLOC LFS2_NO_DEBUG LFS2_NO_WARN LFS2_NO_ERROR LFS2_NO_ASSERT
+        PICO_FLOAT_PROPAGATE_NANS=1
+        PICO_STACK_SIZE=0x2000
+        PICO_CORE1_STACK_SIZE=0
+        PICO_PROGRAM_NAME="MicroPython"
+        PICO_NO_PROGRAM_VERSION_STRING=1 # do it ourselves in main.c
+        MICROPY_BUILD_TYPE="${CMAKE_C_COMPILER_ID} ${CMAKE_C_COMPILER_VERSION} ${CMAKE_BUILD_TYPE}"
+        PICO_NO_BI_STDIO_UART=1 # we call it UART REPL
+        PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1
+   )
+endif()
 
 target_link_libraries(${MICROPY_TARGET}
     ${PICO_SDK_COMPONENTS}
diff --git a/ports/rp2/Makefile b/ports/rp2/Makefile
index 2af13bfbb..9d8cd7482 100644
--- a/ports/rp2/Makefile
+++ b/ports/rp2/Makefile
@@ -5,10 +5,12 @@
 BOARD ?= PICO
  
 BUILD ?= build-$(BOARD)
+MICROPY_PY_WIZNET5K ?= 5105
 
 $(VERBOSE)MAKESILENT = -s
 
 CMAKE_ARGS = -DMICROPY_BOARD=$(BOARD)
+CMAKE_ARGS += -DMICROPY_PY_WIZNET5K=$(MICROPY_PY_WIZNET5K)
 
 ifdef USER_C_MODULES
 CMAKE_ARGS += -DUSER_C_MODULES=${USER_C_MODULES}
@@ -20,8 +22,9 @@ all:
 
 clean:
 	$(RM) -rf $(BUILD)
+	$(RM) -rf out.log
 
-GIT_SUBMODULES += lib/pico-sdk lib/tinyusb
+GIT_SUBMODULES += lib/pico-sdk lib/tinyusb lib/axtls
 
 submodules:
 	$(MAKE) -f ../../py/mkrules.mk GIT_SUBMODULES="$(GIT_SUBMODULES)" submodules
diff --git a/ports/rp2/boards/manifest.py b/ports/rp2/boards/manifest.py
index b0e5e3155..a7850d269 100644
--- a/ports/rp2/boards/manifest.py
+++ b/ports/rp2/boards/manifest.py
@@ -1,5 +1,7 @@
 freeze("$(PORT_DIR)/modules")
 freeze("$(MPY_DIR)/drivers/onewire")
-freeze("$(MPY_DIR)/drivers/dht", "dht.py")
+#freeze('$(MPY_DIR)/drivers/dht', 'dht.py')
+freeze('$(MPY_DIR)/tools','upip.py')
+freeze('$(MPY_DIR)/tools','upip_utarfile.py',opt=3)
 include("$(MPY_DIR)/extmod/uasyncio/manifest.py")
-include("$(MPY_DIR)/drivers/neopixel/manifest.py")
+#include("$(MPY_DIR)/drivers/neopixel/manifest.py")
diff --git a/ports/rp2/machine_i2s.c b/ports/rp2/machine_i2s.c
index ec64f72ec..9561a4070 100644
--- a/ports/rp2/machine_i2s.c
+++ b/ports/rp2/machine_i2s.c
@@ -227,13 +227,13 @@ STATIC uint8_t dma_get_bits(i2s_mode_t mode, int8_t bits);
 STATIC void dma_irq0_handler(void);
 STATIC void dma_irq1_handler(void);
 STATIC mp_obj_t machine_i2s_deinit(mp_obj_t self_in);
-
+/*
 void machine_i2s_init0(void) {
     for (uint8_t i = 0; i < MAX_I2S_RP2; i++) {
         MP_STATE_PORT(machine_i2s_obj[i]) = NULL;
     }
 }
-
+*/
 // Ring Buffer
 // Thread safe when used with these constraints:
 // - Single Producer, Single Consumer
diff --git a/ports/rp2/machine_spi.c b/ports/rp2/machine_spi.c
index 332f44694..4e7fa787e 100644
--- a/ports/rp2/machine_spi.c
+++ b/ports/rp2/machine_spi.c
@@ -24,51 +24,9 @@
  * THE SOFTWARE.
  */
 
-#include "py/runtime.h"
-#include "py/mphal.h"
-#include "py/mperrno.h"
-#include "extmod/machine_spi.h"
-#include "modmachine.h"
 
-#include "hardware/spi.h"
-#include "hardware/dma.h"
-
-#define DEFAULT_SPI_BAUDRATE    (1000000)
-#define DEFAULT_SPI_POLARITY    (0)
-#define DEFAULT_SPI_PHASE       (0)
-#define DEFAULT_SPI_BITS        (8)
-#define DEFAULT_SPI_FIRSTBIT    (SPI_MSB_FIRST)
-
-#ifndef MICROPY_HW_SPI0_SCK
-#define MICROPY_HW_SPI0_SCK     (6)
-#define MICROPY_HW_SPI0_MOSI    (7)
-#define MICROPY_HW_SPI0_MISO    (4)
-#endif
-
-#ifndef MICROPY_HW_SPI1_SCK
-#define MICROPY_HW_SPI1_SCK     (10)
-#define MICROPY_HW_SPI1_MOSI    (11)
-#define MICROPY_HW_SPI1_MISO    (8)
-#endif
-
-#define IS_VALID_PERIPH(spi, pin)   ((((pin) & 8) >> 3) == (spi))
-#define IS_VALID_SCK(spi, pin)      (((pin) & 3) == 2 && IS_VALID_PERIPH(spi, pin))
-#define IS_VALID_MOSI(spi, pin)     (((pin) & 3) == 3 && IS_VALID_PERIPH(spi, pin))
-#define IS_VALID_MISO(spi, pin)     (((pin) & 3) == 0 && IS_VALID_PERIPH(spi, pin))
-
-typedef struct _machine_spi_obj_t {
-    mp_obj_base_t base;
-    spi_inst_t *const spi_inst;
-    uint8_t spi_id;
-    uint8_t polarity;
-    uint8_t phase;
-    uint8_t bits;
-    uint8_t firstbit;
-    uint8_t sck;
-    uint8_t mosi;
-    uint8_t miso;
-    uint32_t baudrate;
-} machine_spi_obj_t;
+#include "machine_spi.h"
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
 
 STATIC machine_spi_obj_t machine_spi_obj[] = {
     {
@@ -208,8 +166,8 @@ STATIC void machine_spi_init(mp_obj_base_t *self_in, size_t n_args, const mp_obj
         spi_set_format(self->spi_inst, self->bits, self->polarity, self->phase, self->firstbit);
     }
 }
-
-STATIC void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest) {
+#if 0
+ void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest) {
     machine_spi_obj_t *self = (machine_spi_obj_t *)self_in;
     // Use DMA for large transfers if channels are available
     const size_t dma_min_size_threshold = 32;
@@ -221,11 +179,16 @@ STATIC void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8
         chan_rx = dma_claim_unused_channel(false);
     }
     bool use_dma = chan_rx >= 0 && chan_tx >= 0;
+	if(use_dma==1)
+		printf("chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
+	else if(chan_rx >=0 || chan_tx >=0)
+		printf("Not DMA : chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
     // note src is guaranteed to be non-NULL
     bool write_only = dest == NULL;
 
     if (use_dma) {
         uint8_t dev_null;
+		printf("Use Dma\r\n");
         dma_channel_config c = dma_channel_get_default_config(chan_tx);
         channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
         channel_config_set_dreq(&c, spi_get_index(self->spi_inst) ? DREQ_SPI1_TX : DREQ_SPI0_TX);
@@ -247,27 +210,121 @@ STATIC void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8
             false);
 
         dma_start_channel_mask((1u << chan_rx) | (1u << chan_tx));
+		printf("1\r\n");
         dma_channel_wait_for_finish_blocking(chan_rx);
+		printf("2\r\n");
         dma_channel_wait_for_finish_blocking(chan_tx);
+		printf("3\r\n");
     }
 
     // If we have claimed only one channel successfully, we should release immediately
     if (chan_rx >= 0) {
+		printf("4\r\n");
         dma_channel_unclaim(chan_rx);
+		printf("5\r\n");
     }
     if (chan_tx >= 0) {
+		printf("6\r\n");
         dma_channel_unclaim(chan_tx);
+		printf("7\r\n");
     }
 
     if (!use_dma) {
+		//printf("Not Use Dma\r\n");
         // Use software for small transfers, or if couldn't claim two DMA channels
         if (write_only) {
+			//printf("4\r\n");
             spi_write_blocking(self->spi_inst, src, len);
+			//printf("5\r\n");
         } else {
+			//printf("6\r\n");
             spi_write_read_blocking(self->spi_inst, src, dest, len);
+			//printf("7\r\n");
         }
     }
 }
+#else
+ void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest) {
+    machine_spi_obj_t *self = (machine_spi_obj_t *)self_in;
+    // Use DMA for large transfers if channels are available
+    const size_t dma_min_size_threshold = 32;
+    int chan_tx = -1;
+    int chan_rx = -1;
+    if (len >= dma_min_size_threshold) {
+        // Use two DMA channels to service the two FIFOs
+        chan_tx = dma_claim_unused_channel(false);
+        chan_rx = dma_claim_unused_channel(false);
+    }
+    bool use_dma = chan_rx >= 0 && chan_tx >= 0;
+	/*if(use_dma==1)
+		printf("chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
+	else if(chan_rx >=0 || chan_tx >=0)
+		printf("Not DMA : chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
+    */
+    // note src is guaranteed to be non-NULL
+    bool write_only = dest == NULL;
+
+    if (use_dma) {
+        uint8_t dev_null;
+        dma_channel_config c = dma_channel_get_default_config(chan_tx);
+        channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
+        channel_config_set_dreq(&c, spi_get_index(self->spi_inst) ? DREQ_SPI1_TX : DREQ_SPI0_TX);
+        dma_channel_configure(chan_tx, &c,
+            &spi_get_hw(self->spi_inst)->dr,
+            write_only ? src : &dev_null,
+            len,
+            false);
+
+        c = dma_channel_get_default_config(chan_rx);
+        channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
+        channel_config_set_dreq(&c, spi_get_index(self->spi_inst) ? DREQ_SPI1_RX : DREQ_SPI0_RX);
+        channel_config_set_read_increment(&c, false);
+        channel_config_set_write_increment(&c, !write_only);
+        dma_channel_configure(chan_rx, &c,
+            write_only ? &dev_null : dest,
+            &spi_get_hw(self->spi_inst)->dr,
+            len,
+            false);
+
+        dma_start_channel_mask((1u << chan_rx) | (1u << chan_tx));
+        dma_channel_wait_for_finish_blocking(chan_rx);
+        //dma_channel_wait_for_finish_blocking(chan_tx);
+    }
+
+    // If we have claimed only one channel successfully, we should release immediately
+    if (chan_rx >= 0) {
+        dma_channel_unclaim(chan_rx);
+    }
+    if (chan_tx >= 0) {
+        dma_channel_unclaim(chan_tx);
+    }
+
+    if (!use_dma) {
+		//printf("Not Use Dma\r\n");
+        // Use software for small transfers, or if couldn't claim two DMA channels
+        if (write_only) {
+			//printf("4\r\n");
+            spi_write_blocking(self->spi_inst, src, len);
+			//printf("5\r\n");
+        } else {
+			//printf("6\r\n");
+            spi_write_read_blocking(self->spi_inst, src, dest, len);
+			//printf("7\r\n");
+        }
+    }
+}
+#endif
+
+machine_spi_obj_t *spi_from_mp_obj(mp_obj_t o) {
+ if (mp_obj_is_type(o, &machine_spi_type)) {
+        machine_spi_obj_t *self = MP_OBJ_TO_PTR(o);
+        //return self->spi_inst;
+        return self;
+    } else {
+        mp_raise_TypeError(MP_ERROR_TEXT("expecting an SPI object"));
+    }
+}
+
 
 STATIC const mp_machine_spi_p_t machine_spi_p = {
     .init = machine_spi_init,
diff --git a/ports/rp2/main.c b/ports/rp2/main.c
index 84f23af23..001a3e9e2 100644
--- a/ports/rp2/main.c
+++ b/ports/rp2/main.c
@@ -50,8 +50,8 @@
 #include "hardware/structs/rosc.h"
 
 extern uint8_t __StackTop, __StackBottom;
-static char gc_heap[192 * 1024];
-
+//static char gc_heap[192 * 1024]; 
+static char gc_heap[50 * 1024]; //irina
 // Embed version info in the binary in machine readable form
 bi_decl(bi_program_version_string(MICROPY_GIT_TAG));
 
@@ -106,7 +106,7 @@ int main(int argc, char **argv) {
         readline_init0();
         machine_pin_init();
         rp2_pio_init();
-        machine_i2s_init0();
+       // machine_i2s_init0();
 
         #if MICROPY_PY_BLUETOOTH
         mp_bluetooth_hci_init();
diff --git a/ports/rp2/modmachine.c b/ports/rp2/modmachine.c
index 9d6178a0f..0cd8dbf1c 100644
--- a/ports/rp2/modmachine.c
+++ b/ports/rp2/modmachine.c
@@ -167,7 +167,7 @@ STATIC const mp_rom_map_elem_t machine_module_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR_ADC),                 MP_ROM_PTR(&machine_adc_type) },
     { MP_ROM_QSTR(MP_QSTR_I2C),                 MP_ROM_PTR(&machine_hw_i2c_type) },
     { MP_ROM_QSTR(MP_QSTR_SoftI2C),             MP_ROM_PTR(&mp_machine_soft_i2c_type) },
-    { MP_ROM_QSTR(MP_QSTR_I2S),                 MP_ROM_PTR(&machine_i2s_type) },
+  //  { MP_ROM_QSTR(MP_QSTR_I2S),                 MP_ROM_PTR(&machine_i2s_type) },
     { MP_ROM_QSTR(MP_QSTR_Pin),                 MP_ROM_PTR(&machine_pin_type) },
     { MP_ROM_QSTR(MP_QSTR_PWM),                 MP_ROM_PTR(&machine_pwm_type) },
     { MP_ROM_QSTR(MP_QSTR_RTC),                 MP_ROM_PTR(&machine_rtc_type) },
diff --git a/ports/rp2/modmachine.h b/ports/rp2/modmachine.h
index af02cd193..49fd67bed 100644
--- a/ports/rp2/modmachine.h
+++ b/ports/rp2/modmachine.h
@@ -5,7 +5,7 @@
 
 extern const mp_obj_type_t machine_adc_type;
 extern const mp_obj_type_t machine_hw_i2c_type;
-extern const mp_obj_type_t machine_i2s_type;
+//extern const mp_obj_type_t machine_i2s_type;
 extern const mp_obj_type_t machine_pin_type;
 extern const mp_obj_type_t machine_rtc_type;
 extern const mp_obj_type_t machine_spi_type;
<<<<<<< HEAD
diff --git a/ports/rp2/modnwwiznet5k.c b/ports/rp2/modnwwiznet5k.c
new file mode 100644
<<<<<<< HEAD
index 000000000..4ca59e838
--- /dev/null
+++ b/ports/rp2/modnwwiznet5k.c
@@ -0,0 +1,621 @@
=======
index 000000000..94714beb3
--- /dev/null
+++ b/ports/rp2/modnwwiznet5k.c
@@ -0,0 +1,627 @@
>>>>>>> dev
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+
+#include <stdint.h>
+#include <string.h>
+
+#include "py/objlist.h"
+#include "py/runtime.h"
+#include "py/stream.h"
+#include "py/mperrno.h"
+#include "py/mphal.h"
+#include "shared/netutils/netutils.h"
+#include "extmod/modnetwork.h"
+#include "machine_spi.h"
+#include "machine_pin.h"
+//#include "pin.h"
+#include "modmachine.h"
+#include "hardware/spi.h"
+
+#if MICROPY_PY_WIZNET5K && !MICROPY_PY_LWIP
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
+#include "ethernet/wizchip_conf.h"
+#include "ethernet/socket.h"
+#include "internet/dns/dns.h"
+#include "internet/dhcp/dhcp.h"
+
+typedef struct _wiznet5k_obj_t {
+    mp_obj_base_t base;
+    mp_uint_t cris_state;
+    machine_spi_obj_t *spi;
+    machine_pin_obj_t cs;
+    machine_pin_obj_t rst;
+    wiz_NetInfo netinfo;
+    uint8_t socket_used;
+} wiznet5k_obj_t;
+
+wiznet5k_obj_t wiznet5k_obj;
+STATIC mp_obj_t wiznet5k_init(wiznet5k_obj_t *self);
+STATIC void wiz_dhcp_assign(void);
+STATIC void wiz_dhcp_update(void);
+STATIC void wiz_dhcp_conflict(void);
+
+STATIC void wiz_cris_enter(void) {
+    wiznet5k_obj.cris_state = MICROPY_BEGIN_ATOMIC_SECTION();
+}
+
+STATIC void wiz_cris_exit(void) {
+    MICROPY_END_ATOMIC_SECTION(wiznet5k_obj.cris_state);
+}
+
+STATIC void wiz_cs_select(void) {
+
+	mp_hal_pin_write(wiznet5k_obj.cs.id,0);
+}
+
+STATIC void wiz_cs_deselect(void) {
+
+   mp_hal_pin_write(wiznet5k_obj.cs.id,1);
+
+}
+
+
+STATIC void wiz_spi_read(uint8_t *buf, uint32_t len) {
+    //uint8_t tx_buf[100]; 
+    uint8_t tx_buf[2048];
+    machine_spi_transfer((mp_obj_base_t*)wiznet5k_obj.spi ,len, tx_buf ,buf);
+
+}
+
+STATIC void wiz_spi_write(const uint8_t *buf, uint32_t len) {
+    machine_spi_transfer((mp_obj_base_t *)wiznet5k_obj.spi ,len,buf,NULL);
+}
+
+STATIC void wiz_dhcp_assign(void)
+{ 
+    getIPfromDHCP(wiznet5k_obj.netinfo.ip);
+    getGWfromDHCP(wiznet5k_obj.netinfo.gw);
+    getSNfromDHCP(wiznet5k_obj.netinfo.sn);
+    getDNSfromDHCP(wiznet5k_obj.netinfo.dns);
+    ctlnetwork(CN_SET_NETINFO, (void *)&wiznet5k_obj.netinfo);
+}
+
+
+STATIC void wiz_dhcp_update(void)
+{
+    ;
+}
+
+
+STATIC void wiz_dhcp_conflict(void)
+{
+    ;
+}
+
+
+STATIC int wiznet5k_gethostbyname(mp_obj_t nic, const char *name, mp_uint_t len, uint8_t *out_ip) {
+    uint8_t dns_ip[MOD_NETWORK_IPADDR_BUF_SIZE] = {8, 8, 8, 8};
+  
+
+    //uint8_t dns_ip[MOD_NETWORK_IPADDR_BUF_SIZE] = {wiznet5k_obj.netinfo.dns[0],wiznet5k_obj.netinfo.dns[1],wiznet5k_obj.netinfo.dns[2],wiznet5k_obj.netinfo.dns[3]} ;
+    uint8_t *buf = m_new(uint8_t, MAX_DNS_BUF_SIZE);
+
+
+       
+    DNS_init(2, buf);
+    mp_int_t ret = DNS_run(dns_ip, (uint8_t *)name, out_ip);
+    m_del(uint8_t, buf, MAX_DNS_BUF_SIZE);
+    if (ret == 1) {
+        // success
+        return 0;
+    } else {
+        // failure
+        return -2;
+    }
+}
+
+STATIC int wiznet5k_socket_socket(mod_network_socket_obj_t *socket, int *_errno) {
+    if (socket->domain != MOD_NETWORK_AF_INET) {
+        *_errno = MP_EAFNOSUPPORT;
+        return -1;
+    }
+
+    switch (socket->type) {
+        case MOD_NETWORK_SOCK_STREAM:
+            socket->type = Sn_MR_TCP;
+            break;
+        case MOD_NETWORK_SOCK_DGRAM:
+            socket->type = Sn_MR_UDP;
+            break;
+        default:
+            *_errno = MP_EINVAL;
+            return -1;
+    }
+
+    if (socket->fileno == -1) {
+        // get first unused socket number
+        for (mp_uint_t sn = 0; sn < _WIZCHIP_SOCK_NUM_; sn++) {
+            if ((wiznet5k_obj.socket_used & (1 << sn)) == 0) {
+                wiznet5k_obj.socket_used |= (1 << sn);
+                socket->fileno = sn;
+                break;
+            }
+        }
+        if (socket->fileno == -1) {
+            // too many open sockets
+            *_errno = MP_EMFILE;
+            return -1;
+        }
+    }
+
+    // WIZNET does not have a concept of pure "open socket".  You need to know
+    // if it's a server or client at the time of creation of the socket.
+    // So, we defer the open until we know what kind of socket we want.
+
+    // use "domain" to indicate that this socket has not yet been opened
+    socket->domain = 0;
+
+    return 0;
+}
+
+STATIC void wiznet5k_socket_close(mod_network_socket_obj_t *socket) {
+    uint8_t sn = (uint8_t)socket->fileno;
+    if (sn < _WIZCHIP_SOCK_NUM_) {
+        wiznet5k_obj.socket_used &= ~(1 << sn);
+        WIZCHIP_EXPORT(close)(sn);
+    }
+}
+
+STATIC int wiznet5k_socket_bind(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {
+    // open the socket in server mode (if port != 0)
+    mp_int_t ret = WIZCHIP_EXPORT(socket)(socket->fileno, socket->type, port, 0);
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+
+    // indicate that this socket has been opened
+    socket->domain = 1;
+
+    // success
+    return 0;
+}
+
+STATIC int wiznet5k_socket_listen(mod_network_socket_obj_t *socket, mp_int_t backlog, int *_errno) {
+    mp_int_t ret = WIZCHIP_EXPORT(listen)(socket->fileno);
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return 0;
+}
+
+STATIC int wiznet5k_socket_accept(mod_network_socket_obj_t *socket, mod_network_socket_obj_t *socket2, byte *ip, mp_uint_t *port, int *_errno) {
+    for (;;) {
+        int sr = getSn_SR((uint8_t)socket->fileno);
+        if (sr == SOCK_ESTABLISHED) {
+            socket2->domain = socket->domain;
+            socket2->type = socket->type;
+            socket2->fileno = socket->fileno;
+            getSn_DIPR((uint8_t)socket2->fileno, ip);
+            *port = getSn_PORT(socket2->fileno);
+
+            // WIZnet turns the listening socket into the client socket, so we
+            // need to re-bind and re-listen on another socket for the server.
+            // TODO handle errors, especially no-more-sockets error
+            socket->domain = MOD_NETWORK_AF_INET;
+            socket->fileno = -1;
+            int _errno2;
+            if (wiznet5k_socket_socket(socket, &_errno2) != 0) {
+                // printf("(bad resocket %d)\n", _errno2);
+            } else if (wiznet5k_socket_bind(socket, NULL, *port, &_errno2) != 0) {
+                // printf("(bad rebind %d)\n", _errno2);
+            } else if (wiznet5k_socket_listen(socket, 0, &_errno2) != 0) {
+                // printf("(bad relisten %d)\n", _errno2);
+            }
+
+            return 0;
+        }
+        if (sr == SOCK_CLOSED || sr == SOCK_CLOSE_WAIT) {
+            wiznet5k_socket_close(socket);
+            *_errno = MP_ENOTCONN; // ??
+            return -1;
+        }
+        mp_hal_delay_ms(1);
+    }
+}
+
+STATIC int wiznet5k_socket_connect(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {
+    // use "bind" function to open the socket in client mode
+    if (wiznet5k_socket_bind(socket, ip, 0, _errno) != 0) {
+        return -1;
+    }
+
+    // now connect
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(connect)(socket->fileno, ip, port);
+    MP_THREAD_GIL_ENTER();
+
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+
+    // success
+    return 0;
+}
+
+STATIC mp_uint_t wiznet5k_socket_send(mod_network_socket_obj_t *socket, const byte *buf, mp_uint_t len, int *_errno) {
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(send)(socket->fileno, (byte *)buf, len);
+    MP_THREAD_GIL_ENTER();
+
+    // TODO convert Wiz errno's to POSIX ones
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC mp_uint_t wiznet5k_socket_recv(mod_network_socket_obj_t *socket, byte *buf, mp_uint_t len, int *_errno) {
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(recv)(socket->fileno, buf, len);
+    MP_THREAD_GIL_ENTER();
+
+    // TODO convert Wiz errno's to POSIX ones
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC mp_uint_t wiznet5k_socket_sendto(mod_network_socket_obj_t *socket, const byte *buf, mp_uint_t len, byte *ip, mp_uint_t port, int *_errno) {
+    if (socket->domain == 0) {
+        // socket not opened; use "bind" function to open the socket in client mode
+        if (wiznet5k_socket_bind(socket, ip, 0, _errno) != 0) {
+            return -1;
+        }
+    }
+
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(sendto)(socket->fileno, (byte *)buf, len, ip, port);
+    MP_THREAD_GIL_ENTER();
+
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC mp_uint_t wiznet5k_socket_recvfrom(mod_network_socket_obj_t *socket, byte *buf, mp_uint_t len, byte *ip, mp_uint_t *port, int *_errno) {
+    uint16_t port2;
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(recvfrom)(socket->fileno, buf, len, ip, &port2);
+    MP_THREAD_GIL_ENTER();
+    *port = port2;
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC int wiznet5k_socket_setsockopt(mod_network_socket_obj_t *socket, mp_uint_t level, mp_uint_t opt, const void *optval, mp_uint_t optlen, int *_errno) {
+    // TODO
+    *_errno = MP_EINVAL;
+    return -1;
+}
+
+STATIC int wiznet5k_socket_settimeout(mod_network_socket_obj_t *socket, mp_uint_t timeout_ms, int *_errno) {
+    // TODO
+    *_errno = MP_EINVAL;
+    return -1;
+
+    /*
+    if (timeout_ms == 0) {
+        // set non-blocking mode
+        uint8_t arg = SOCK_IO_NONBLOCK;
+        WIZCHIP_EXPORT(ctlsocket)(socket->fileno, CS_SET_IOMODE, &arg);
+    }
+    */
+}
+
+STATIC int wiznet5k_socket_ioctl(mod_network_socket_obj_t *socket, mp_uint_t request, mp_uint_t arg, int *_errno) {
+    if (request == MP_STREAM_POLL) {
+        int ret = 0;
+        if (arg & MP_STREAM_POLL_RD && getSn_RX_RSR(socket->fileno) != 0) {
+            ret |= MP_STREAM_POLL_RD;
+        }
+        if (arg & MP_STREAM_POLL_WR && getSn_TX_FSR(socket->fileno) != 0) {
+            ret |= MP_STREAM_POLL_WR;
+        }
+        return ret;
+    } else {
+        *_errno = MP_EINVAL;
+        return MP_STREAM_ERROR;
+    }
+}
+
+#if 0
+STATIC void wiznet5k_socket_print(void (*print)(void *env, const char *fmt, ...), void *env, mp_obj_t self_in, mp_print_kind_t kind) {
+    wiznet5k_socket_obj_t *self = self_in;
+    print(env, "<WIZNET5K.socket sn=%u MR=0x%02x>", self->sn, getSn_MR(self->sn));
+}
+
+STATIC mp_obj_t wiznet5k_socket_disconnect(mp_obj_t self_in) {
+    mp_int_t ret = WIZCHIP_EXPORT(disconnect)(self->sn);
+    return 0;
+}
+#endif
+
+/******************************************************************************/
+// MicroPython bindings
+
+/// \classmethod \constructor(spi, pin_cs, pin_rst)
+/// Create and return a WIZNET5K object.
+STATIC mp_obj_t wiznet5k_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
+    // check arguments
+    mp_arg_check_num(n_args, n_kw, 3, 3, false);
+	
+    machine_spi_obj_t *spi = spi_from_mp_obj(args[0]);
+    mp_hal_pin_obj_t cs = mp_hal_get_pin_obj(args[1]);
+    mp_hal_pin_obj_t rst = mp_hal_get_pin_obj(args[2]);
+
+    // init the wiznet5k object
+    wiznet5k_obj.base.type = (mp_obj_type_t *)&mod_network_nic_type_wiznet5k;
+    wiznet5k_obj.cris_state = 0;
+    wiznet5k_obj.spi = spi;
+    wiznet5k_obj.cs.id= cs;
+    wiznet5k_obj.rst.id = rst;
+
+    wiznet5k_obj.socket_used = 0;
+
+    spi_init(wiznet5k_obj.spi->spi_inst, 48000);
+	
+    mp_hal_pin_output(wiznet5k_obj.cs.id);
+    mp_hal_pin_output(wiznet5k_obj.rst.id);
+
+    mp_hal_pin_write(wiznet5k_obj.rst.id,0);
+    mp_hal_delay_ms(1); // datasheet says 2us
+    mp_hal_pin_write(wiznet5k_obj.rst.id,1);
+    mp_hal_delay_ms(160); // datasheet says 150ms
+
+    reg_wizchip_cris_cbfunc(wiz_cris_enter, wiz_cris_exit);
+    reg_wizchip_cs_cbfunc(wiz_cs_select, wiz_cs_deselect);
+    reg_wizchip_spi_cbfunc(wiz_spi_read, wiz_spi_write);
+    reg_dhcp_cbfunc(wiz_dhcp_assign, wiz_dhcp_update, wiz_dhcp_conflict);
+    uint8_t sn_size[16] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; // 2k buffer for each socket
+    ctlwizchip(CW_INIT_WIZCHIP, sn_size);
+
+    // set some sensible default values; they are configurable using ifconfig method
+    wiz_NetInfo netinfo = {
+        .mac = {0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef},
+        .ip = {192, 168, 100, 18},
+        .sn = {255, 255, 255, 0},
+        .gw = {192, 168, 100, 1},
+        .dns = {8, 8, 8, 8}, // Google public DNS
+        .dhcp = NETINFO_STATIC,
+    };
+    wiznet5k_obj.netinfo = netinfo;
+    ctlnetwork(CN_SET_NETINFO, (void *)&wiznet5k_obj.netinfo);
+    // seems we need a small delay after init
+    mp_hal_delay_ms(250);
+
+    // register with network module
+    mod_network_register_nic(&wiznet5k_obj);
+
+    // return wiznet5k object
+    return &wiznet5k_obj;
+} 
+STATIC mp_obj_t wiznet5k_active(size_t n_args, const mp_obj_t *args) {
+    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);
<<<<<<< HEAD
+
=======
>>>>>>> dev
+    //wiz_NetInfo netinfo;
+    if (n_args == 1) {
+        return mp_const_none;
+    } else {
+        if (mp_obj_is_true(args[1])) {
+            self->netinfo.dhcp = NETINFO_DHCP;
+            //self->netinfo.mac = netinfo.mac;
+            wiznet5k_init((void *)self);
+
+            mp_obj_t tuple[4] = {
+                netutils_format_ipv4_addr(self->netinfo.ip, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.sn, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.gw, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.dns, NETUTILS_BIG),
+
+            };
+            
+            printf("netif changed  %d.%d.%d.%d\r\n",self->netinfo.ip[0],self->netinfo.ip[1],self->netinfo.ip[2],self->netinfo.ip[3]);
+            
+            return mp_obj_new_tuple(4, tuple); 
+        } else {
+            //self->netinfo = netinfo;
+            self->netinfo.dhcp = NETINFO_STATIC;
+                       
+            ctlnetwork(CN_SET_NETINFO, (void *)&self->netinfo);
+            ctlnetwork(CN_GET_NETINFO, (void *)&self->netinfo);
+        // get
+            mp_obj_t tuple[4] = {
+                netutils_format_ipv4_addr(self->netinfo.ip, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.sn, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.gw, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.dns, NETUTILS_BIG),
+
+            };
+                return mp_obj_new_tuple(4, tuple);
+            
+        }
+        return mp_const_none;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_active_obj, 1, 2, wiznet5k_active);
+
+STATIC mp_obj_t wiznet5k_init(wiznet5k_obj_t *self){
+    uint8_t test_buf[2048];
+    
+    uint8_t ret =0;
+    uint8_t dhcp_retry=0;
+    DHCP_init(1, test_buf);
+    while (1)  {
+        /*if (mp_hal_ticks_ms() - start > 10000) {
+            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT("timeout waiting for DHCP to get IP address"));
+        }*/
+        ret = DHCP_run();
+        if (ret == DHCP_IP_LEASED) {
+            break;
+        }
+            else if (ret == DHCP_FAILED) {
+            dhcp_retry++;
+        }
+
+        if (dhcp_retry > 3) {
+            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT("timeout waiting for DHCP to get IP address"));
+             break;
+        }
+      }
+   
+    if(ret == DHCP_IP_LEASED){
+        ctlnetwork(CN_GET_NETINFO,&self->netinfo);
+        return  mp_const_none;
+    }
+    else {
+        
+        return  mp_const_none;
+    }
+
+}
+/// \method regs()
+/// Dump WIZNET5K registers.
+STATIC mp_obj_t wiznet5k_regs(mp_obj_t self_in) {
+    // wiznet5k_obj_t *self = self_in;
+    printf("Wiz CREG:");
+    for (int i = 0; i < 0x50; ++i) {
+        if (i % 16 == 0) {
+            printf("\n  %04x:", i);
+        }
+        #if MICROPY_PY_WIZNET5K <= 5200 
+        uint32_t reg = i;
+        #else
+        uint32_t reg = _WIZCHIP_IO_BASE_ | i << 8;
+        #endif
+        printf(" %02x", WIZCHIP_READ(reg));
+    }
+    for (int sn = 0; sn < 4; ++sn) {
+        printf("\nWiz SREG[%d]:", sn);
+        for (int i = 0; i < 0x30; ++i) {
+            if (i % 16 == 0) {
+                printf("\n  %04x:", i);
+            }
+            #if MICROPY_PY_WIZNET5K <= 5200
+            uint32_t reg = WIZCHIP_SREG_ADDR(sn, i);
+            #else
+            uint32_t reg = _WIZCHIP_IO_BASE_ | i << 8 | WIZCHIP_SREG_BLOCK(sn) << 3;
+            #endif
+            printf(" %02x", WIZCHIP_READ(reg));
+        }
+    }
+    printf("\n");
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(wiznet5k_regs_obj, wiznet5k_regs);
+
+STATIC mp_obj_t wiznet5k_isconnected(mp_obj_t self_in) {
+    (void)self_in;
+    #if MICROPY_PY_WIZNET5K == 5100
+     return mp_obj_new_bool( PHY_LINK_ON);
+    #else
+     return mp_obj_new_bool(wizphy_getphylink() == PHY_LINK_ON);
+    #endif
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(wiznet5k_isconnected_obj, wiznet5k_isconnected);
+
+/// \method ifconfig([(ip, subnet, gateway, dns)])
+/// Get/set IP address, subnet mask, gateway and DNS.
+STATIC mp_obj_t wiznet5k_ifconfig(size_t n_args, const mp_obj_t *args) {
+    wiz_NetInfo netinfo;
+    ctlnetwork(CN_GET_NETINFO, &netinfo);
+    if (n_args == 1) {
+        // get
+        mp_obj_t tuple[4] = {
+            netutils_format_ipv4_addr(netinfo.ip, NETUTILS_BIG),
+            netutils_format_ipv4_addr(netinfo.sn, NETUTILS_BIG),
+            netutils_format_ipv4_addr(netinfo.gw, NETUTILS_BIG),
+            netutils_format_ipv4_addr(netinfo.dns, NETUTILS_BIG),
+        };
+        return mp_obj_new_tuple(4, tuple);
+    } else {
+        // set
+        mp_obj_t *items;
+        mp_obj_get_array_fixed_n(args[1], 4, &items);
+        netutils_parse_ipv4_addr(items[0], netinfo.ip, NETUTILS_BIG);
+        netutils_parse_ipv4_addr(items[1], netinfo.sn, NETUTILS_BIG);
+        netutils_parse_ipv4_addr(items[2], netinfo.gw, NETUTILS_BIG);
+        netutils_parse_ipv4_addr(items[3], netinfo.dns, NETUTILS_BIG);
+        ctlnetwork(CN_SET_NETINFO, &netinfo);
+        return mp_const_none;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_ifconfig_obj, 1, 2, wiznet5k_ifconfig);
+
+STATIC const mp_rom_map_elem_t wiznet5k_locals_dict_table[] = {
+    { MP_ROM_QSTR(MP_QSTR_regs), MP_ROM_PTR(&wiznet5k_regs_obj) },
+    { MP_ROM_QSTR(MP_QSTR_ifconfig), MP_ROM_PTR(&wiznet5k_ifconfig_obj) },
+    { MP_ROM_QSTR(MP_QSTR_active), MP_ROM_PTR(&wiznet5k_active_obj) },
+    { MP_ROM_QSTR(MP_QSTR_isconnected), MP_ROM_PTR(&wiznet5k_isconnected_obj) },
+};
+
+STATIC MP_DEFINE_CONST_DICT(wiznet5k_locals_dict, wiznet5k_locals_dict_table);
+
+const mod_network_nic_type_t mod_network_nic_type_wiznet5k = {
+    .base = {
+        { &mp_type_type },
+        .name = MP_QSTR_WIZNET5K,
+        .make_new = wiznet5k_make_new,
+        .locals_dict = (mp_obj_dict_t *)&wiznet5k_locals_dict,
+    },
+    .gethostbyname = wiznet5k_gethostbyname,
+    .socket = wiznet5k_socket_socket,
+    .close = wiznet5k_socket_close,
+    .bind = wiznet5k_socket_bind,
+    .listen = wiznet5k_socket_listen,
+    .accept = wiznet5k_socket_accept,
+    .connect = wiznet5k_socket_connect,
+    .send = wiznet5k_socket_send,
+    .recv = wiznet5k_socket_recv,
+    .sendto = wiznet5k_socket_sendto,
+    .recvfrom = wiznet5k_socket_recvfrom,
+    .setsockopt = wiznet5k_socket_setsockopt,
+    .settimeout = wiznet5k_socket_settimeout,
+    .ioctl = wiznet5k_socket_ioctl,
+};
+
+#endif // MICROPY_PY_WIZNET5K && !MICROPY_PY_LWIP
\ No newline at end of file
=======
>>>>>>> dev
diff --git a/ports/rp2/modrp2.c b/ports/rp2/modrp2.c
index 15c61911d..f16d6bc6c 100644
--- a/ports/rp2/modrp2.c
+++ b/ports/rp2/modrp2.c
@@ -25,7 +25,7 @@
  */
 
 #include "py/runtime.h"
-#include "drivers/dht/dht.h"
+//#include "drivers/dht/dht.h"
 #include "modrp2.h"
 
 STATIC const mp_rom_map_elem_t rp2_module_globals_table[] = {
@@ -33,8 +33,8 @@ STATIC const mp_rom_map_elem_t rp2_module_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR_Flash),               MP_ROM_PTR(&rp2_flash_type) },
     { MP_ROM_QSTR(MP_QSTR_PIO),                 MP_ROM_PTR(&rp2_pio_type) },
     { MP_ROM_QSTR(MP_QSTR_StateMachine),        MP_ROM_PTR(&rp2_state_machine_type) },
-
-    { MP_ROM_QSTR(MP_QSTR_dht_readinto),        MP_ROM_PTR(&dht_readinto_obj) },
+//    { MP_ROM_QSTR(MP_QSTR_dht_readinto),        MP_ROM_PTR(&dht_readinto_obj) },
+    { MP_ROM_QSTR(MP_QSTR_SPI),					MP_ROM_PTR(&machine_spi_type)},
 };
 STATIC MP_DEFINE_CONST_DICT(rp2_module_globals, rp2_module_globals_table);
 
diff --git a/ports/rp2/modrp2.h b/ports/rp2/modrp2.h
index 805c785f2..db19b485d 100644
--- a/ports/rp2/modrp2.h
+++ b/ports/rp2/modrp2.h
@@ -27,11 +27,12 @@
 #define MICROPY_INCLUDED_RP2_MODRP2_H
 
 #include "py/obj.h"
+#include "machine_spi.h"
 
 extern const mp_obj_type_t rp2_flash_type;
 extern const mp_obj_type_t rp2_pio_type;
 extern const mp_obj_type_t rp2_state_machine_type;
-
+extern const mp_obj_fun_builtin_fixed_t dht_readinto_obj;
 void rp2_pio_init(void);
 void rp2_pio_deinit(void);
 
diff --git a/ports/rp2/mpconfigport.h b/ports/rp2/mpconfigport.h
index 63d9818e3..296b9009e 100644
--- a/ports/rp2/mpconfigport.h
+++ b/ports/rp2/mpconfigport.h
@@ -27,6 +27,7 @@
 // Options controlling how MicroPython is built, overriding defaults in py/mpconfig.h
 
 #include <stdint.h>
+
 #include "hardware/spi.h"
 #include "hardware/sync.h"
 #include "pico/binary_info.h"
@@ -72,22 +73,32 @@
 #define MICROPY_FLOAT_IMPL                      (MICROPY_FLOAT_IMPL_FLOAT)
 #define MICROPY_USE_INTERNAL_ERRNO              (1)
 #define MICROPY_SCHEDULER_DEPTH                 (8)
+#define MICROPY_STREAMS_POSIX_API               (1)
 
 // Fine control over Python builtins, classes, modules, etc
 #define MICROPY_PY_BUILTINS_HELP_TEXT           rp2_help_text
 #define MICROPY_PY_SYS_PLATFORM                 "rp2"
+#define MICROPY_PY_UERRNO                       (1)
 #define MICROPY_PY_THREAD                       (1)
-#define MICROPY_PY_THREAD_GIL                   (0)
+#define MICROPY_PY_THREAD_GIL                   (1)
+//#define MICROPY_PY_THREAD_GIL                   (0)
 
+#define MICROPY_PY_NETWORK                      (1)
+#define MICROPY_PY_USOCKET                      (1)
+#define MICROPY_PY_USSL                         (1)
+#define MICROPY_SSL_AXTLS                       (1)
 // Extended modules
 #define MICROPY_EPOCH_IS_1970                   (1)
 #define MICROPY_PY_URE_MATCH_GROUPS             (1)
 #define MICROPY_PY_URE_MATCH_SPAN_START_END     (1)
 #define MICROPY_PY_UTIME_MP_HAL                 (1)
+#define MICROPY_PY_URANDOM                      (1)
+#define MICROPY_PY_URANDOM_EXTRA_FUNCS          (1)
 #define MICROPY_PY_URANDOM_SEED_INIT_FUNC       (rosc_random_u32())
+#define MICROPY_PY_USELECT                      (1)
 #define MICROPY_PY_MACHINE                      (1)
 #define MICROPY_PY_MACHINE_PIN_MAKE_NEW         mp_pin_make_new
-#define MICROPY_PY_MACHINE_BITSTREAM            (1)
+//#define MICROPY_PY_MACHINE_BITSTREAM            (1)
 #define MICROPY_PY_MACHINE_PULSE                (1)
 #define MICROPY_PY_MACHINE_PWM                  (1)
 #define MICROPY_PY_MACHINE_PWM_DUTY_U16_NS      (1)
@@ -128,6 +139,7 @@ extern const struct _mp_obj_module_t mp_module_rp2;
 extern const struct _mp_obj_module_t mp_module_uos;
 extern const struct _mp_obj_module_t mp_module_usocket;
 extern const struct _mp_obj_module_t mp_module_utime;
+extern const struct _mp_obj_module_t mp_module_ussl;
 
 #if MICROPY_PY_USOCKET
 #define SOCKET_BUILTIN_MODULE               { MP_ROM_QSTR(MP_QSTR_usocket), MP_ROM_PTR(&mp_module_usocket) },
@@ -142,6 +154,14 @@ extern const struct _mp_obj_module_t mp_module_utime;
 #define NETWORK_ROOT_POINTERS
 #endif
 
+#if MICROPY_PY_WIZNET5K
+extern const struct _mod_network_nic_type_t mod_network_nic_type_wiznet5k;
+#define MICROPY_HW_NIC_WIZNET5K             { MP_ROM_QSTR(MP_QSTR_WIZNET5K), MP_ROM_PTR(&mod_network_nic_type_wiznet5k) },
+#else
+#define MICROPY_HW_NIC_WIZNET5K
+#endif
+
+
 #if MICROPY_PY_BLUETOOTH
 #define MICROPY_PORT_ROOT_POINTER_BLUETOOTH struct _machine_uart_obj_t *mp_bthci_uart;
 #else
@@ -179,8 +199,15 @@ extern const struct _mod_network_nic_type_t mod_network_nic_type_nina;
     SOCKET_BUILTIN_MODULE \
     NETWORK_BUILTIN_MODULE \
 
-#define MICROPY_PORT_NETWORK_INTERFACES \
-    MICROPY_HW_NIC_NINAW10  \
+#if defined(MICROPY_PY_NETWORK_NINAW10)
+    #define MICROPY_PORT_NETWORK_INTERFACES \
+        MICROPY_HW_NIC_NINAW10  
+#elif defined(MICROPY_PY_WIZNET5K)
+    #define MICROPY_PORT_NETWORK_INTERFACES \
+        MICROPY_HW_NIC_WIZNET5K 
+#else
+    #define MICROPY_PORT_NETWORK_INTERFACES
+#endif
 
 #ifndef MICROPY_BOARD_ROOT_POINTERS
 #define MICROPY_BOARD_ROOT_POINTERS
@@ -230,6 +257,7 @@ extern const struct _mod_network_nic_type_t mod_network_nic_type_nina;
         MICROPY_HW_USBDEV_TASK_HOOK \
     } while (0);
 
+#define MICROPY_THREAD_YIELD() // mp_handle_pending(true);
 #define MICROPY_MAKE_POINTER_CALLABLE(p) ((void *)((mp_uint_t)(p) | 1))
 
 #define MP_SSIZE_MAX (0x7fffffff)
diff --git a/tools/upip.py b/tools/upip.py
index 9fb872642..34d23d2a8 100644
--- a/tools/upip.py
+++ b/tools/upip.py
@@ -16,7 +16,8 @@ import upip_utarfile as tarfile
 gc.collect()
 
 
-debug = False
+#debug = False
+debug = True
 index_urls = ["https://micropython.org/pi", "https://pypi.org/pypi"]
 install_path = None
 cleanup_files = []
@@ -112,6 +113,7 @@ def expandhome(s):
     if "~/" in s:
         h = os.getenv("HOME")
         s = s.replace("~/", h + "/")
+        print("path ",s)
     return s
 
 
@@ -134,25 +136,29 @@ def url_open(url):
             host, port = host.split(":")
             port = int(port)
         ai = usocket.getaddrinfo(host, port, 0, usocket.SOCK_STREAM)
+        print("Address infos:", ai)
+        #ai = usocket.getaddrinfo(host, port)
     except OSError as e:
         fatal("Unable to resolve %s (no Internet?)" % host, e)
-    # print("Address infos:", ai)
     ai = ai[0]
 
     s = usocket.socket(ai[0], ai[1], ai[2])
     try:
-        # print("Connect address:", addr)
-        s.connect(ai[-1])
-
+        #print("Connect address:", addr)
+        #print("Connect address:", ai[4])
+        s.connect(ai[4])
         if proto == "https:":
             s = ussl.wrap_socket(s, server_hostname=host)
             if warn_ussl:
                 print("Warning: %s SSL certificate is not validated" % host)
                 warn_ussl = False
-
+            ##211209 upip modification
+            print("HTTPS TLS established : %s " % host) 
         # MicroPython rawsocket module supports file interface directly
         s.write("GET /%s HTTP/1.0\r\nHost: %s:%s\r\n\r\n" % (urlpath, host, port))
         l = s.readline()
+        ##211209 upip modification
+        print("   " + l.decode(), end='')
         protover, status, msg = l.split(None, 2)
         if status != b"200":
             if status == b"404" or status == b"301":
@@ -192,13 +198,14 @@ def fatal(msg, exc=None):
 
 
 def install_pkg(pkg_spec, install_path):
-    package = pkg_spec.split("==")
-    data = get_pkg_metadata(package[0])
-
-    if len(package) == 1:
-        latest_ver = data["info"]["version"]
-    else:
-        latest_ver = package[1]
+   # package = pkg_spec.split("==")
+    #data = get_pkg_metadata(package[0])
+    data = get_pkg_metadata(pkg_spec)
+    
+    #if len(package) == 1:
+    latest_ver = data["info"]["version"]
+    #else:
+    #    latest_ver = package[1]
     packages = data["releases"][latest_ver]
     del data
     gc.collect()
@@ -262,8 +269,9 @@ def get_install_path():
     if install_path is None:
         # sys.path[0] is current module's path
         install_path = sys.path[1]
-        if install_path == ".frozen":
-            install_path = sys.path[2]
+        install_path = "lib"
+        #if install_path == ".frozen":
+        #    install_path = sys.path[2]
     install_path = expandhome(install_path)
     return install_path
 
@@ -353,4 +361,5 @@ def main():
 
 
 if __name__ == "__main__":
-    main()
+    #main()
+    install("ureqeust")
