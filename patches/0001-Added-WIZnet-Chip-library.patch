diff --git a/drivers/wiznet5k/ethernet/socket.c b/drivers/wiznet5k/ethernet/socket.c
<<<<<<< HEAD
index 3ffda3a72..777fe1df5 100644
=======
index 3ffda3a72..43ac18292 100644
>>>>>>> dev
--- a/drivers/wiznet5k/ethernet/socket.c
+++ b/drivers/wiznet5k/ethernet/socket.c
@@ -53,20 +53,32 @@
 #include <string.h>
 
 #include "py/mpthread.h"
+#include "py/stream.h"
+#include "py/runtime.h"
 #include "socket.h"
 
-#define SOCK_ANY_PORT_NUM  0xC000;
+#include "py/mphal.h"
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
+//M20150401 : Typing Error
+//#define SOCK_ANY_PORT_NUM  0xC000;
+#define SOCK_ANY_PORT_NUM  0xC000
 
 static uint16_t sock_any_port = SOCK_ANY_PORT_NUM;
 static uint16_t sock_io_mode = 0;
 static uint16_t sock_is_sending = 0;
 static uint16_t sock_remained_size[_WIZCHIP_SOCK_NUM_] = {0,0,};
-static uint8_t  sock_pack_info[_WIZCHIP_SOCK_NUM_] = {0,};
+//static uint8_t  sock_pack_info[_WIZCHIP_SOCK_NUM_] = {0,};
+uint8_t  sock_pack_info[_WIZCHIP_SOCK_NUM_] = {0,};
 
 #if _WIZCHIP_ == 5200
    static uint16_t sock_next_rd[_WIZCHIP_SOCK_NUM_] ={0,};
 #endif
 
+//A20150601 : For integrating with W5300
+#if _WIZCHIP_ == 5300
+   uint8_t sock_remained_byte[_WIZCHIP_SOCK_NUM_] = {0,}; // set by wiz_recv_data()
+#endif
+
 #define CHECK_SOCKNUM()   \
    do{                    \
       if(sn > _WIZCHIP_SOCK_NUM_) return SOCKERR_SOCKNUM;   \
@@ -107,6 +119,17 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
 	switch(protocol)
 	{
       case Sn_MR_TCP :
+         {
+            //M20150601 : Fixed the warning - taddr will never be NULL
+		    /*
+            uint8_t taddr[4];
+            getSIPR(taddr);
+            */
+            uint32_t taddr;
+            getSIPR((uint8_t*)&taddr);
+            if(taddr == 0) return SOCKERR_SOCKINIT;
+	    break;
+         }
       case Sn_MR_UDP :
       case Sn_MR_MACRAW :
          break;
@@ -118,7 +141,9 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
       default :
          return SOCKERR_SOCKMODE;
 	}
-	if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
+	//M20150601 : For SF_TCP_ALIGN & W5300
+	//if((flag & 0x06) != 0) return SOCKERR_SOCKFLAG;
+	if((flag & 0x04) != 0) return SOCKERR_SOCKFLAG;
 #if _WIZCHIP_ == 5200
    if(flag & 0x10) return SOCKERR_SOCKFLAG;
 #endif
@@ -128,7 +153,12 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
    	switch(protocol)
    	{
    	   case Sn_MR_TCP:
-   	      if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
+   		  //M20150601 :  For SF_TCP_ALIGN & W5300
+          #if _WIZCHIP_ == 5300
+   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK|SF_TCP_ALIGN))==0) return SOCKERR_SOCKFLAG;
+          #else
+   		     if((flag & (SF_TCP_NODELAY|SF_IO_NONBLOCK))==0) return SOCKERR_SOCKFLAG;
+          #endif
    	      break;
    	   case Sn_MR_UDP:
    	      if(flag & SF_IGMP_VER2)
@@ -147,7 +177,12 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
    	}
    }
 	WIZCHIP_EXPORT(close)(sn);
-	setSn_MR(sn, (protocol | (flag & 0xF0)));
+	//M20150601
+	#if _WIZCHIP_ == 5300
+	   setSn_MR(sn, ((uint16_t)(protocol | (flag & 0xF0))) | (((uint16_t)(flag & 0x02)) << 7) );
+    #else
+	   setSn_MR(sn, (protocol | (flag & 0xF0)));
+    #endif
 	if(!port)
 	{
 	   port = sock_any_port++;
@@ -156,10 +191,14 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
    setSn_PORT(sn,port);	
    setSn_CR(sn,Sn_CR_OPEN);
    while(getSn_CR(sn));
+   //A20150401 : For release the previous sock_io_mode
+   sock_io_mode &= ~(1 <<sn);
    sock_io_mode |= ((flag & SF_IO_NONBLOCK) << sn);
    sock_is_sending &= ~(1<<sn);
    sock_remained_size[sn] = 0;
-   sock_pack_info[sn] = 0;
+   //M20150601 : repalce 0 with PACK_COMPLETED
+   //sock_pack_info[sn] = 0;
+   sock_pack_info[sn] = PACK_COMPLETED;
    while(getSn_SR(sn) == SOCK_CLOSED);
    return (int8_t)sn;
 }	   
@@ -167,12 +206,39 @@ int8_t WIZCHIP_EXPORT(socket)(uint8_t sn, uint8_t protocol, uint16_t port, uint8
 int8_t WIZCHIP_EXPORT(close)(uint8_t sn)
 {
 	CHECK_SOCKNUM();
-	
+//A20160426 : Applied the erratum 1 of W5300
+#if   (_WIZCHIP_ == 5300) 
+   //M20160503 : Wrong socket parameter. s -> sn 
+   //if( ((getSn_MR(s)& 0x0F) == Sn_MR_TCP) && (getSn_TX_FSR(s) != getSn_TxMAX(s)) ) 
+   if( ((getSn_MR(sn)& 0x0F) == Sn_MR_TCP) && (getSn_TX_FSR(sn) != getSn_TxMAX(sn)) ) 
+   { 
+      uint8_t destip[4] = {0, 0, 0, 1};
+      // TODO
+      // You can wait for completing to sending data;
+      // wait about 1 second;
+      // if you have completed to send data, skip the code of erratum 1
+      // ex> wait_1s();
+      //     if (getSn_TX_FSR(s) == getSn_TxMAX(s)) continue;
+      // 
+      //M20160503 : The socket() of close() calls close() itself again. It occures a infinite loop - close()->socket()->close()->socket()-> ~
+      //socket(s,Sn_MR_UDP,0x3000,0);
+      //sendto(s,destip,1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0.1).
+      setSn_MR(sn,Sn_MR_UDP);
+      setSn_PORTR(sn, 0x3000);
+      setSn_CR(sn,Sn_CR_OPEN);
+      while(getSn_CR(sn) != 0);
+      while(getSn_SR(sn) != SOCK_UDP);
+      sendto(sn,destip,1,destip,0x3000); // send the dummy data to an unknown destination(0.0.0.1).
+   };   
+#endif 
 	setSn_CR(sn,Sn_CR_CLOSE);
    /* wait to process the command... */
 	while( getSn_CR(sn) );
 	/* clear all interrupt of the socket. */
 	setSn_IR(sn, 0xFF);
+	//A20150401 : Release the sock_io_mode of socket n.
+	sock_io_mode &= ~(1<<sn);
+	//
 	sock_is_sending &= ~(1<<sn);
 	sock_remained_size[sn] = 0;
 	sock_pack_info[sn] = 0;
@@ -189,12 +255,9 @@ int8_t WIZCHIP_EXPORT(listen)(uint8_t sn)
 	while(getSn_CR(sn));
    while(getSn_SR(sn) != SOCK_LISTEN)
    {
-      if(getSn_CR(sn) == SOCK_CLOSED)
-      {
-         WIZCHIP_EXPORT(close)(sn);
+       	WIZCHIP_EXPORT(close)(sn);
          return SOCKERR_SOCKCLOSED;
       }
-   }
    return SOCK_OK;
 }
 
@@ -286,12 +349,14 @@ int32_t WIZCHIP_EXPORT(send)(uint8_t sn, uint8_t * buf, uint16_t len)
       if(tmp & Sn_IR_SENDOK)
       {
          setSn_IR(sn, Sn_IR_SENDOK);
-         #if _WZICHIP_ == 5200
+         //M20150401 : Typing Error
+         //#if _WZICHIP_ == 5200
+         #if _WIZCHIP_ == 5200
             if(getSn_TX_RD(sn) != sock_next_rd[sn])
             {
                setSn_CR(sn,Sn_CR_SEND);
                while(getSn_CR(sn));
-               return SOCKERR_BUSY;
+               return SOCK_BUSY;
             }
          #endif
          sock_is_sending &= ~(1<<sn);         
@@ -326,7 +391,9 @@ int32_t WIZCHIP_EXPORT(send)(uint8_t sn, uint8_t * buf, uint16_t len)
    /* wait to process the command... */
    while(getSn_CR(sn));
    sock_is_sending |= (1 << sn);
-   return len;
+   //M20150409 : Explicit Type Casting
+   //return len;
+   return (int32_t)len;
 }
 
 
@@ -334,12 +401,26 @@ int32_t WIZCHIP_EXPORT(recv)(uint8_t sn, uint8_t * buf, uint16_t len)
 {
    uint8_t  tmp = 0;
    uint16_t recvsize = 0;
+//A20150601 : For integarating with W5300
+#if   _WIZCHIP_ == 5300
+   uint8_t head[2];
+   uint16_t mr;
+#endif
+//
    CHECK_SOCKNUM();
    CHECK_SOCKMODE(Sn_MR_TCP);
    CHECK_SOCKDATA();
    
    recvsize = getSn_RxMAX(sn);
    if(recvsize < len) len = recvsize;
+      
+//A20150601 : For Integrating with W5300
+#if _WIZCHIP_ == 5300
+   //sock_pack_info[sn] = PACK_COMPLETED;    // for clear      
+   if(sock_remained_size[sn] == 0)
+   {
+#endif
+//
    while(1)
    {
       recvsize = getSn_RX_RSR(sn);
@@ -357,8 +438,8 @@ int32_t WIZCHIP_EXPORT(recv)(uint8_t sn, uint8_t * buf, uint16_t len)
                //  formed an orderly shutdown, recv() shall return 0".
                // TODO this return value clashes with SOCK_BUSY in non-blocking mode.
                WIZCHIP_EXPORT(close)(sn);
-               return 0;
-            }
+                  return SOCKERR_SOCKSTATUS;
+               }
          }
          else
          {
@@ -370,17 +451,62 @@ int32_t WIZCHIP_EXPORT(recv)(uint8_t sn, uint8_t * buf, uint16_t len)
       if(recvsize != 0) break;
       MICROPY_THREAD_YIELD();
    };
-   if(recvsize < len) len = recvsize;
+//A20150601 : For integrating with W5300
+#if _WIZCHIP_ == 5300
+   if((sock_remained_size[sn] == 0) || (getSn_MR(sn) & Sn_MR_ALIGN))
+   {
+      mr = getMR();
+      if((getSn_MR(sn) & Sn_MR_ALIGN)==0)
+      {
+         wiz_recv_data(sn,head,2);
+         if(mr & MR_FS)
+            recvsize = (((uint16_t)head[1]) << 8) | ((uint16_t)head[0]);
+         else
+            recvsize = (((uint16_t)head[0]) << 8) | ((uint16_t)head[1]);
+         sock_pack_info[sn] = PACK_FIRST;
+      }
+      sock_remained_size[sn] = recvsize;
+   }
+   if(len > sock_remained_size[sn]) len = sock_remained_size[sn];
+   recvsize = len;   
+   if(sock_pack_info[sn] & PACK_FIFOBYTE)
+   {
+      *buf = sock_remained_byte[sn];
+      buf++;
+      sock_pack_info[sn] &= ~(PACK_FIFOBYTE);
+      recvsize -= 1;
+      sock_remained_size[sn] -= 1;
+   }
+   if(recvsize != 0)
+   {
+      wiz_recv_data(sn, buf, recvsize);
+      setSn_CR(sn,Sn_CR_RECV);
+      while(getSn_CR(sn));
+   }
+   sock_remained_size[sn] -= recvsize;
+   if(sock_remained_size[sn] != 0)
+   {
+      sock_pack_info[sn] |= PACK_REMAINED;
+      if(recvsize & 0x1) sock_pack_info[sn] |= PACK_FIFOBYTE;
+   }
+   else sock_pack_info[sn] = PACK_COMPLETED;
+   if(getSn_MR(sn) & Sn_MR_ALIGN) sock_remained_size[sn] = 0;
+   //len = recvsize;
+#else   
+   if(recvsize < len) len = recvsize;   
    wiz_recv_data(sn, buf, len);
    setSn_CR(sn,Sn_CR_RECV);
    while(getSn_CR(sn));
-   return len;
+#endif
+   return (int32_t)len;
 }
 
 int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port)
 {
    uint8_t tmp = 0;
    uint16_t freesize = 0;
+   uint32_t taddr;
+
    CHECK_SOCKNUM();
    switch(getSn_MR(sn) & 0x0F)
    {
@@ -393,18 +519,23 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
    CHECK_SOCKDATA();
    //M20140501 : For avoiding fatal error on memory align mismatched
    //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
-   {
-      uint32_t taddr;
+   
+      //uint32_t taddr;
       taddr = ((uint32_t)addr[0]) & 0x000000FF;
       taddr = (taddr << 8) + ((uint32_t)addr[1] & 0x000000FF);
       taddr = (taddr << 8) + ((uint32_t)addr[2] & 0x000000FF);
       taddr = (taddr << 8) + ((uint32_t)addr[3] & 0x000000FF);
-      if (taddr == 0xFFFFFFFF || taddr == 0) return SOCKERR_IPINVALID;
-   }
+   //}
    //
-   if(port == 0)               return SOCKERR_PORTZERO;
+   //if(*((uint32_t*)addr) == 0) return SOCKERR_IPINVALID;
+   if((taddr == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_IPINVALID;
+   if((port  == 0) && ((getSn_MR(sn)&Sn_MR_MACRAW) != Sn_MR_MACRAW)) return SOCKERR_PORTZERO;
    tmp = getSn_SR(sn);
-   if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
+//#if ( _WIZCHIP_ < 5200 )
+   if((tmp != SOCK_MACRAW) && (tmp != SOCK_UDP) && (tmp != SOCK_IPRAW)) return SOCKERR_SOCKSTATUS;
+//#else
+//   if(tmp != SOCK_MACRAW && tmp != SOCK_UDP) return SOCKERR_SOCKSTATUS;
+//#endif
       
    setSn_DIPR(sn,addr);
    setSn_DPORT(sn,port);      
@@ -412,6 +543,7 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
    if (len > freesize) len = freesize; // check size not to exceed MAX size.
    while(1)
    {
+      mp_hal_delay_ms(500);
       freesize = getSn_TX_FSR(sn);
       if(getSn_SR(sn) == SOCK_CLOSED) return SOCKERR_SOCKCLOSED;
       if( (sock_io_mode & (1<<sn)) && (len > freesize) ) return SOCK_BUSY;
@@ -419,11 +551,21 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
       MICROPY_THREAD_YIELD();
    };
 	wiz_send_data(sn, buf, len);
-
-   #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
-      setSUBR(wizchip_getsubn());
+   #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
+      getSIPR((uint8_t*)&taddr);
+      if(taddr == 0)
+      {
+         getSUBR((uint8_t*)&taddr);
+         setSUBR((uint8_t*)"\x00\x00\x00\x00");
+      }
+      else taddr = 0;
    #endif
 
+//A20150601 : For W5300
+#if _WIZCHIP_ == 5300
+   setSn_TX_WRSR(sn, len);
+#endif
+//   
 	setSn_CR(sn,Sn_CR_SEND);
 	/* wait to process the command... */
 	while(getSn_CR(sn));
<<<<<<< HEAD
@@ -440,37 +513,54 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
=======
@@ -440,37 +582,52 @@ int32_t WIZCHIP_EXPORT(sendto)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t
>>>>>>> dev
       else if(tmp & Sn_IR_TIMEOUT)
       {
          setSn_IR(sn, Sn_IR_TIMEOUT);
-   #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
-      setSUBR((uint8_t*)"\x00\x00\x00\x00");
-   #endif
+         //M20150409 : Fixed the lost of sign bits by type casting.
+         //len = (uint16_t)SOCKERR_TIMEOUT;
+         //break;
+         #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
+            if(taddr) setSUBR((uint8_t*)&taddr);
+         #endif
          return SOCKERR_TIMEOUT;
       }
       ////////////
       MICROPY_THREAD_YIELD();
    }
-   #if _WIZCHIP_ == 5200   // for W5200 ARP errata 
-      setSUBR((uint8_t*)"\x00\x00\x00\x00");
+   #if _WIZCHIP_ < 5500   //M20150401 : for WIZCHIP Errata #4, #5 (ARP errata)
+      if(taddr) setSUBR((uint8_t*)&taddr);
    #endif
-	return len;
+   //M20150409 : Explicit Type Casting
+   //return len;
+   return (int32_t)len;
 }
 
 
 
 int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port)
 {
+//M20150601 : For W5300   
+#if _WIZCHIP_ == 5300
+   uint16_t mr;
+   uint16_t mr1;
+#else   
    uint8_t  mr;
+#endif
    uint8_t  head[8];
 	uint16_t pack_len=0;
 
    CHECK_SOCKNUM();
    //CHECK_SOCKMODE(Sn_MR_UDP);
+//A20150601
+#if _WIZCHIP_ == 5300
+   mr1 = getMR();
+#endif   
    switch((mr=getSn_MR(sn)) & 0x0F)
    {
       case Sn_MR_UDP:
+    #if ( _WIZCHIP_ != 5500 )
+	   case Sn_MR_IPRAW:
+    #endif
       case Sn_MR_MACRAW:
          break;
    #if ( _WIZCHIP_ < 5200 )         
-      case Sn_MR_IPRAW:
       case Sn_MR_PPPoE:
          break;
    #endif
<<<<<<< HEAD
@@ -489,7 +579,8 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -489,7 +646,8 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
          MICROPY_THREAD_YIELD();
       };
    }
-   sock_pack_info[sn] = PACK_COMPLETED;
+//D20150601 : Move it to bottom
+// sock_pack_info[sn] = PACK_COMPLETED;
 	switch (mr & 0x07)
 	{
 	   case Sn_MR_UDP :
<<<<<<< HEAD
@@ -499,6 +590,22 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -499,6 +657,22 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			setSn_CR(sn,Sn_CR_RECV);
    			while(getSn_CR(sn));
    			// read peer's IP address, port number & packet length
+   	   //A20150601 : For W5300
+   		#if _WIZCHIP_ == 5300
+   		   if(mr1 & MR_FS)
+   		   {
+   		      addr[0] = head[1];
+   		      addr[1] = head[0];
+   		      addr[2] = head[3];
+   		      addr[3] = head[2];
+   		      *port = head[5];
+   		      *port = (*port << 8) + head[4];
+      			sock_remained_size[sn] = head[7];
+      			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[6];
+   		   }
+            else
+            {
+         #endif
     			addr[0] = head[0];
    			addr[1] = head[1];
    			addr[2] = head[2];
<<<<<<< HEAD
@@ -507,10 +614,24 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -507,10 +681,24 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			*port = (*port << 8) + head[5];
    			sock_remained_size[sn] = head[6];
    			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[7];
+         #if _WIZCHIP_ == 5300
+            }
+         #endif
    			sock_pack_info[sn] = PACK_FIRST;
    	   }
 			if(len < sock_remained_size[sn]) pack_len = len;
 			else pack_len = sock_remained_size[sn];
+			//A20150601 : For W5300
+			len = pack_len;
+			#if _WIZCHIP_ == 5300
+			   if(sock_pack_info[sn] & PACK_FIFOBYTE)
+			   {
+			      *buf++ = sock_remained_byte[sn];
+			      pack_len -= 1;
+			      sock_remained_size[sn] -= 1;
+			      sock_pack_info[sn] &= ~PACK_FIFOBYTE;
+			   }
+			#endif
 			//
 			// Need to packet length check (default 1472)
 			//
<<<<<<< HEAD
@@ -524,8 +645,13 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -524,8 +712,13 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			while(getSn_CR(sn));
    			// read peer's IP address, port number & packet length
     			sock_remained_size[sn] = head[0];
-   			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1];
-   			sock_remained_size[sn] -= 2; // len includes 2 len bytes
+   			sock_remained_size[sn] = (sock_remained_size[sn] <<8) + head[1] -2;
+   			#if _WIZCHIP_ == W5300
+   			if(sock_remained_size[sn] & 0x01)
+   				sock_remained_size[sn] = sock_remained_size[sn] + 1 - 4;
+   			else
+   				sock_remained_size[sn] -= 4;
+			#endif
    			if(sock_remained_size[sn] > 1514) 
    			{
    			   WIZCHIP_EXPORT(close)(sn);
<<<<<<< HEAD
@@ -549,7 +675,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -537,7 +730,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
 			else pack_len = sock_remained_size[sn];
 			wiz_recv_data(sn,buf,pack_len);
 		   break;
-   #if ( _WIZCHIP_ < 5200 )
+   //#if ( _WIZCHIP_ < 5200 )
 		case Sn_MR_IPRAW:
 		   if(sock_remained_size[sn] == 0)
 		   {
@@ -549,7 +742,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
    			addr[2] = head[2];
    			addr[3] = head[3];
    			sock_remained_size[sn] = head[4];
-   			sock_remaiend_size[sn] = (sock_remained_size[sn] << 8) + head[5];
+   			sock_remained_size[sn] = (sock_remained_size[sn] << 8) + head[5];
    			sock_pack_info[sn] = PACK_FIRST;
          }
 			//
<<<<<<< HEAD
@@ -569,11 +695,23 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
=======
@@ -559,7 +752,7 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
 			else pack_len = sock_remained_size[sn];
    		wiz_recv_data(sn, buf, pack_len); // data copy.
 			break;
-   #endif
+   //#endif
       default:
          wiz_recv_ignore(sn, pack_len); // data copy.
          sock_remained_size[sn] = pack_len;
@@ -569,11 +762,23 @@ int32_t WIZCHIP_EXPORT(recvfrom)(uint8_t sn, uint8_t * buf, uint16_t len, uint8_
>>>>>>> dev
 	/* wait to process the command... */
 	while(getSn_CR(sn)) ;
 	sock_remained_size[sn] -= pack_len;
-	//M20140501 : replace 0x01 with PACK_REMAINED
+	//M20150601 : 
 	//if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= 0x01;
-	if(sock_remained_size[sn] != 0) sock_pack_info[sn] |= PACK_REMAINED;
+	if(sock_remained_size[sn] != 0)
+	{
+	   sock_pack_info[sn] |= PACK_REMAINED;
+   #if _WIZCHIP_ == 5300	   
+	   if(pack_len & 0x01) sock_pack_info[sn] |= PACK_FIFOBYTE;
+   #endif	      
+	}
+	else sock_pack_info[sn] = PACK_COMPLETED;
+#if _WIZCHIP_ == 5300	   
+   pack_len = len;
+#endif
    //
- 	return pack_len;
+   //M20150409 : Explicit Type Casting
+   //return pack_len;
+   return (int32_t)pack_len;
 }
 
 
<<<<<<< HEAD
@@ -608,12 +746,15 @@ int8_t  WIZCHIP_EXPORT(ctlsocket)(uint8_t sn, ctlsock_type cstype, void* arg)
=======
@@ -608,12 +813,15 @@ int8_t  WIZCHIP_EXPORT(ctlsocket)(uint8_t sn, ctlsock_type cstype, void* arg)
>>>>>>> dev
       case CS_GET_INTERRUPT:
          *((uint8_t*)arg) = getSn_IR(sn);
          break;
-      case CS_SET_INTMASK:  
+    #if _WIZCHIP_ !=5100
+     case CS_SET_INTMASK:  
          if( (*(uint8_t*)arg) > SIK_ALL) return SOCKERR_ARG;
          setSn_IMR(sn,*(uint8_t*)arg);
          break;
       case CS_GET_INTMASK:   
          *((uint8_t*)arg) = getSn_IMR(sn);
+         break;
+   #endif
       default:
          return SOCKERR_ARG;
    }
<<<<<<< HEAD
@@ -660,7 +801,7 @@ int8_t  WIZCHIP_EXPORT(setsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
=======
@@ -660,7 +868,7 @@ int8_t  WIZCHIP_EXPORT(setsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
>>>>>>> dev
          		}
             }
          break;
-   #if _WIZCHIP_ > 5200
+   #if !( (_WIZCHIP_ == 5100) || (_WIZCHIP_ == 5200) )
       case SO_KEEPALIVEAUTO:
          CHECK_SOCKMODE(Sn_MR_TCP);
          setSn_KPALVTR(sn,*(uint8_t*)arg);
<<<<<<< HEAD
@@ -688,7 +829,8 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
=======
@@ -688,7 +896,8 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
>>>>>>> dev
          *(uint8_t*) arg = getSn_TOS(sn);
          break;
       case SO_MSS:   
-         *(uint8_t*) arg = getSn_MSSR(sn);
+         *(uint16_t*) arg = getSn_MSSR(sn);
+         break;
       case SO_DESTIP:
          getSn_DIPR(sn, (uint8_t*)arg);
          break;
<<<<<<< HEAD
@@ -703,19 +845,25 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
=======
@@ -703,19 +912,25 @@ int8_t  WIZCHIP_EXPORT(getsockopt)(uint8_t sn, sockopt_type sotype, void* arg)
>>>>>>> dev
    #endif      
       case SO_SENDBUF:
          *(uint16_t*) arg = getSn_TX_FSR(sn);
+         break;
       case SO_RECVBUF:
          *(uint16_t*) arg = getSn_RX_RSR(sn);
+         break;
       case SO_STATUS:
          *(uint8_t*) arg = getSn_SR(sn);
          break;
       case SO_REMAINSIZE:
-         if(getSn_MR(sn) == Sn_MR_TCP)
+         if(getSn_MR(sn) & Sn_MR_TCP)
             *(uint16_t*)arg = getSn_RX_RSR(sn);
          else
             *(uint16_t*)arg = sock_remained_size[sn];
          break;
       case SO_PACKINFO:
-         CHECK_SOCKMODE(Sn_MR_TCP);
+         //CHECK_SOCKMODE(Sn_MR_TCP);
+#if _WIZCHIP_ != 5300
+         if((getSn_MR(sn) == Sn_MR_TCP))
+             return SOCKERR_SOCKMODE;
+#endif
          *(uint8_t*)arg = sock_pack_info[sn];
          break;
       default:
diff --git a/drivers/wiznet5k/ethernet/socket.h b/drivers/wiznet5k/ethernet/socket.h
index 2f03a34eb..2857277e5 100644
--- a/drivers/wiznet5k/ethernet/socket.h
+++ b/drivers/wiznet5k/ethernet/socket.h
@@ -124,6 +124,11 @@
    #define SF_UNI_BLOCK           (Sn_MR_UCASTB)   ///< In \ref Sn_MR_UDP with \ref SF_MULTI_ENABLE. Valid only in W5500
 #endif
 
+//A201505 : For W5300
+#if _WIZCHIP_ == 5300
+   #define SF_TCP_ALIGN		     0x02			   ///< Valid only \ref Sn_MR_TCP and W5300, refer to \ref Sn_MR_ALIGN
+#endif
+
 #define SF_IO_NONBLOCK           0x01              ///< Socket nonblock io mode. It used parameter in \ref socket().
 
 /*
@@ -132,6 +137,8 @@
 #define PACK_FIRST               0x80              ///< In Non-TCP packet, It indicates to start receiving a packet.
 #define PACK_REMAINED            0x01              ///< In Non-TCP packet, It indicates to remain a packet to be received.
 #define PACK_COMPLETED           0x00              ///< In Non-TCP packet, It indicates to complete to receive a packet.
+//A20150601 : For Integrating with W5300
+#define PACK_FIFOBYTE            0x02              ///< Valid only W5300, It indicate to have read already the Sn_RX_FIFOR.
 
 // resets all global state associated with the socket interface
 void WIZCHIP_EXPORT(socket_reset)(void);
@@ -343,7 +350,9 @@ typedef enum
    SIK_RECEIVED      = (1 << 2),    ///< data received
    SIK_TIMEOUT       = (1 << 3),    ///< timeout occurred
    SIK_SENT          = (1 << 4),    ///< send ok
-   SIK_ALL           = 0x1F,        ///< all interrupt
+   //M20150410 : Remove the comma of last member
+   //SIK_ALL           = 0x1F,        ///< all interrupt
+   SIK_ALL           = 0x1F         ///< all interrupt
 }sockint_kind;
 
 /**
@@ -358,8 +367,10 @@ typedef enum
    CS_GET_MAXRXBUF,        ///< get the size of socket buffer allocated in RX memory
    CS_CLR_INTERRUPT,       ///< clear the interrupt of socket with @ref sockint_kind
    CS_GET_INTERRUPT,       ///< get the socket interrupt. refer to @ref sockint_kind
-   CS_SET_INTMASK,         ///< set the interrupt mask of socket with @ref sockint_kind
-   CS_GET_INTMASK          ///< get the masked interrupt of socket. refer to @ref sockint_kind
+#if _WIZCHIP_ > 5100
+   CS_SET_INTMASK,         ///< set the interrupt mask of socket with @ref sockint_kind, Not supported in W5100
+   CS_GET_INTMASK          ///< get the masked interrupt of socket. refer to @ref sockint_kind, Not supported in W5100
+#endif
 }ctlsock_type;
 
 
@@ -376,9 +387,9 @@ typedef enum
    SO_DESTIP,           ///< Set/Get the destination IP address. @ref Sn_DIPR ( @ref setSn_DIPR(), @ref getSn_DIPR() )
    SO_DESTPORT,         ///< Set/Get the destination Port number. @ref Sn_DPORT ( @ref setSn_DPORT(), @ref getSn_DPORT() )
 #if _WIZCHIP_ != 5100   
-   SO_KEEPALIVESEND,    ///< Valid only in setsockopt. Manually send keep-alive packet in TCP mode
-   #if _WIZCHIP_ > 5200   
-      SO_KEEPALIVEAUTO, ///< Set/Get keep-alive auto transmission timer in TCP mode
+   SO_KEEPALIVESEND,    ///< Valid only in setsockopt. Manually send keep-alive packet in TCP mode, Not supported in W5100
+   #if !( (_WIZCHIP_ == 5100) || (_WIZCHIP_ == 5200) )
+      SO_KEEPALIVEAUTO, ///< Set/Get keep-alive auto transmission timer in TCP mode, Not supported in W5100, W5200
    #endif      
 #endif
    SO_SENDBUF,          ///< Valid only in getsockopt. Get the free data size of Socekt TX buffer. @ref Sn_TX_FSR, @ref getSn_TX_FSR()
diff --git a/drivers/wiznet5k/ethernet/w5100/w5100.c b/drivers/wiznet5k/ethernet/w5100/w5100.c
new file mode 100644
index 000000000..4eece132d
--- /dev/null
+++ b/drivers/wiznet5k/ethernet/w5100/w5100.c
@@ -0,0 +1,395 @@
+//*****************************************************************************
+//
+//! \file w5100.c
+//! \brief W5100 HAL Interface.
+//! \version 1.0.0
+//! \date 2013/10/21
+//! \par  Revision history
+//!       <2013/10/21> 1st Release
+//! \author MidnightCow
+//! 
+//! Copyright (c)  2013, WIZnet Co., LTD.
+//! All rights reserved.
+//! 
+//! Redistribution and use in source and binary forms, with or without 
+//! modification, are permitted provided that the following conditions 
+//! are met: 
+//! 
+//!     * Redistributions of source code must retain the above copyright 
+//! notice, this list of conditions and the following disclaimer. 
+//!     * Redistributions in binary form must reproduce the above copyright
+//! notice, this list of conditions and the following disclaimer in the
+//! documentation and/or other materials provided with the distribution. 
+//!     * Neither the name of the <ORGANIZATION> nor the names of its 
+//! contributors may be used to endorse or promote products derived 
+//! from this software without specific prior written permission. 
+//! 
+//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
+//! THE POSSIBILITY OF SUCH DAMAGE.
+//
+//*****************************************************************************
+
+#include "w5100.h"
+
+#define LPC_SSP0 (0)
+
+static void Chip_SSP_ReadFrames_Blocking(int dummy, uint8_t *buf, uint32_t len) {
+    WIZCHIP.IF.SPI._read_bytes(buf, len);
+}
+
+static void Chip_SSP_WriteFrames_Blocking(int dummy, const uint8_t *buf, uint32_t len) {
+    WIZCHIP.IF.SPI._write_bytes(buf, len);
+}
+
+#if   (_WIZCHIP_ == 5100)
+/**
+@brief  This function writes the data into W5100 registers.
+*/
+void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
+{
+   uint8_t spi_data[4];
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();
+
+#if( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_))
+   spi_data[0] = 0xF0;
+	spi_data[1] = (AddrSel & 0xFF00) >>  8;
+	spi_data[2] = (AddrSel & 0x00FF) >>  0;
+	spi_data[3] = wb;
+	Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 4);
+
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_) )
+   //M20150601 : Rename the function for integrating with ioLibrary
+   //WIZCHIP.IF.BUS._write_byte(AddrSel,wb);
+   WIZCHIP.IF.BUS._write_data(AddrSel,wb);
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+
+   //add indirect bus 
+   //M20150601 : Rename the function for integrating with ioLibrary
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));	
+   //WIZCHIP.IF.BUS._write_byte(IDM_DR,wb);
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));	
+   WIZCHIP.IF.BUS._write_data(IDM_DR,wb);
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100. !!!"
+#endif
+
+   WIZCHIP.CS._deselect();
+   WIZCHIP_CRITICAL_EXIT();
+}
+/**
+@brief  This function reads the value from W5100 registers.
+*/
+uint8_t  WIZCHIP_READ(uint32_t AddrSel)
+{
+   uint8_t ret;
+   uint8_t spi_data[3];
+
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();
+
+#if( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_))
+   spi_data[0] = 0x0F;
+   spi_data[1] = (AddrSel & 0xFF00) >>  8;
+   spi_data[2] = (AddrSel & 0x00FF) >>  0;
+   Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
+   Chip_SSP_ReadFrames_Blocking(LPC_SSP0, &ret, 1);
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_) )
+   //M20150601 : Rename the function for integrating with ioLibrary
+   //ret = WIZCHIP.IF.BUS._read_byte(AddrSel);
+   ret = WIZCHIP.IF.BUS._read_data(AddrSel);   
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+
+   //add indirect bus
+   //M20150601 : Rename the function for integrating with ioLibrary
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));	
+   //ret = WIZCHIP.IF.BUS._read_byte(IDM_DR);
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));	
+   ret = WIZCHIP.IF.BUS._read_data(IDM_DR);
+
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100. !!!"   
+#endif
+
+   WIZCHIP.CS._deselect();
+   WIZCHIP_CRITICAL_EXIT();
+   return ret;
+}
+
+
+/**
+@brief  This function writes into W5100 memory(Buffer)
+*/ 
+void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
+{
+   uint8_t spi_data[3];
+   uint16_t i = 0;
+
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();   //M20150601 : Moved here.
+
+#if( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_))
+     //M20160715 : Depricated "M20150601 : Remove _select() to top-side"
+     //            CS should be controlled every SPI frames
+    spi_data[0] = 0xF0;
+	spi_data[1] = (((uint16_t)(AddrSel+i)) & 0xFF00) >>  8;
+	spi_data[2] = (((uint16_t)(AddrSel+i)) & 0x00FF) >>  0;
+	Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
+    Chip_SSP_WriteFrames_Blocking(LPC_SSP0, pBuf, len);
+ 
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_) )
+   for(i = 0; i < len; i++)
+   //M20150601 : Rename the function for integrating with ioLibrary  
+   //  WIZCHIP.IF.BUS._write_byte(AddrSel+i,pBuf[i]);  
+       WIZCHIP.IF.BUS._write_data(AddrSel+i,pBuf[i]);  
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+   //M20150601 : Rename the function for integrating with ioLibrary  
+   /*
+   WIZCHIP_WRITE(MR,WIZCHIP_READ(MR) | MR_AI);     
+   WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));
+   for(i = 0 ; i < len; i++)
+      WIZCHIP.IF.BUS._write_byte(IDM_DR,pBuf[i]);
+   WIZCHIP_WRITE(MR, WIZCHIP_READ(MR) & ~MR_AI);   
+   */
+   setMR(getMR()|MR_AI);     
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));
+   for(i = 0 ; i < len; i++)
+      WIZCHIP.IF.BUS._write_data(IDM_DR,pBuf[i]);
+   setMR(getMR() & ~MR_AI);   
+
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100. !!!!"
+#endif
+   
+   WIZCHIP.CS._deselect();  //M20150601 : Moved here.
+   WIZCHIP_CRITICAL_EXIT();
+}
+
+/**
+@brief  This function reads into W5100 memory(Buffer)
+*/ 
+
+void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
+{
+   uint8_t spi_data[3];
+   uint16_t i = 0;
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();   //M20150601 : Moved here.
+   
+   #if( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_))
+     //M20160715 : Depricated "M20150601 : Remove _select() to top-side"
+     //            CS should be controlled every SPI frames
+     spi_data[0] = 0x0F;
+	 spi_data[1] = (uint16_t)((AddrSel+i) & 0xFF00) >>  8;
+	 spi_data[2] = (uint16_t)((AddrSel+i) & 0x00FF) >>  0;
+	 Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
+     Chip_SSP_ReadFrames_Blocking(LPC_SSP0, pBuf, len);
+
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_) )
+   for(i = 0 ; i < len; i++)
+   //M20150601 : Rename the function for integrating with ioLibrary  
+   // pBuf[i]	= WIZCHIP.IF.BUS._read_byte(AddrSel+i);
+      pBuf[i]	= WIZCHIP.IF.BUS._read_data(AddrSel+i);
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+   //M20150601 : Rename the function for integrating with ioLibrary  
+   /*
+   WIZCHIP_WRITE(MR, WIZCHIP_READ(MR) | MR_AI);    
+   WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));	
+   for(i = 0 ; i < len; i++)
+      pBuf[i]	= WIZCHIP.IF.BUS._read_byte(IDM_DR);
+   WIZCHIP_WRITE(MR, WIZCHIP_READ(MR) & ~MR_AI); 
+   */
+   setMR(getMR() | MR_AI);
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));	
+   for(i = 0 ; i < len; i++)
+      pBuf[i]	= WIZCHIP.IF.BUS._read_data(IDM_DR);
+   setMR(getMR() & ~MR_AI); 
+   
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100. !!!!"
+#endif
+
+   WIZCHIP.CS._deselect();    //M20150601 : Moved Here.
+   WIZCHIP_CRITICAL_EXIT();
+}
+
+///////////////////////////////////
+// Socket N regsiter IO function //
+///////////////////////////////////
+
+uint16_t getSn_TX_FSR(uint8_t sn)
+{
+   uint16_t val=0,val1=0;
+   do
+   {
+      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
+      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
+      if (val1 != 0)
+      {
+        val = WIZCHIP_READ(Sn_TX_FSR(sn));
+        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
+      }
+   }while (val != val1);
+   return val;
+}
+
+
+uint16_t getSn_RX_RSR(uint8_t sn)
+{
+   uint16_t val=0,val1=0;
+   do
+   {
+      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
+      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
+      if (val1 != 0)
+      {
+        val = WIZCHIP_READ(Sn_RX_RSR(sn));
+        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
+      }
+   }while (val != val1);
+   return val;
+}
+
+/////////////////////////////////////
+// Sn_TXBUF & Sn_RXBUF IO function //
+/////////////////////////////////////
+uint32_t getSn_RxBASE(uint8_t sn)
+{
+   int8_t  i;
+#if ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
+   uint32_t rxbase = _W5100_IO_BASE_ + _WIZCHIP_IO_RXBUF_;
+#else   
+   uint32_t rxbase = _WIZCHIP_IO_RXBUF_;
+#endif   
+   for(i = 0; i < sn; i++)
+      rxbase += getSn_RxMAX(i);
+
+   return rxbase;
+}
+
+uint32_t getSn_TxBASE(uint8_t sn)
+{
+   int8_t  i;
+#if ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
+   uint32_t txbase = _W5100_IO_BASE_ + _WIZCHIP_IO_TXBUF_;
+#else   
+   uint32_t txbase = _WIZCHIP_IO_TXBUF_;
+#endif   
+   for(i = 0; i < sn; i++)
+      txbase += getSn_TxMAX(i);
+   return txbase;
+}
+
+/**
+@brief  This function is being called by send() and sendto() function also. for copy the data form application buffer to Transmite buffer of the chip.
+
+This function read the Tx write pointer register and after copy the data in buffer update the Tx write pointer
+register. User should read upper byte first and lower byte later to get proper value.
+And this function is being used for copy the data form application buffer to Transmite
+buffer of the chip. It calculate the actual physical address where one has to write
+the data in transmite buffer. Here also take care of the condition while it exceed
+the Tx memory uper-bound of socket.
+
+*/
+void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
+{
+  uint16_t ptr;
+  uint16_t size;
+  uint16_t dst_mask;
+  uint16_t dst_ptr;
+
+  ptr = getSn_TX_WR(sn);
+
+  dst_mask = ptr & getSn_TxMASK(sn);
+  dst_ptr = getSn_TxBASE(sn) + dst_mask;
+  
+  if (dst_mask + len > getSn_TxMAX(sn)) 
+  {
+    size = getSn_TxMAX(sn) - dst_mask;
+    WIZCHIP_WRITE_BUF(dst_ptr, wizdata, size);
+    wizdata += size;
+    size = len - size;
+    dst_ptr = getSn_TxBASE(sn);
+    WIZCHIP_WRITE_BUF(dst_ptr, wizdata, size);
+  } 
+  else
+  {
+    WIZCHIP_WRITE_BUF(dst_ptr, wizdata, len);
+  }
+
+  ptr += len;
+
+  setSn_TX_WR(sn, ptr);  
+}
+
+
+/**
+@brief  This function is being called by recv() also. This function is being used for copy the data form Receive buffer of the chip to application buffer.
+
+This function read the Rx read pointer register
+and after copy the data from receive buffer update the Rx write pointer register.
+User should read upper byte first and lower byte later to get proper value.
+It calculate the actual physical address where one has to read
+the data from Receive buffer. Here also take care of the condition while it exceed
+the Rx memory uper-bound of socket.
+*/
+void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
+{
+  uint16_t ptr;
+  uint16_t size;
+  uint16_t src_mask;
+  uint16_t src_ptr;
+
+  ptr = getSn_RX_RD(sn);
+  
+  src_mask = (uint32_t)ptr & getSn_RxMASK(sn);
+  src_ptr = (getSn_RxBASE(sn) + src_mask);
+
+  
+  if( (src_mask + len) > getSn_RxMAX(sn) ) 
+  {
+    size = getSn_RxMAX(sn) - src_mask;
+    WIZCHIP_READ_BUF((uint32_t)src_ptr, (uint8_t*)wizdata, size);
+    wizdata += size;
+    size = len - size;
+	src_ptr = getSn_RxBASE(sn);
+    WIZCHIP_READ_BUF(src_ptr, (uint8_t*)wizdata, size);
+  } 
+  else
+  {
+    WIZCHIP_READ_BUF(src_ptr, (uint8_t*)wizdata, len);
+  }
+    
+  ptr += len;
+  
+  setSn_RX_RD(sn, ptr);
+}
+
+void wiz_recv_ignore(uint8_t sn, uint16_t len)
+{
+  uint16_t ptr;
+
+  ptr = getSn_RX_RD(sn);
+  
+  ptr += len;
+  setSn_RX_RD(sn,ptr);
+}
+
+#endif
diff --git a/drivers/wiznet5k/ethernet/w5100/w5100.h b/drivers/wiznet5k/ethernet/w5100/w5100.h
new file mode 100644
index 000000000..8b7bee3ec
--- /dev/null
+++ b/drivers/wiznet5k/ethernet/w5100/w5100.h
@@ -0,0 +1,1869 @@
+//* ****************************************************************************
+//! \file w5100.h
+//! \brief W5100 HAL Header File.
+//! \version 1.0.0
+//! \date 2013/10/21
+//! \par  Revision history
+//!       <2013/10/21> 1st Release
+//! \author MidnightCow
+//! \copyright
+//!
+//! Copyright (c)  2013, WIZnet Co., LTD.
+//! All rights reserved.
+//! 
+//! Redistribution and use in source and binary forms, with or without 
+//! modification, are permitted provided that the following conditions 
+//! are met: 
+//! 
+//!     * Redistributions of source code must retain the above copyright 
+//! notice, this list of conditions and the following disclaimer. 
+//!     * Redistributions in binary form must reproduce the above copyright
+//! notice, this list of conditions and the following disclaimer in the
+//! documentation and/or other materials provided with the distribution. 
+//!     * Neither the name of the <ORGANIZATION> nor the names of its 
+//! contributors may be used to endorse or promote products derived 
+//! from this software without specific prior written permission. 
+//! 
+//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
+//! THE POSSIBILITY OF SUCH DAMAGE.
+//
+//*****************************************************************************
+
+#ifndef	_W5100_H_
+#define	_W5100_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include "../wizchip_conf.h"
+
+/// \cond DOXY_APPLY_CODE
+#if   (_WIZCHIP_ == 5100)
+/// \endcond
+
+#define _WIZCHIP_SN_BASE_  (0x0400)
+#define _WIZCHIP_SN_SIZE_  (0x0100)
+#define _WIZCHIP_IO_TXBUF_ (0x4000) /* Internal Tx buffer address of the iinchip */
+#define _WIZCHIP_IO_RXBUF_ (0x6000) /* Internal Rx buffer address of the iinchip */
+
+
+#define WIZCHIP_CREG_BLOCK      	      0x00   ///< Common register block
+#define WIZCHIP_SREG_BLOCK(N)    	   (_WIZCHIP_SN_BASE_+ _WIZCHIP_SN_SIZE_*N) ///< Socket N register block
+
+#define WIZCHIP_OFFSET_INC(ADDR, N)    (ADDR + N) ///< Increase offset address
+
+#if (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
+   #define _W5100_IO_BASE_     _WIZCHIP_IO_BASE_
+#elif (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
+	#define IDM_OR             ((_WIZCHIP_IO_BASE  + 0x0000))
+	#define IDM_AR0            ((_WIZCHIP_IO_BASE_ + 0x0001))
+	#define IDM_AR1            ((_WIZCHIP_IO_BASE_ + 0x0002))
+	#define IDM_DR             ((_WIZCHIP_IO_BASE_ + 0x0003))
+	#define _W5100_IO_BASE_    0x0000
+#elif (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
+   #define _W5100_IO_BASE_    0x0000
+#endif
+
+///////////////////////////////////////
+// Definition For Legacy Chip Driver //
+///////////////////////////////////////
+#define IINCHIP_READ(ADDR)                WIZCHIP_READ(ADDR)               ///< The defined for legacy chip driver
+#define IINCHIP_WRITE(ADDR,VAL)           WIZCHIP_WRITE(ADDR,VAL)          ///< The defined for legacy chip driver
+#define IINCHIP_READ_BUF(ADDR,BUF,LEN)    WIZCHIP_READ_BUF(ADDR,BUF,LEN)   ///< The defined for legacy chip driver
+#define IINCHIP_WRITE_BUF(ADDR,BUF,LEN)   WIZCHIP_WRITE(ADDR,BUF,LEN)      ///< The defined for legacy chip driver
+
+
+//-----------    defgroup --------------------------------
+
+/**
+ * @defgroup W5100 W5100
+ * @brief WHIZCHIP register defines and I/O functions of @b W5100.
+ *
+ * - @ref WIZCHIP_register_W5100 : @ref Common_register_group_W5100 and @ref Socket_register_group_W5100
+ * - @ref WIZCHIP_IO_Functions_W5100 : @ref Basic_IO_function_W5100, @ref Common_register_access_function_W5100 and @ref Socket_register_group_W5100
+ */
+ 
+ /**
+ * @defgroup WIZCHIP_register_W5100 WIZCHIP register
+ * @ingroup W5100
+ * @brief WIZCHIP register defines register group of <b> W5100 </b>.
+ *
+ * - \ref Common_register_group_W5100 : Common register group W5100
+ * - \ref Socket_register_group_W5100 : \c SOCKET n register group W5100
+ */
+ 
+
+/**
+ * @defgroup WIZCHIP_IO_Functions_W5100 WIZCHIP I/O functions
+ * @ingroup W5100 
+ * @brief This supports the basic I/O functions for \ref WIZCHIP_register_W5100.
+ *
+ * - <b> Basic I/O function </b> \n
+ *   WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF() \n\n
+ *
+ * - \ref Common_register_group_W5100 <b>access functions</b> \n
+ * 	-# @b Mode \n
+ *    getMR(), setMR()
+ * 	-# @b Interrupt \n
+ *    getIR(), setIR(), getIMR(), setIMR(), 
+ * 	-# <b> Network Information </b> \n
+ *    getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR()
+ * 	-# @b Retransmission \n
+ *    getRCR(), setRCR(), getRTR(), setRTR()
+ * 	-# @b PPPoE \n
+ *    getPTIMER(), setPTIMER(), getPMAGIC(), getPMAGIC()
+ *
+ * - \ref Socket_register_group_W5100 <b>access functions</b> \n
+ *   -# <b> SOCKET control</b> \n
+ *      getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IR()
+ *   -# <b> SOCKET information</b> \n
+ *      getSn_SR(), getSn_DHAR(), setSn_DHAR(), getSn_PORT(), setSn_PORT(), getSn_DIPR(), setSn_DIPR(), getSn_DPORT(), setSn_DPORT()
+ *      getSn_MSSR(), setSn_MSSR()
+ *   -# <b> SOCKET communication </b> \n
+ *      getSn_RXMEM_SIZE(), setSn_RXMEM_SIZE(), getSn_TXMEM_SIZE(), setSn_TXMEM_SIZE() \n
+ *      getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
+ *      getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
+ *      getSn_TX_FSR(), getSn_RX_RSR()
+ *   -# <b> IP header field </b> \n
+ *      getSn_FRAG(), setSn_FRAG(),  getSn_TOS(), setSn_TOS() \n
+ *      getSn_TTL(), setSn_TTL()
+ */
+ 
+/**
+ * @defgroup Common_register_group_W5100 Common register
+ * @ingroup WIZCHIP_register_W5100
+ * @brief Common register group\n
+ * It set the basic for the networking\n
+ * It set the configuration such as interrupt, network information, ICMP, etc.
+ * @details
+ * @sa MR : Mode register.
+ * @sa GAR, SUBR, SHAR, SIPR
+ * @sa IR, Sn_IR, _IMR_  : Interrupt.
+ * @sa _RTR_, _RCR_ : Data retransmission.
+ * @sa PTIMER, PMAGIC : PPPoE.
+ */
+
+
+ /**
+ * @defgroup Socket_register_group_W5100 Socket register
+ * @ingroup WIZCHIP_register_W5100
+ * @brief Socket register group\n
+ * Socket register configures and control SOCKETn which is necessary to data communication.
+ * @details
+ * @sa Sn_MR, Sn_CR, Sn_IR : SOCKETn Control
+ * @sa Sn_SR, Sn_PORT, Sn_DHAR, Sn_DIPR, Sn_DPORT : SOCKETn Information
+ * @sa Sn_MSSR, Sn_TOS, Sn_TTL, Sn_FRAG : Internet protocol.
+ * @sa Sn_RXMEM_SIZE, Sn_TXMEM_SIZE, Sn_TX_FSR, Sn_TX_RD, Sn_TX_WR, Sn_RX_RSR, Sn_RX_RD, Sn_RX_WR : Data communication
+ */
+ 
+ /**
+ * @defgroup Basic_IO_function_W5100 Basic I/O function
+ * @ingroup WIZCHIP_IO_Functions_W5100
+ * @brief These are basic input/output functions to read values from register or write values to register.
+ */
+
+/**
+ * @defgroup Common_register_access_function_W5100 Common register access functions
+ * @ingroup WIZCHIP_IO_Functions_W5100
+ * @brief These are functions to access <b>common registers</b>.
+ */
+ 
+/**
+ * @defgroup Socket_register_access_function_W5100 Socket register access functions
+ * @ingroup WIZCHIP_IO_Functions_W5100
+ * @brief These are functions to access <b>socket registers</b>.
+ */
+ 
+ //-----------------------------------------------------------------------------------
+
+//----------------------------- W5100 Common Registers IOMAP -----------------------------
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Mode Register address(R/W)\n
+ * \ref MR is used for S/W reset, ping block mode, PPPoE mode and etc.
+ * @details Each bit of \ref MR defined as follows.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>RST</td> <td>Reserved</td> <td>WOL</td> <td>PB</td> <td>PPPoE</td> <td>Reserved</td> <td>AI</td> <td>IND</td> </tr>
+ * </table>
+ * - \ref MR_RST		 	   : Reset
+ * - \ref MR_PB         	: Ping block
+ * - \ref MR_PPPOE      	: PPPoE mode
+ * - \ref MR_AI         	: Address Auto-Increment in Indirect Bus Interface
+ * - \ref MR_IND         	: Indirect Bus Interface mode
+ */
+#if _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_
+   #define MR					(_WIZCHIP_IO_BASE_ + (0x0000))  // Mode
+#else
+   #define MR					(_W5100_IO_BASE_ + (0x0000))  // Mode
+#endif   
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Gateway IP Register address(R/W)
+ * @details \ref GAR configures the default gateway address.
+ */
+#define GAR     			(_W5100_IO_BASE_ + (0x0001))  // GW Address
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Subnet mask Register address(R/W)
+ * @details \ref SUBR configures the subnet mask address.
+ */
+#define SUBR    			(_W5100_IO_BASE_ + (0x0005)) // SN Mask Address
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Source MAC Register address(R/W)
+ * @details \ref SHAR configures the source hardware address.
+ */
+#define SHAR    			(_W5100_IO_BASE_ + (0x0009)) // Source Hardware Address
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Source IP Register address(R/W)
+ * @details \ref SIPR configures the source IP address.
+ */
+#define SIPR    			(_W5100_IO_BASE_ + (0x000F)) // Source IP Address
+
+// Reserved					(_W5100_IO_BASE_ + (0x0013))
+// Reserved					(_W5100_IO_BASE_ + (0x0014))
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Interrupt Register(R/W)
+ * @details \ref IR indicates the interrupt status. Each bit of \ref IR will be still until the bit will be written to by the host.
+ * If \ref IR is not equal to x00 INTn PIN is asserted to low until it is x00\n\n
+ * Each bit of \ref IR defined as follows.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>CONFLICT</td> <td>UNREACH</td> <td>PPPoE</td> <td>Reserved</td> <td>S3_INT</td> <td>S2_INT</td> <td>S1_INT</td> <td>S0_INT</td> </tr>
+ * </table>
+ * - \ref IR_CONFLICT : IP conflict
+ * - \ref IR_UNREACH  : Destination unreachable
+ * - \ref IR_PPPoE	 : PPPoE connection close
+ * - \ref IR_SOCK(3)  : SOCKET 3 Interrupt
+ * - \ref IR_SOCK(2)  : SOCKET 2 Interrupt
+ * - \ref IR_SOCK(1)  : SOCKET 1 Interrupt
+ * - \ref IR_SOCK(0)  : SOCKET 0 Interrupt 
+ */
+#define IR					(_W5100_IO_BASE_ + (0x0015)) // Interrupt
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Socket Interrupt Mask Register(R/W)
+ * @details Each bit of \ref _IMR_ corresponds to each bit of \ref IR.
+ * When a bit of \ref _IMR_ is and the corresponding bit of \ref IR is set, Interrupt will be issued.
+ */
+#define _IMR_    			(_W5100_IO_BASE_ + (0x0016)) // Socket Interrupt Mask
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Timeout register address( 1 is 100us )(R/W)
+ * @details \ref _RTR_ configures the retransmission timeout period. The unit of timeout period is 100us and the default of \ref _RTR_ is x07D0or 000
+ * And so the default timeout period is 200ms(100us X 2000). During the time configured by \ref _RTR_, W5100 waits for the peer response
+ * to the packet that is transmitted by \ref Sn_CR (CONNECT, DISCON, CLOSE, SEND, SEND_MAC, SEND_KEEP command).
+ * If the peer does not respond within the \ref _RTR_ time, W5100 retransmits the packet or issues timeout.
+ */
+#define _RTR_     			(_W5100_IO_BASE_ + (0x0017)) // Retry Time
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief Retry count register(R/W)
+ * @details \ref _RCR_ configures the number of time of retransmission.
+ * When retransmission occurs as many as ref _RCR_+1 Timeout interrupt is issued (\ref Sn_IR_TIMEOUT = '1').
+ */
+#define _RCR_      		(_W5100_IO_BASE_ + (0x0019)) // Retry Count
+#define RMSR				(_W5100_IO_BASE_ + (0x001A)) // Receicve Memory Size
+#define TMSR				(_W5100_IO_BASE_ + (0x001B)) // Trnasmit Memory Size
+
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief PPP LCP Request Timer register  in PPPoE mode(R)
+ * @details \ref PATR notifies authentication method that has been agreed at the connection with
+ * PPPoE Server. W5100 supports two types of Authentication method - PAP and CHAP.
+ */
+#define PATR            (_W5100_IO_BASE_ + (0x001C))
+
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief PPP LCP Request Timer register  in PPPoE mode(R)
+ * @details \ref PTIMER configures the time for sending LCP echo request. The unit of time is 25ms.
+ */
+#define PTIMER  			(_W5100_IO_BASE_ + (0x0028)) // PPP LCP RequestTimer
+
+/**
+ * @ingroup Common_register_group_W5100
+ * @brief PPP LCP Magic number register  in PPPoE mode(R)
+ * @details \ref PMAGIC configures the 4bytes magic number to be used in LCP negotiation.
+ */
+#define PMAGIC   			(_W5100_IO_BASE_ + (0x0029)) // PPP LCP Magic number
+
+#define UIPR0				(_W5100_IO_BASE_ + (0x002A))
+#define UPORT0          (_W5100_IO_BASE  + (0x002E))
+
+
+
+//----------------------------- W5100 Socket Registers -----------------------------
+
+//--------------------------- For Backward Compatibility ---------------------------
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief socket Mode register(R/W)
+ * @details \ref Sn_MR configures the option or protocol type of Socket n.\n\n
+ * Each bit of \ref Sn_MR defined as the following.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>MULTI</td> <td>MF</td> <td>ND/MC</td> <td>Reserved</td> <td>Protocol[3]</td> <td>Protocol[2]</td> <td>Protocol[1]</td> <td>Protocol[0]</td> </tr>
+ * </table>
+ * - \ref Sn_MR_MULTI	: Support UDP Multicasting
+ * - \ref Sn_MR_MF	   : Support MACRAW
+ * - \ref Sn_MR_ND		: No Delayed Ack(TCP) flag
+ * - \ref Sn_MR_MC   	: IGMP version used <b>in UDP mulitcasting</b>
+ * - <b>Protocol</b>
+ * <table>
+ * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
+ * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>Closed</td>   </tr>
+ * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>TCP</td>   </tr>
+ * 		<tr>   <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>UDP</td>   </tr>
+ * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
+ * </table>
+ * - <b>In case of Socket 0</b>
+ *  <table>
+ * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
+ * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
+ * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>PPPoE</td>   </tr>
+ * </table> 
+ *	 - \ref Sn_MR_MACRAW	: MAC LAYER RAW SOCK \n
+ *  - \ref Sn_MR_UDP		: UDP
+ *  - \ref Sn_MR_TCP		: TCP
+ *  - \ref Sn_MR_CLOSE	: Unused socket
+ *  @note MACRAW mode should be only used in Socket 0.
+ */
+#define Sn_MR(sn)			(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0000)) // socket Mode register
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Socket command register(R/W)
+ * @details This is used to set the command for Socket n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
+ * After W5100 accepts the command, the \ref Sn_CR register is automatically cleared to 0x00.
+ * Even though \ref Sn_CR is cleared to 0x00, the command is still being processed.\n
+ * To check whether the command is completed or not, please check the \ref Sn_IR or \ref Sn_SR.
+ * - \ref Sn_CR_OPEN 		: Initialize or open socket.
+ * - \ref Sn_CR_LISTEN 		: Wait connection request in TCP mode(<b>Server mode</b>)
+ * - \ref Sn_CR_CONNECT 	: Send connection request in TCP mode(<b>Client mode</b>)
+ * - \ref Sn_CR_DISCON 		: Send closing request in TCP mode.
+ * - \ref Sn_CR_CLOSE   	: Close socket.
+ * - \ref Sn_CR_SEND    	: Update TX buffer pointer and send data.
+ * - \ref Sn_CR_SEND_MAC	: Send data with MAC address, so without ARP process.
+ * - \ref Sn_CR_SEND_KEEP 	: Send keep alive message.
+ * - \ref Sn_CR_RECV		: Update RX buffer pointer and receive data.
+ * - <b>In case of S0_MR(P3:P0) = S0_MR_PPPoE</b>
+ *  <table>
+ * 		<tr>   <td><b>Value</b></td> <td><b>Symbol</b></td> <td><b>Description</b></td></tr>
+ * 		<tr>   <td>0x23</td> <td>PCON</td> <td>PPPoE connection begins by transmitting PPPoE discovery packet</td>  </tr>
+ * 		<tr>   <td>0x24</td> <td>PDISCON</td> <td>Closes PPPoE connection</td>  </tr>
+ * 		<tr>   <td>0x25</td> <td>PCR</td> <td>In each phase, it transmits REQ message.</td> </tr>
+ * 		<tr>   <td>0x26</td> <td>PCN</td> <td>In each phase, it transmits NAK message.</td> </tr>
+ * 		<tr>   <td>0x27</td> <td>PCJ</td> <td>In each phase, it transmits REJECT message.</td> </tr>
+ * </table> 
+ */
+#define Sn_CR(sn)			(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0001)) // channel Sn_CR register
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Socket interrupt register(R)
+ * @details \ref Sn_IR indicates the status of Socket Interrupt such as establishment, termination, receiving data, timeout).\n
+ * When an interrupt occurs and the corresponding bit \ref IR_SOCK(N) in \ref _IMR_ are set, \ref IR_SOCK(N) in \ref IR becomes '1'.\n
+ * In order to clear the \ref Sn_IR bit, the host should write the bit to \n
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>PRECV</td> <td>PFAIL</td> <td>PNEXT</td> <td>SEND_OK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
+ * </table>
+ * - \ref Sn_IR_PRECV : <b>PPP Receive Interrupt</b>
+ * - \ref Sn_IR_PFAIL : <b>PPP Fail Interrupt</b>
+ * - \ref Sn_IR_PNEXT : <b>PPP Next Phase Interrupt</b>
+ * - \ref Sn_IR_SENDOK : <b>SEND_OK Interrupt</b>
+ * - \ref Sn_IR_TIMEOUT : <b>TIMEOUT Interrupt</b>
+ * - \ref Sn_IR_RECV : <b>RECV Interrupt</b>
+ * - \ref Sn_IR_DISCON : <b>DISCON Interrupt</b>
+ * - \ref Sn_IR_CON : <b>CON Interrupt</b>
+ */
+#define Sn_IR(sn)			(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0002)) // channel interrupt register
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Socket status register(R)
+ * @details \ref Sn_SR indicates the status of Socket n.\n
+ * The status of Socket n is changed by \ref Sn_CR or some special control packet as SYN, FIN packet in TCP.
+ * @par Normal status
+ * - \ref SOCK_CLOSED 		: Closed
+ * - \ref SOCK_INIT   		: Initiate state
+ * - \ref SOCK_LISTEN    	: Listen state
+ * - \ref SOCK_ESTABLISHED 	: Success to connect
+ * - \ref SOCK_CLOSE_WAIT   : Closing state
+ * - \ref SOCK_UDP   		: UDP socket
+ * - \ref SOCK_MACRAW  		: MAC raw mode socket
+ *@par Temporary status during changing the status of Socket n.
+ * - \ref SOCK_SYNSENT   	: This indicates Socket n sent the connect-request packet (SYN packet) to a peer.
+ * - \ref SOCK_SYNRECV    	: It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.
+ * - \ref SOCK_FIN_WAIT		: Connection state
+ * - \ref SOCK_CLOSING		: Closing state
+ * - \ref SOCK_TIME_WAIT	: Closing state
+ * - \ref SOCK_LAST_ACK 	: Closing state
+ */
+#define Sn_SR(sn)			(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0003)) // channel status register
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief source port register(R/W)
+ * @details \ref Sn_PORT configures the source port number of Socket n.
+ * It is valid when Socket n is used in TCP/UDP mode. It should be set before OPEN command is ordered.
+*/
+#define Sn_PORT(sn)		(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0004)) // source port register
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Peer MAC register address(R/W)
+ * @details \ref Sn_DHAR configures the destination hardware address of Socket n when using SEND_MAC command in UDP mode or
+ * it indicates that it is acquired in ARP-process by CONNECT/SEND command.
+ */
+#define Sn_DHAR(sn)     (_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0006)) // Peer MAC register address
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Peer IP register address(R/W)
+ * @details \ref Sn_DIPR configures or indicates the destination IP address of Socket n. It is valid when Socket n is used in TCP/UDP mode.
+ * In TCP client mode, it configures an IP address of TCP server before CONNECT command.
+ * In TCP server mode, it indicates an IP address of TCP client after successfully establishing connection.
+ * In UDP mode, it configures an IP address of peer to be received the UDP packet by SEND or SEND_MAC command.
+ */
+#define Sn_DIPR(sn)		(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x000C)) // Peer IP register address
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Peer port register address(R/W)
+ * @details \ref Sn_DPORT configures or indicates the destination port number of Socket n. It is valid when Socket n is used in TCP/UDP mode.
+ * In TCP clientmode, it configures the listen port number of TCP server before CONNECT command.
+ * In TCP Servermode, it indicates the port number of TCP client after successfully establishing connection.
+ * In UDP mode, it configures the port number of peer to be transmitted the UDP packet by SEND/SEND_MAC command.
+ */
+#define Sn_DPORT(sn)    (_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0010)) // Peer port register address
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Maximum Segment Size(Sn_MSSR0) register address(R/W)
+ * @details \ref Sn_MSSR configures or indicates the MTU(Maximum Transfer Unit) of Socket n.
+ */
+#define Sn_MSSR(sn)	   (_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0012)) // Maximum Segment Size(Sn_MSSR0) register address
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief IP Protocol(PROTO) Register(R/W)
+ * @details \ref Sn_PROTO that sets the protocol number field of the IP header at the IP layer. It is
+ * valid only in IPRAW mode, and ignored in other modes.
+ */
+#define Sn_PROTO(sn)	   (_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0014)) // Protocol of IP Header field register in IP raw mode
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief IP Type of Service(TOS) Register(R/W)
+ * @details \ref Sn_TOS configures the TOS(Type Of Service field in IP Header) of Socket n.
+ * It is set before OPEN command.
+ */
+#define Sn_TOS(sn)			(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + 0x0015) // IP Type of Service(TOS) Register 
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief IP Time to live(TTL) Register(R/W)
+ * @details \ref Sn_TTL configures the TTL(Time To Live field in IP header) of Socket n.
+ * It is set before OPEN command.
+ */
+#define Sn_TTL(sn)		(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0016)) // IP Time to live(TTL) Register 
+
+// Reserved					(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0017))
+// Reserved					(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0018))
+// Reserved					(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0019))
+// Reserved					(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001A))
+// Reserved					(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001B))
+// Reserved					(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001C))
+// Reserved					(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001D))
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Transmit free memory size register(R)
+ * @details \ref Sn_TX_FSR indicates the free size of Socket n TX Buffer Block. It is initialized to the configured size by \ref Sn_TXMEM_SIZE.
+ * Data bigger than \ref Sn_TX_FSR should not be saved in the Socket n TX Buffer because the bigger data overwrites the previous saved data not yet sent.
+ * Therefore, check before saving the data to the Socket n TX Buffer, and if data is equal or smaller than its checked size,
+ * transmit the data with SEND/SEND_MAC command after saving the data in Socket n TX buffer. But, if data is bigger than its checked size,
+ * transmit the data after dividing into the checked size and saving in the Socket n TX buffer.
+ */
+#define Sn_TX_FSR(sn)	(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0020)) // Transmit free memory size register
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Transmit memory read pointer register address(R)
+ * @details \ref Sn_TX_RD is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001), it is re-initialized while connecting with TCP.
+ * After its initialization, it is auto-increased by SEND command.
+ * SEND command transmits the saved data from the current \ref Sn_TX_RD to the \ref Sn_TX_WR in the Socket n TX Buffer.
+ * After transmitting the saved data, the SEND command increases the \ref Sn_TX_RD as same as the \ref Sn_TX_WR.
+ * If its increment value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
+ * then the carry bit is ignored and will automatically update with the lower 16bits value.
+ */
+#define Sn_TX_RD(sn)		(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0022)) // Transmit memory read pointer register address
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Transmit memory write pointer register address(R/W)
+ * @details \ref Sn_TX_WR is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001), it is re-initialized while connecting with TCP.\n
+ * It should be read or be updated like as follows.\n
+ * 1. Read the starting address for saving the transmitting data.\n
+ * 2. Save the transmitting data from the starting address of Socket n TX buffer.\n
+ * 3. After saving the transmitting data, update \ref Sn_TX_WR to the increased value as many as transmitting data size.
+ * If the increment value exceeds the maximum value 0xFFFF(greater than 0x10000 and the carry bit occurs),
+ * then the carry bit is ignored and will automatically update with the lower 16bits value.\n
+ * 4. Transmit the saved data in Socket n TX Buffer by using SEND/SEND command
+ */
+#define Sn_TX_WR(sn)		(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0024)) // Transmit memory write pointer register address
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Received data size register(R)
+ * @details \ref Sn_RX_RSR indicates the data size received and saved in Socket n RX Buffer.
+ * \ref Sn_RX_RSR does not exceed the \ref Sn_RXMEM_SIZE and is calculated as the difference between
+ * Socket n RX Write Pointer (\ref Sn_RX_WR)and Socket n RX Read Pointer (\ref Sn_RX_RD)
+ */
+#define Sn_RX_RSR(sn)	(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0026)) // Received data size register
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Read point of Receive memory(R/W)
+ * @details \ref Sn_RX_RD is initialized by OPEN command. Make sure to be read or updated as follows.\n
+ * 1. Read the starting save address of the received data.\n
+ * 2. Read data from the starting address of Socket n RX Buffer.\n
+ * 3. After reading the received data, Update \ref Sn_RX_RD to the increased value as many as the reading size.
+ * If the increment value exceeds the maximum value 0xFFFF, that is, is greater than 0x10000 and the carry bit occurs,
+ * update with the lower 16bits value ignored the carry bit.\n
+ * 4. Order RECV command is for notifying the updated \ref Sn_RX_RD to W5100.
+ */
+#define Sn_RX_RD(sn)		(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0028)) // Read point of Receive memory
+
+/**
+ * @ingroup Socket_register_group_W5100
+ * @brief Write point of Receive memory(R)
+ * @details \ref Sn_RX_WR is initialized by OPEN command and it is auto-increased by the data reception.
+ * If the increased value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
+ * then the carry bit is ignored and will automatically update with the lower 16bits value.
+ */
+#define Sn_RX_WR(sn)		(_W5100_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x002A)) // Write point of Receive memory
+
+
+//----------------------------- W5100 Register values  -----------------------------
+
+/* MODE register values */
+/**
+ * @brief Reset
+ * @details If this bit is  All internal registers will be initialized. It will be automatically cleared as after S/W reset.
+ */
+#define MR_RST				0x80 ///< reset 
+
+
+/**
+ * @brief Ping block
+ * @details 0 : Disable Ping block\n
+ * 1 : Enable Ping block\n
+ * If the bit is  it blocks the response to a ping request.
+ */
+#define MR_PB				0x10 ///< ping block 
+
+/**
+ * @brief Enable PPPoE
+ * @details 0 : DisablePPPoE mode\n
+ * 1 : EnablePPPoE mode\n
+ * If you use ADSL, this bit should be '1'.
+ */
+#define MR_PPPOE			0x08 ///< enable pppoe 
+
+/**
+ * @brief Address Auto-Increment in Indirect Bus Interface
+ * @details 0 : Disable auto-increment \n
+ * 1 : Enable auto-incremente \n
+ * At the Indirect Bus Interface mode, if this bit is set as 1, the address will
+ * be automatically increased by 1 whenever read and write are performed.
+ */
+#define MR_AI				0x02 ///< auto-increment in indirect mode 
+
+/**
+ * @brief Indirect Bus Interface mode
+ * @details 0 : Disable Indirect bus Interface mode \n
+ * 1 : Enable Indirect bus Interface mode \n
+ * If this bit is set as 1, Indirect Bus Interface mode is set.
+ */
+#define MR_IND				0x01 ///< enable indirect mode 
+
+/* IR register values */
+/**
+ * @brief Check IP conflict.
+ * @details Bit is set as when own source IP address is same with the sender IP address in the received ARP request.
+ */
+#define IR_CONFLICT			0x80 ///< check ip confict 
+
+/**
+ * @brief Get the destination unreachable message in UDP sending.
+ * @details When receiving the ICMP (Destination port unreachable) packet, this bit is set as 
+ * When this bit is  Destination Information such as IP address and Port number may be checked with the corresponding @ref UIPR & @ref UPORTR.
+ */
+#define IR_UNREACH			0x40 ///< check destination unreachable
+
+/**
+ * @brief Get the PPPoE close message.
+ * @details When PPPoE is disconnected during PPPoE mode, this bit is set.
+ */
+#define IR_PPPoE			0x20 ///< get the PPPoE close message 
+
+#define IR_SOCK(sn)		(0x01 << sn)	///< check socket interrupt
+
+//----------------------------- W5100S Socket Registers -----------------------------
+#define WIZCHIP_SREG_ADDR(sn, addr) (WIZCHIP_SREG_BLOCK(sn) + (addr))
+//--------------------------- For Backward Compatibility ---------------------------
+
+
+// Sn_MR values 
+/* Sn_MR Default values */
+/**
+ * @brief Unused socket
+ * @details This configures the protocol mode of Socket n.
+ */
+#define Sn_MR_CLOSE			0x00 ///< unused socket 
+
+/**
+ * @brief TCP
+ * @details This configures the protocol mode of Socket n.
+ */
+#define Sn_MR_TCP			0x01 ///< TCP 
+
+/**
+ * @brief UDP
+ * @details This configures the protocol mode of Socket n.
+ */
+#define Sn_MR_UDP       0x02 ///< UDP 
+#define Sn_MR_IPRAW     0x03 ///< IP LAYER RAW SOCK 
+
+/**
+ * @brief MAC LAYER RAW SOCK
+ * @details This configures the protocol mode of Socket n.
+ * @note MACRAW mode should be only used in Socket 0.
+ */
+#define Sn_MR_MACRAW		0x04 ///< MAC LAYER RAW SOCK 
+
+/**
+ * @brief PPPoE
+ * @details This configures the protocol mode of Socket n.
+ * @note PPPoE mode should be only used in Socket 0.
+ */
+#define Sn_MR_PPPoE			0x05 ///< PPPoE
+
+/**
+ * @brief No Delayed Ack(TCP), Multicast flag
+ * @details 0 : Disable No Delayed ACK option\n
+ * 1 : Enable No Delayed ACK option\n
+ * This bit is applied only during TCP mode (P[3:0] = 001).\n
+ * When this bit is  It sends the ACK packet without delay as soon as a Data packet is received from a peer.\n
+ * When this bit is  It sends the ACK packet after waiting for the timeout time configured by \ref _RTR_.
+ */
+#define Sn_MR_ND			0x20 ///< No Delayed Ack(TCP) flag 
+
+/**
+ * @brief Support UDP Multicasting
+ * @details 0 : using IGMP version 2\n
+ * 1 : using IGMP version 1\n
+ * This bit is applied only during UDP mode(P[3:0] = 010 and MULTI = '1')
+ * It configures the version for IGMP messages (Join/Leave/Report).
+ */
+#define Sn_MR_MC			Sn_MR_ND ///< Select IGMP version 1(0) or 2(1) 
+
+/**
+ * @brief MAC filter enable in @ref Sn_MR_MACRAW mode
+ * @details 0 : disable MAC Filtering\n
+ * 1 : enable MAC Filtering\n
+ * This bit is applied only during MACRAW mode(P[3:0] = 100.\n
+ * When set as  W5100 can only receive broadcasting packet or packet sent to itself.
+ * When this bit is  W5100 can receive all packets on Ethernet.
+ * If user wants to implement Hybrid TCP/IP stack,
+ * it is recommended that this bit is set as for reducing host overhead to process the all received packets.
+ */
+#define Sn_MR_MF			0x40 ///< Use MAC filter
+#define Sn_MR_MFEN      Sn_MR_MF
+
+
+/* Sn_MR Default values */
+/**
+ * @brief Support UDP Multicasting
+ * @details 0 : disable Multicasting\n
+ * 1 : enable Multicasting\n
+ * This bit is applied only during UDP mode(P[3:0] = 010).\n
+ * To use multicasting, \ref Sn_DIPR & \ref Sn_DPORT should be respectively configured with the multicast group IP address & port number
+ * before Socket n is opened by OPEN command of \ref Sn_CR.
+ */
+#define Sn_MR_MULTI			0x80 ///< support multicating 
+
+/* Sn_CR values */
+/**
+ * @brief Initialize or open socket
+ * @details Socket n is initialized and opened according to the protocol selected in Sn_MR(P3:P0).
+ * The table below shows the value of \ref Sn_SR corresponding to \ref Sn_MR.\n
+ * <table>
+ *   <tr>  <td>\b Sn_MR (P[3:0])</td> <td>\b Sn_SR</td>            		 </tr>
+ *   <tr>  <td>Sn_MR_CLOSE  (000)</td> <td>--</td>         	   		 </tr>
+ *   <tr>  <td>Sn_MR_TCP  (001)</td> <td>SOCK_INIT (0x13)</td>  		 </tr>
+ *   <tr>  <td>Sn_MR_UDP  (010)</td>  <td>SOCK_UDP (0x22)</td>  		 </tr>
+ *   <tr>  <td>S0_MR_IPRAW  (011)</td>  <td>SOCK_IPRAW (0x32)</td>  </tr>
+ *   <tr>  <td>S0_MR_MACRAW  (100)</td>  <td>SOCK_MACRAW (0x42)</td>  </tr>
+ *   <tr>  <td>S0_MR_PPPoE  (101)</td>  <td>SOCK_PPPoE (0x5F)</td>  </tr>
+ * </table>
+ */
+#define Sn_CR_OPEN			0x01 ///< initialize or open socket 
+
+/**
+ * @brief Wait connection request in TCP mode(Server mode)
+ * @details This is valid only in TCP mode (Sn_MR(P3:P0) = \ref Sn_MR_TCP).//
+ * In this mode, Socket n operates as a 'TCP server' and waits for connection-request (SYN packet) from any 'TCP client'.//
+ * The \ref Sn_SR changes the state from SOCK_INIT to SOCKET_LISTEN.//
+ * When a 'TCP client' connection request is successfully established,
+ * the \ref Sn_SR changes from SOCK_LISTEN to SOCK_ESTABLISHED and the Sn_IR(0) becomes 
+ * But when a 'TCP client' connection request is failed, Sn_IR(3) becomes and the status of \ref Sn_SR changes to SOCK_CLOSED.
+ */
+#define Sn_CR_LISTEN		0x02 ///< wait connection request in tcp mode(Server mode) 
+
+/**
+ * @brief Send connection request in TCP mode(Client mode)
+ * @details  To connect, a connect-request (SYN packet) is sent to <b>TCP server</b>configured by \ref Sn_DIPR & Sn_DPORT(destination address & port).
+ * If the connect-request is successful, the \ref Sn_SR is changed to \ref SOCK_ESTABLISHED and the Sn_IR(0) becomes \n\n
+ * The connect-request fails in the following three cases.\n
+ * 1. When a @b ARPTO occurs (\ref Sn_IR[3] = '1') because destination hardware address is not acquired through the ARP-process.\n
+ * 2. When a @b SYN/ACK packet is not received and @b TCPTO (Sn_IR(3) ='1')\n
+ * 3. When a @b RST packet is received instead of a @b SYN/ACK packet. In these cases, \ref Sn_SR is changed to \ref SOCK_CLOSED.
+ * @note This is valid only in TCP mode and operates when Socket n acts as <b>TCP client</b>
+ */
+#define Sn_CR_CONNECT		0x04 ///< send connection request in tcp mode(Client mode) 
+
+/**
+ * @brief Send closing request in TCP mode
+ * @details Regardless of <b>TCP server</b>or <b>TCP client</b> the DISCON command processes the disconnect-process (<b>Active close</b>or <b>Passive close</b>.\n
+ * @par Active close
+ * it transmits disconnect-request(FIN packet) to the connected peer\n
+ * @par Passive close
+ * When FIN packet is received from peer, a FIN packet is replied back to the peer.\n
+ * @details When the disconnect-process is successful (that is, FIN/ACK packet is received successfully), \ref Sn_SR is changed to \ref SOCK_CLOSED.\n
+ * Otherwise, TCPTO occurs (Sn_IR(3)='1') and then \ref Sn_SR is changed to \ref SOCK_CLOSED.
+ * @note Valid only in TCP mode.
+ */
+#define Sn_CR_DISCON		0x08 ///< send closing reqeuset in tcp mode 
+
+/**
+ * @brief Close socket
+ * @details Sn_SR is changed to \ref SOCK_CLOSED.
+ */
+#define Sn_CR_CLOSE         0x10
+
+/**
+ * @brief Update TX buffer pointer and send data
+ * @details SEND transmits all the data in the Socket n TX buffer.\n
+ * For more details, please refer to Socket n TX Free Size Register (\ref Sn_TX_FSR), Socket n,
+ * TX Write Pointer Register(\ref Sn_TX_WR), and Socket n TX Read Pointer Register(\ref Sn_TX_RD).
+ */
+#define Sn_CR_SEND          0x20
+
+/**
+ * @brief Send data with MAC address, so without ARP process
+ * @details The basic operation is same as SEND.\n
+ * Normally SEND transmits data after destination hardware address is acquired by the automatic ARP-process(Address Resolution Protocol).\n
+ * But SEND_MAC transmits data without the automatic ARP-process.\n
+ * In this case, the destination hardware address is acquired from \ref Sn_DHAR configured by host, instead of APR-process.
+ * @note Valid only in UDP mode.
+ */
+#define Sn_CR_SEND_MAC      0x21
+
+/**
+ * @brief Send keep alive message
+ * @details It checks the connection status by sending 1byte keep-alive packet.\n
+ * If the peer can not respond to the keep-alive packet during timeout time, the connection is terminated and the timeout interrupt will occur.
+ * @note Valid only in TCP mode.
+ */
+#define Sn_CR_SEND_KEEP     0x22
+
+/**
+ * @brief Update RX buffer pointer and receive data
+ * @details RECV completes the processing of the received data in Socket n RX Buffer by using a RX read pointer register (\ref Sn_RX_RD).\n
+ * For more details, refer to Socket n RX Received Size Register (\ref Sn_RX_RSR), Socket n RX Write Pointer Register (\ref Sn_RX_WR),
+ * and Socket n RX Read Pointer Register (\ref Sn_RX_RD).
+ */
+#define Sn_CR_RECV          0x40
+
+/**
+ * @brief PPPoE connection
+ * @details PPPoE connection begins by transmitting PPPoE discovery packet
+ */
+#define Sn_CR_PCON			0x23
+
+/**
+ * @brief Closes PPPoE connection
+ * @details Closes PPPoE connection
+ */		 
+#define Sn_CR_PDISCON		0x24		 
+
+/**
+ * @brief REQ message transmission
+ * @details In each phase, it transmits REQ message.
+ */
+#define Sn_CR_PCR			0x25		 
+
+/**
+ * @brief NAK massage transmission
+ * @details In each phase, it transmits NAK message.
+ */
+#define Sn_CR_PCN			0x26		
+
+/**
+ * @brief REJECT message transmission
+ * @details In each phase, it transmits REJECT message.
+ */
+#define Sn_CR_PCJ			0x27		
+
+/* Sn_IR values */
+/**
+ * @brief PPP Receive Interrupt
+ * @details PPP Receive Interrupts when the option which is not supported is received.
+ */
+#define Sn_IR_PRECV			0x80	
+
+/**
+ * @brief PPP Fail Interrupt
+ * @details PPP Fail Interrupts when PAP Authentication is failed.
+ */	
+#define Sn_IR_PFAIL			0x40		
+
+/**
+ * @brief PPP Next Phase Interrupt
+ * @details PPP Next Phase Interrupts when the phase is changed during ADSL connection process.
+ */
+#define Sn_IR_PNEXT			0x20		
+
+/**
+ * @brief SEND_OK Interrupt
+ * @details This is issued when SEND command is completed.
+ */
+#define Sn_IR_SENDOK		0x10 ///< complete sending 
+
+/**
+ * @brief TIMEOUT Interrupt
+ * @details This is issued when ARPTO or TCPTO occurs.
+ */
+#define Sn_IR_TIMEOUT		0x08 ///< assert timeout 
+
+/**
+ * @brief RECV Interrupt
+ * @details This is issued whenever data is received from a peer.
+ */
+#define Sn_IR_RECV          0x04
+
+/**
+ * @brief DISCON Interrupt
+ * @details This is issued when FIN or FIN/ACK packet is received from a peer.
+ */
+#define Sn_IR_DISCON        0x02
+
+/**
+ * @brief CON Interrupt
+ * @details This is issued one time when the connection with peer is successful and then \ref Sn_SR is changed to \ref SOCK_ESTABLISHED.
+ */
+#define Sn_IR_CON           0x01
+
+/* Sn_SR values */
+/**
+ * @brief Closed
+ * @details This indicates that Socket n is released.\n
+ * When DICON, CLOSE command is ordered, or when a timeout occurs, it is changed to \ref SOCK_CLOSED regardless of previous status.
+ */
+#define SOCK_CLOSED			0x00 ///< closed 
+
+/**
+ * @brief Initiate state
+ * @details This indicates Socket n is opened with TCP mode.\n
+ * It is changed to \ref SOCK_INIT when Sn_MR(P[3:0]) = 001)and OPEN command is ordered.\n
+ * After \ref SOCK_INIT, user can use LISTEN /CONNECT command.
+ */
+#define SOCK_INIT 			0x13 ///< init state 
+
+/**
+ * @brief Listen state
+ * @details This indicates Socket n is operating as <b>TCP server</b>mode and waiting for connection-request (SYN packet) from a peer (<b>TCP client</b>).\n
+ * It will change to \ref SOCK_ESTABLISHED when the connection-request is successfully accepted.\n
+ * Otherwise it will change to \ref SOCK_CLOSED after TCPTO occurred (Sn_IR(TIMEOUT) = '1').
+ */
+#define SOCK_LISTEN         0x14
+
+/**
+ * @brief Connection state
+ * @details This indicates Socket n sent the connect-request packet (SYN packet) to a peer.\n
+ * It is temporarily shown when \ref Sn_SR is changed from \ref SOCK_INIT to \ref SOCK_ESTABLISHED by CONNECT command.\n
+ * If connect-accept(SYN/ACK packet) is received from the peer at SOCK_SYNSENT, it changes to \ref SOCK_ESTABLISHED.\n
+ * Otherwise, it changes to \ref SOCK_CLOSED after TCPTO (\ref Sn_IR[TIMEOUT] = '1') is occurred.
+ */
+#define SOCK_SYNSENT        0x15
+
+/**
+ * @brief Connection state
+ * @details It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.\n
+ * If socket n sends the response (SYN/ACK  packet) to the peer successfully,  it changes to \ref SOCK_ESTABLISHED. \n
+ * If not, it changes to \ref SOCK_CLOSED after timeout occurs (\ref Sn_IR[TIMEOUT] = '1').
+ */
+#define SOCK_SYNRECV        0x16
+
+/**
+ * @brief Success to connect
+ * @details This indicates the status of the connection of Socket n.\n
+ * It changes to \ref SOCK_ESTABLISHED when the <b>TCP SERVER</b>processed the SYN packet from the <b>TCP CLIENT</b>during \ref SOCK_LISTEN, or
+ * when the CONNECT command is successful.\n
+ * During \ref SOCK_ESTABLISHED, DATA packet can be transferred using SEND or RECV command.
+ */
+#define SOCK_ESTABLISHED    0x17
+
+/**
+ * @brief Closing state
+ * @details These indicate Socket n is closing.\n
+ * These are shown in disconnect-process such as active-close and passive-close.\n
+ * When Disconnect-process is successfully completed, or when timeout occurs, these change to \ref SOCK_CLOSED.
+ */
+#define SOCK_FIN_WAIT       0x18
+
+/**
+ * @brief Closing state
+ * @details These indicate Socket n is closing.\n
+ * These are shown in disconnect-process such as active-close and passive-close.\n
+ * When Disconnect-process is successfully completed, or when timeout occurs, these change to \ref SOCK_CLOSED.
+ */
+#define SOCK_CLOSING        0x1A
+
+/**
+ * @brief Closing state
+ * @details These indicate Socket n is closing.\n
+ * These are shown in disconnect-process such as active-close and passive-close.\n
+ * When Disconnect-process is successfully completed, or when timeout occurs, these change to \ref SOCK_CLOSED.
+ */
+#define SOCK_TIME_WAIT      0x1B
+
+/**
+ * @brief Closing state
+ * @details This indicates Socket n received the disconnect-request (FIN packet) from the connected peer.\n
+ * This is half-closing status, and data can be transferred.\n
+ * For full-closing, DISCON command is used. But For just-closing, @ref Sn_CR_CLOSE command is used.
+ */
+#define SOCK_CLOSE_WAIT     0x1C
+
+/**
+ * @brief Closing state
+ * @details This indicates Socket n is waiting for the response (FIN/ACK packet) to the disconnect-request (FIN packet) by passive-close.\n
+ * It changes to \ref SOCK_CLOSED when Socket n received the response successfully, or when timeout occurs  (\ref Sn_IR[TIMEOUT] = '1').
+ */
+#define SOCK_LAST_ACK       0x1D
+
+/**
+ * @brief UDP socket
+ * @details This indicates Socket n is opened in UDP mode(Sn_MR(P[3:0]) = 010).\n
+ * It changes to SOCK_UDP when Sn_MR(P[3:0]) = 010 and @ref Sn_CR_OPEN command is ordered.\n
+ * Unlike TCP mode, data can be transfered without the connection-process.
+ */
+#define SOCK_UDP			0x22 ///< udp socket 
+
+/**
+ * @brief IP raw mode socket
+ * @details TThe socket is opened in IPRAW mode. The SOCKET status is change to SOCK_IPRAW when @ref Sn_MR (P3:P0) is
+ * Sn_MR_IPRAW and @ref Sn_CR_OPEN command is used.\n
+ * IP Packet can be transferred without a connection similar to the UDP mode.
+*/
+#define SOCK_IPRAW			0x32 ///< ip raw mode socket 
+
+/**
+ * @brief MAC raw mode socket
+ * @details This indicates Socket 0 is opened in MACRAW mode (@ref Sn_MR(P[3:0]) = '100' and n=0) and is valid only in Socket 0.\n
+ * It changes to SOCK_MACRAW when @ref Sn_MR(P[3:0]) = '100' and @ref Sn_CR_OPEN command is ordered.\n
+ * Like UDP mode socket, MACRAW mode Socket 0 can transfer a MAC packet (Ethernet frame) without the connection-process.
+ */
+#define SOCK_MACRAW			0x42 ///< mac raw mode socket 
+
+/**
+ * @brief PPPoE mode socket
+ * @details It is the status that SOCKET0 is open as PPPoE mode. It is changed to SOCK_PPPoE in case of S0_CR=OPEN and S0_MR
+ * (P3:P0)=S0_MR_PPPoE.\n
+ * It is temporarily used at the PPPoE
+connection.
+ */
+#define SOCK_PPPOE			0x5F ///< pppoe socket 
+
+// IP PROTOCOL 
+#define IPPROTO_IP			0 ///< Dummy for IP 
+#define IPPROTO_ICMP		   1 ///< Control message protocol 
+#define IPPROTO_IGMP		   2 ///< Internet group management protocol 
+#define IPPROTO_GGP			3 ///< GW^2 (deprecated) 
+#define IPPROTO_TCP			6 ///< TCP 
+#define IPPROTO_PUP			12 ///< PUP 
+#define IPPROTO_UDP			17 ///< UDP 
+#define IPPROTO_IDP			22 ///< XNS idp 
+#define IPPROTO_ND			77 ///< UNOFFICIAL net disk protocol 
+#define IPPROTO_RAW			255 ///< Raw IP packet 
+
+/**
+ * @brief Enter a critical section
+ *
+ * @details It is provided to protect your shared code which are executed without distribution. \n \n
+ *
+ * In non-OS environment, It can be just implemented by disabling whole interrupt.\n
+ * In OS environment, You can replace it to critical section api supported by OS.
+ *
+ * \sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
+ * \sa WIZCHIP_CRITICAL_EXIT()
+ */
+#define WIZCHIP_CRITICAL_ENTER()    WIZCHIP.CRIS._enter()
+
+#ifdef _exit
+#undef _exit
+#endif
+
+/**
+ * @brief Exit a critical section
+ *
+ * @details It is provided to protect your shared code which are executed without distribution. \n\n
+ *
+ * In non-OS environment, It can be just implemented by disabling whole interrupt. \n
+ * In OS environment, You can replace it to critical section api supported by OS.
+ *
+ * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
+ * @sa WIZCHIP_CRITICAL_ENTER()
+ */
+#define WIZCHIP_CRITICAL_EXIT()     WIZCHIP.CRIS._exit()
+
+
+
+////////////////////////
+// Basic I/O Function //
+////////////////////////
+//
+//M20150601 :  uint16_t AddrSel --> uint32_t AddrSel
+//
+/**
+ * @ingroup Basic_IO_function_W5100
+ * @brief It reads 1 byte value from a register.
+ * @param AddrSel Register address
+ * @return The value of register
+ */
+uint8_t  WIZCHIP_READ (uint32_t AddrSel);
+
+/**
+ * @ingroup Basic_IO_function_W5100
+ * @brief It writes 1 byte value to a register.
+ * @param AddrSel Register address
+ * @param wb Write data
+ * @return void
+ */
+void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
+
+/**
+ * @ingroup Basic_IO_function_W5100
+ * @brief It reads sequence data from registers.
+ * @param AddrSel Register address
+ * @param pBuf Pointer buffer to read data
+ * @param len Data length
+ */
+void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
+
+/**
+ * @ingroup Basic_IO_function_W5100
+ * @brief It writes sequence data to registers.
+ * @param AddrSel Register address
+ * @param pBuf Pointer buffer to write data
+ * @param len Data length
+ */
+void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
+
+
+/////////////////////////////////
+// Common Register IO function //
+/////////////////////////////////
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set Mode Register
+ * @param (uint8_t)mr The value to be set.
+ * @sa getMR()
+ */
+#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
+   #define setMR(mr) 	WIZCHIP_WRITE(MR,mr)
+#else
+   #define setMR(mr)    (*((uint8_t*)MR) = mr)
+#endif
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get @ref MR.
+ * @return uint8_t. The value of Mode register.
+ * @sa setMR()
+ */
+#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
+   #define getMR() 		WIZCHIP_READ(MR)
+#else
+   #define getMR()      (*(uint8_t*)MR)
+#endif
+   
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set @ref GAR.
+ * @param (uint8_t*)gar Pointer variable to set gateway IP address. It should be allocated 4 bytes.
+ * @sa getGAR()
+ */
+#define setGAR(gar) \
+		WIZCHIP_WRITE_BUF(GAR,gar,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get @ref GAR.
+ * @param (uint8_t*)gar Pointer variable to get gateway IP address. It should be allocated 4 bytes.
+ * @sa setGAR()
+ */
+#define getGAR(gar) \
+		WIZCHIP_READ_BUF(GAR,gar,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set @ref SUBR.
+ * @param (uint8_t*)subr Pointer variable to set subnet mask address. It should be allocated 4 bytes.
+ * @note If subr is null pointer, set the backup subnet to SUBR. \n
+ *       If subr is 0.0.0.0, back up SUBR and clear it. \n
+ *       Otherwize, set subr to SUBR
+ * @sa getSUBR()
+ */
+#define setSUBR(subr) \
+      WIZCHIP_WRITE_BUF(SUBR,subr,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get @ref SUBR.
+ * @param (uint8_t*)subr Pointer variable to get subnet mask address. It should be allocated 4 bytes.
+ * @sa setSUBR()
+ */
+#define getSUBR(subr) \
+		WIZCHIP_READ_BUF(SUBR, subr, 4)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set @ref SHAR.
+ * @param (uint8_t*)shar Pointer variable to set local MAC address. It should be allocated 6 bytes.
+ * @sa getSHAR()
+ */
+#define setSHAR(shar) \
+		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get @ref SHAR.
+ * @param (uint8_t*)shar Pointer variable to get local MAC address. It should be allocated 6 bytes.
+ * @sa setSHAR()
+ */
+#define getSHAR(shar) \
+		WIZCHIP_READ_BUF(SHAR, shar, 6)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set @ref SIPR.
+ * @param (uint8_t*)sipr Pointer variable to set local IP address. It should be allocated 4 bytes.
+ * @sa getSIPR()
+*/
+#define setSIPR(sipr) \
+		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get @ref SIPR.
+ * @param (uint8_t*)sipr Pointer variable to get local IP address. It should be allocated 4 bytes.
+ * @sa setSIPR()
+ */
+#define getSIPR(sipr) \
+		WIZCHIP_READ_BUF(SIPR, sipr, 4)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set \ref IR register
+ * @param (uint8_t)ir Value to set \ref IR register.
+ * @sa getIR()
+ */
+#define setIR(ir) \
+		WIZCHIP_WRITE(IR, (ir & 0xA0))
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref IR register
+ * @return uint8_t. Value of \ref IR register.
+ * @sa setIR()
+ */
+#define getIR() \
+		(WIZCHIP_READ(IR) & 0xA0)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set \ref _IMR_ register
+ * @param (uint8_t)imr Value to set @ref _IMR_ register.
+ * @sa getIMR()
+ */
+#define setIMR(imr) \
+		WIZCHIP_WRITE(_IMR_, imr)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref _IMR_ register
+ * @return uint8_t. Value of @ref _IMR_ register.
+ * @sa setIMR()
+ */
+#define getIMR() \
+		WIZCHIP_READ(_IMR_)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set \ref _RTR_ register
+ * @param (uint16_t)rtr Value to set @ref _RTR_ register.
+ * @sa getRTR()
+ */
+#define setRTR(rtr)   {\
+		WIZCHIP_WRITE(_RTR_,   (uint8_t)(rtr >> 8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1), (uint8_t) rtr); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref _RTR_ register
+ * @return uint16_t. Value of @ref _RTR_ register.
+ * @sa setRTR()
+ */
+#define getRTR() \
+		(((uint16_t)WIZCHIP_READ(_RTR_) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set \ref _RCR_ register
+ * @param (uint8_t)rcr Value to set @ref _RCR_ register.
+ * @sa getRCR()
+ */
+#define setRCR(rcr) \
+		WIZCHIP_WRITE(_RCR_, rcr)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref _RCR_ register
+ * @return uint8_t. Value of @ref _RCR_ register.
+ * @sa setRCR()
+ */
+#define getRCR() \
+		WIZCHIP_READ(_RCR_)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref RMSR register
+ * @sa getRMSR()
+ */
+#define setRMSR(rmsr)   \
+      WIZCHIP_WRITE(RMSR) // Receicve Memory Size
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref RMSR register
+ * @return uint8_t. Value of @ref RMSR register.
+ * @sa setRMSR()
+ */
+ #define getRMSR()   \
+      WIZCHIP_READ() // Receicve Memory Size
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref TMSR register
+ * @sa getTMSR()
+ */
+#define setTMSR(rmsr)   \
+      WIZCHIP_WRITE(TMSR) // Receicve Memory Size
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref TMSR register
+ * @return uint8_t. Value of @ref TMSR register.
+ * @sa setTMSR()
+ */
+
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref PATR register
+ * @return uint16_t. Value to set \ref PATR register
+ */
+#define getPATR() \
+		(((uint16_t)WIZCHIP_READ(PATR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PATR,1)))
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref PPPALGO register
+ * @return uint8_t. Value to set \ref PPPALGO register
+ */
+#define getPPPALGO() \
+		WIZCHIP_READ(PPPALGO)
+
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set \ref PTIMER register
+ * @param (uint8_t)ptimer Value to set \ref PTIMER register.
+ * @sa getPTIMER()
+ */
+#define setPTIMER(ptimer) \
+		WIZCHIP_WRITE(PTIMER, ptimer)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref PTIMER register
+ * @return uint8_t. Value of @ref PTIMER register.
+ * @sa setPTIMER()
+ */
+#define getPTIMER() \
+		WIZCHIP_READ(PTIMER)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Set \ref PMAGIC register
+ * @param (uint8_t)pmagic Value to set @ref PMAGIC register.
+ * @sa getPMAGIC()
+ */
+#define setPMAGIC(pmagic) \
+		WIZCHIP_WRITE(PMAGIC, pmagic)
+
+/**
+ * @ingroup Common_register_access_function_W5100
+ * @brief Get \ref PMAGIC register
+ * @return uint8_t. Value of @ref PMAGIC register.
+ * @sa setPMAGIC()
+ */
+#define getPMAGIC() \
+		WIZCHIP_READ(PMAGIC)
+
+///////////////////////////////////
+// Socket N register I/O function //
+///////////////////////////////////
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_MR register
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ * @param mr Value to set @ref Sn_MR
+ * @sa getSn_MR()
+ */
+#define setSn_MR(sn, mr) \
+		WIZCHIP_WRITE(Sn_MR(sn),mr)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_MR register
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ * @return Value of @ref Sn_MR.
+ * @sa setSn_MR()
+ */
+#define getSn_MR(sn) \
+	WIZCHIP_READ(Sn_MR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_CR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)cr Value to set @ref Sn_CR
+ * @sa getSn_CR()
+ */
+#define setSn_CR(sn, cr) \
+		WIZCHIP_WRITE(Sn_CR(sn), cr)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_CR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_CR.
+ * @sa setSn_CR()
+ */
+#define getSn_CR(sn) \
+		WIZCHIP_READ(Sn_CR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_IR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)ir Value to set @ref Sn_IR
+ * @sa getSn_IR()
+ */
+#define setSn_IR(sn, ir) \
+		WIZCHIP_WRITE(Sn_IR(sn), ir)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_IR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_IR.
+ * @sa setSn_IR()
+ */
+#define getSn_IR(sn) \
+		WIZCHIP_READ(Sn_IR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_SR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_SR.
+ */
+#define getSn_SR(sn) \
+		WIZCHIP_READ(Sn_SR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_PORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)port Value to set @ref Sn_PORT.
+ * @sa getSn_PORT()
+ */
+#define setSn_PORT(sn, port)  { \
+		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_PORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_PORT.
+ * @sa setSn_PORT()
+ */
+#define getSn_PORT(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_DHAR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dhar Pointer variable to set socket n destination hardware address. It should be allocated 6 bytes.
+ * @sa getSn_DHAR()
+ */
+#define setSn_DHAR(sn, dhar) \
+		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_DHAR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dhar Pointer variable to get socket n destination hardware address. It should be allocated 6 bytes.
+ * @sa setSn_DHAR()
+ */
+#define getSn_DHAR(sn, dhar) \
+		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_DIPR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dipr Pointer variable to set socket n destination IP address. It should be allocated 4 bytes.
+ * @sa getSn_DIPR()
+ */
+#define setSn_DIPR(sn, dipr) \
+		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_DIPR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dipr Pointer variable to get socket n destination IP address. It should be allocated 4 bytes.
+ * @sa SetSn_DIPR()
+ */
+#define getSn_DIPR(sn, dipr) \
+		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_DPORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)dport Value to set @ref Sn_DPORT
+ * @sa getSn_DPORT()
+ */
+#define setSn_DPORT(sn, dport) { \
+		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_DPORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_DPORT.
+ * @sa setSn_DPORT()
+ */
+#define getSn_DPORT(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_MSSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)mss Value to set @ref Sn_MSSR
+ * @sa setSn_MSSR()
+ */
+#define setSn_MSSR(sn, mss) { \
+		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_MSSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_MSSR.
+ * @sa setSn_MSSR()
+ */
+#define getSn_MSSR(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_PROTO register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)proto Value to set \ref Sn_PROTO
+ * @sa getSn_PROTO()
+ */
+#define setSn_PROTO(sn, proto) \
+		WIZCHIP_WRITE(Sn_TOS(sn), tos)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_PROTO register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_PROTO.
+ * @sa setSn_PROTO()
+ */
+#define getSn_PROTO(sn) \
+		WIZCHIP_READ(Sn_TOS(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_TOS register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)tos Value to set @ref Sn_TOS
+ * @sa getSn_TOS()
+ */
+#define setSn_TOS(sn, tos) \
+		WIZCHIP_WRITE(Sn_TOS(sn), tos)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_TOS register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @return uint8_t. Value of Sn_TOS.
+ * @sa setSn_TOS()
+ */
+#define getSn_TOS(sn) \
+		WIZCHIP_READ(Sn_TOS(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_TTL register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @param (uint8_t)ttl Value to set @ref Sn_TTL
+ * @sa getSn_TTL()
+ */
+#define setSn_TTL(sn, ttl) \
+		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_TTL register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @return uint8_t. Value of @ref Sn_TTL.
+ * @sa setSn_TTL()
+ */
+#define getSn_TTL(sn) \
+		WIZCHIP_READ(Sn_TTL(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_RXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @param (uint8_t)rxmemsize Value to set \ref Sn_RXMEM_SIZE
+ * @sa getSn_RXMEM_SIZE()
+ */
+#define  setSn_RXMEM_SIZE(sn, rxmemsize) \
+      WIZCHIP_WRITE(RMSR, (WIZCHIP_READ(RMSR) & ~(0x03 << (2*sn))) | (rxmemsize << (2*sn)))
+#define  setSn_RXBUF_SIZE(sn,rxmemsize) setSn_RXMEM_SIZE(sn,rxmemsize)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_RXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_RXMEM.
+ * @sa setSn_RXMEM_SIZE()
+ */
+#define  getSn_RXMEM_SIZE(sn) \
+      ((WIZCHIP_READ(RMSR) & (0x03 << (2*sn))) >> (2*sn))
+#define  getSn_RXBUF_SIZE(sn) getSn_RXMEM_SIZE(sn)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_TXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)txmemsize Value to set \ref Sn_TXMEM_SIZE
+ * @sa getSn_TXMEM_SIZE()
+ */
+#define setSn_TXMEM_SIZE(sn, txmemsize) \
+      WIZCHIP_WRITE(TMSR, (WIZCHIP_READ(TMSR) & ~(0x03 << (2*sn))) | (txmemsize << (2*sn)))
+#define  setSn_TXBUF_SIZE(sn, txmemsize) setSn_TXMEM_SIZE(sn,txmemsize)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_TXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_TXMEM_SIZE.
+ * @sa setSn_TXMEM_SIZE()
+ */
+#define  getSn_TXMEM_SIZE(sn) \
+      ((WIZCHIP_READ(TMSR) & (0x03 << (2*sn))) >> (2*sn))
+#define  getSn_TXBUF_SIZE(sn) getSn_TXMEM_SIZE(sn)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_TX_FSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_TX_FSR.
+ */
+uint16_t getSn_TX_FSR(uint8_t sn);
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_TX_RD register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_TX_RD.
+ */
+#define getSn_TX_RD(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_TX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)txwr Value to set @ref Sn_TX_WR
+ * @sa GetSn_TX_WR()
+ */
+#define setSn_TX_WR(sn, txwr) { \
+		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); \
+		}
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_TX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_TX_WR.
+ * @sa setSn_TX_WR()
+ */
+#define getSn_TX_WR(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_RX_RSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_RX_RSR.
+ */
+uint16_t getSn_RX_RSR(uint8_t sn);
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_RX_RD register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)rxrd Value to set @ref Sn_RX_RD
+ * @sa getSn_RX_RD()
+ */
+#define setSn_RX_RD(sn, rxrd) { \
+		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_RX_RD register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @regurn uint16_t. Value of @ref Sn_RX_RD.
+ * @sa setSn_RX_RD()
+ */
+#define getSn_RX_RD(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_RX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)rxwr Value to set \ref Sn_RX_WR
+ * @sa getSn_RX_WR()
+ */
+#define setSn_RX_WR(sn, rxwr) { \
+		WIZCHIP_WRITE(Sn_RX_WR(sn),   (uint8_t)(rxwr>>8)); \
+	   WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1), (uint8_t) rxwr); \
+	}
+
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_RX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_RX_WR.
+ */
+#define getSn_RX_WR(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Set @ref Sn_FRAG register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)frag Value to set \ref Sn_FRAG
+ * @sa getSn_FRAG()
+ */
+#define setSn_FRAG(sn, frag) { \
+		WIZCHIP_WRITE(Sn_FRAG(sn),  (uint8_t)(frag >>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1), (uint8_t) frag); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get @ref Sn_FRAG register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_FRAG.
+ * @sa setSn_FRAG()
+ */
+#define getSn_FRAG(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_FRAG(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAG(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get the max RX buffer size of socket sn
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Max buffer size
+ */
+#define getSn_RxMAX(sn) \
+		((uint16_t)(1 << getSn_RXMEM_SIZE(sn)) << 10)
+
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get the max TX buffer size of socket sn
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Max buffer size
+ */
+#define getSn_TxMAX(sn) \
+		((uint16_t)(1 << getSn_TXMEM_SIZE(sn)) << 10)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get the mask of socket sn RX buffer.
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Mask value
+ */
+#define getSn_RxMASK(sn) \
+		(getSn_RxMAX(sn) - 1)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get the mask of socket sn TX buffer
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Mask value
+ */
+#define getSn_TxMASK(sn) \
+		(getSn_TxMAX(sn) - 1)
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get the base address of socket sn RX buffer.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of Socket n RX buffer base address.
+ */
+uint32_t getSn_RxBASE(uint8_t sn);
+
+/**
+ * @ingroup Socket_register_access_function_W5100
+ * @brief Get the base address of socket sn TX buffer.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of Socket n TX buffer base address.
+ */
+uint32_t getSn_TxBASE(uint8_t sn);
+
+/////////////////////////////////////
+// Sn_TXBUF & Sn_RXBUF IO function //
+/////////////////////////////////////
+/**
+ * @ingroup Basic_IO_function_W5100
+ * @brief It copies data to internal TX memory
+ *
+ * @details This function reads the Tx write pointer register and after that,
+ * it copies the <i>wizdata(pointer buffer)</i> of the length of <i>len(variable)</i> bytes to internal TX memory
+ * and updates the Tx write pointer register.
+ * This function is being called by send() and sendto() function also.
+ *
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param wizdata Pointer buffer to write data
+ * @param len Data length
+ * @sa wiz_recv_data()
+ */
+void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
+
+/**
+ * @ingroup Basic_IO_function_W5100
+ * @brief It copies data to your buffer from internal RX memory
+ *
+ * @details This function read the Rx read pointer register and after that,
+ * it copies the received data from internal RX memory
+ * to <i>wizdata(pointer variable)</i> of the length of <i>len(variable)</i> bytes.
+ * This function is being called by recv() also.
+ *
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param wizdata Pointer buffer to read data
+ * @param len Data length
+ * @sa wiz_send_data()
+ */
+void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
+
+/**
+ * @ingroup Basic_IO_function_W5100
+ * @brief It discard the received data in RX memory.
+ * @details It discards the data of the length of <i>len(variable)</i> bytes in internal RX memory.
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param len Data length
+ */
+void wiz_recv_ignore(uint8_t sn, uint16_t len);
+
+/// @cond DOXY_APPLY_CODE
+#endif
+/// @endcond
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //_W5100_H_
+
+
+
diff --git a/drivers/wiznet5k/ethernet/w5105/w5105.c b/drivers/wiznet5k/ethernet/w5105/w5105.c
new file mode 100644
index 000000000..49a56ae56
--- /dev/null
+++ b/drivers/wiznet5k/ethernet/w5105/w5105.c
@@ -0,0 +1,485 @@
+//*****************************************************************************
+//
+//! \file w5100S.c
+//! \brief W5100S HAL Interface.
+//! \version 1.0.0
+//! \date 2018/03/29
+//! \par  Revision history
+//!       <2018/03/29> 1st Release
+//! \author Peter
+//! 
+//! Copyright (c)  2013, WIZnet Co., LTD.
+//! All rights reserved.
+//! 
+//! Redistribution and use in source and binary forms, with or without 
+//! modification, are permitted provided that the following conditions 
+//! are met: 
+//! 
+//!     * Redistributions of source code must retain the above copyright 
+//! notice, this list of conditions and the following disclaimer. 
+//!     * Redistributions in binary form must reproduce the above copyright
+//! notice, this list of conditions and the following disclaimer in the
+//! documentation and/or other materials provided with the distribution. 
+//!     * Neither the name of the <ORGANIZATION> nor the names of its 
+//! contributors may be used to endorse or promote products derived 
+//! from this software without specific prior written permission. 
+//! 
+//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
+//! THE POSSIBILITY OF SUCH DAMAGE.
+//
+//*****************************************************************************
+
+#include "w5105.h"
+
+////////////////////////////////////////////////////
+
+#define LPC_SSP0 (0)
+static void Chip_SSP_ReadFrames_Blocking(int dummy, uint8_t *buf, uint32_t len) {
+    WIZCHIP.IF.SPI._read_bytes(buf, len);
+}
+
+static void Chip_SSP_WriteFrames_Blocking(int dummy, uint8_t *buf, uint32_t len) {
+    WIZCHIP.IF.SPI._write_bytes(buf, len);
+}
+
+
+/**
+@brief  This function writes the data into W5100S registers.
+*/
+void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
+{ 
+   uint8_t spi_data[4];
+
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();
+
+#if( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_))
+      spi_data[0] = 0xF0;
+		spi_data[1] = (AddrSel & 0xFF00) >>  8;
+		spi_data[2] = (AddrSel & 0x00FF) >>  0;
+		spi_data[3] = wb;
+		Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 4);
+      //WIZCHIP.IF.SPI._write_byte(spi_data, 4);
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_5500_) )
+   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
+   {
+	   WIZCHIP.IF.SPI._write_byte((AddrSel & 0xFF00) >>  8);
+	   WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF) >>  0);
+	   WIZCHIP.IF.SPI._write_byte(0xF0);
+	   WIZCHIP.IF.SPI._write_byte(wb);    // Data write (write 1byte data)
+   }
+   else     // burst operation
+   {
+      spi_data[0] = (AddrSel & 0xFF00) >>  8;
+		spi_data[1] = (AddrSel & 0x00FF) >>  0;
+		spi_data[2] = 0xF0;
+		spi_data[3] = wb;
+		WIZCHIP.IF.SPI._write_burst(spi_data, 4);
+
+   }
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+
+   //add indirect bus 
+   //M20150601 : Rename the function for integrating with ioLibrary
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));	
+   //WIZCHIP.IF.BUS._write_byte(IDM_DR,wb);
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));	
+   WIZCHIP.IF.BUS._write_data(IDM_DR,wb);
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100. !!!"
+#endif
+
+   WIZCHIP.CS._deselect();
+   WIZCHIP_CRITICAL_EXIT();
+}
+/**
+@brief  This function reads the value from W5100S registers.
+*/
+uint8_t  WIZCHIP_READ(uint32_t AddrSel)
+{
+   uint8_t ret;
+   uint8_t spi_data[3];
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();
+
+#if( (_WIZCHIP_IO_MODE_ ==  _WIZCHIP_IO_MODE_SPI_))
+      spi_data[0] = 0x0F;
+      spi_data[1] = (AddrSel & 0xFF00) >>  8;
+      spi_data[2] = (AddrSel & 0x00FF) >>  0;
+      //WIZCHIP.IF.SPI._write_byte(spi_data, 3);
+      //WIZCHIP.IF.SPI._read_byte(&ret, 1);
+      Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
+      Chip_SSP_ReadFrames_Blocking(LPC_SSP0, &ret, 1);
+    
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_5500_) )
+   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// burst operation
+	{
+        WIZCHIP.IF.SPI._write_byte((AddrSel & 0xFF00) >>  8);
+        WIZCHIP.IF.SPI._write_byte((AddrSel & 0x00FF) >>  0);
+        WIZCHIP.IF.SPI._write_byte(0x0F);
+   }
+   else
+   {
+		spi_data[0] = (AddrSel & 0xFF00) >>  8;
+		spi_data[1] = (AddrSel & 0x00FF) >>  0;
+		spi_data[2] = 0x0F
+		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
+   }
+   ret = WIZCHIP.IF.SPI._read_byte();
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+
+   //add indirect bus
+   //M20150601 : Rename the function for integrating with ioLibrary
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   //WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));	
+   //ret = WIZCHIP.IF.BUS._read_byte(IDM_DR);
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));
+   ret = WIZCHIP.IF.BUS._read_data(IDM_DR);
+
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100S. !!!"   
+#endif
+
+   WIZCHIP.CS._deselect();
+   WIZCHIP_CRITICAL_EXIT();
+   return ret;
+}
+
+
+/**
+@brief  This function writes into W5100S memory(Buffer)
+*/ 
+void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
+{
+   uint8_t spi_data[3];
+   uint16_t i = 0;
+
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();   //M20150601 : Moved here.
+
+#if((_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_))
+		spi_data[0] = 0xF0;
+		spi_data[1] = (((uint16_t)(AddrSel+i)) & 0xFF00) >>  8;
+		spi_data[2] = (((uint16_t)(AddrSel+i)) & 0x00FF) >>  0;
+		Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
+      Chip_SSP_WriteFrames_Blocking(LPC_SSP0, pBuf, len);
+      //WIZCHIP.IF.SPI._write_byte(spi_data, 3);
+      //WIZCHIP.IF.SPI._write_byte(pBuf, len);
+
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_5500_) )
+   if(!WIZCHIP.IF.SPI._write_burst) 	// byte operation
+   {
+      WIZCHIP.IF.SPI._write_byte((((uint16_t)(AddrSel+i)) & 0xFF00) >>  8);
+      WIZCHIP.IF.SPI._write_byte((((uint16_t)(AddrSel+i)) & 0x00FF) >>  0);
+      WIZCHIP.IF.SPI._write_byte(0xF0);
+
+      for(i = 0; i < len; i++)
+      {
+         WIZCHIP.IF.SPI._write_byte(pBuf[i]);    // Data write (write 1byte data)
+      }
+   }
+   else     // burst operation
+   {
+		spi_data[0] = (((uint16_t)(AddrSel+i)) & 0xFF00) >>  8;
+		spi_data[1] = (((uint16_t)(AddrSel+i)) & 0x00FF) >>  0;
+      spi_data[2] = 0xF0;
+		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
+		WIZCHIP.IF.SPI._write_burst(pBuf, len);
+   }
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+   //M20150601 : Rename the function for integrating with ioLibrary  
+   /*
+   WIZCHIP_WRITE(MR,WIZCHIP_READ(MR) | MR_AI);     
+   WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));
+   for(i = 0 ; i < len; i++)
+      WIZCHIP.IF.BUS._write_byte(IDM_DR,pBuf[i]);
+   WIZCHIP_WRITE(MR, WIZCHIP_READ(MR) & ~MR_AI);   
+   */
+   setMR(getMR()|MR_AI);     
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));
+   for(i = 0 ; i < len; i++)
+      WIZCHIP.IF.BUS._write_data(IDM_DR,pBuf[i]);
+   setMR(getMR() & ~MR_AI);   
+
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100S. !!!!"
+#endif
+   
+   WIZCHIP.CS._deselect();  //M20150601 : Moved here.
+   WIZCHIP_CRITICAL_EXIT();
+}
+
+/**
+@brief  This function reads into W5100S memory(Buffer)
+*/ 
+
+void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len)
+{
+   uint8_t spi_data[3];
+   uint16_t i = 0;
+   WIZCHIP_CRITICAL_ENTER();
+   WIZCHIP.CS._select();   //M20150601 : Moved here.
+   
+#if( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_) )
+		spi_data[0] = 0x0F;
+		spi_data[1] = (uint16_t)((AddrSel+i) & 0xFF00) >>  8;
+		spi_data[2] = (uint16_t)((AddrSel+i) & 0x00FF) >>  0;
+		Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
+      Chip_SSP_ReadFrames_Blocking(LPC_SSP0, pBuf, len);
+      //WIZCHIP.IF.SPI._write_byte(spi_data, 3);
+      //WIZCHIP.IF.SPI._read_byte(pBuf, len);
+
+
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_5500_) )
+   if(!WIZCHIP.IF.SPI._read_burst || !WIZCHIP.IF.SPI._write_burst) 	// byte operation
+   {
+      WIZCHIP.IF.SPI._write_byte((uint16_t)((AddrSel+i) & 0xFF00) >>  8);
+      WIZCHIP.IF.SPI._write_byte((uint16_t)((AddrSel+i) & 0x00FF) >>  0);
+      WIZCHIP.IF.SPI._write_byte(0x0F);
+   
+      for(i = 0; i < len; i++)
+      {
+         pBuf[i] = WIZCHIP.IF.SPI._read_byte();
+      }
+   }
+   else																// burst operation
+   {
+		spi_data[0] = (uint16_t)((AddrSel+i) & 0xFF00) >>  8;
+		spi_data[1] = (uint16_t)((AddrSel+i) & 0x00FF) >>  0;
+      spi_data[2] = 0x0F;
+		WIZCHIP.IF.SPI._write_burst(spi_data, 3);
+		WIZCHIP.IF.SPI._read_burst(pBuf, len);
+   }
+
+
+#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
+   //M20150601 : Rename the function for integrating with ioLibrary  
+   /*
+   WIZCHIP_WRITE(MR, WIZCHIP_READ(MR) | MR_AI);    
+   WIZCHIP.IF.BUS._write_byte(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_byte(IDM_AR1,(AddrSel & 0x00FF));	
+   for(i = 0 ; i < len; i++)
+      pBuf[i]	= WIZCHIP.IF.BUS._read_byte(IDM_DR);
+   WIZCHIP_WRITE(MR, WIZCHIP_READ(MR) & ~MR_AI); 
+   */
+   setMR(getMR() | MR_AI);
+   WIZCHIP.IF.BUS._write_data(IDM_AR0,(AddrSel & 0xFF00) >>  8);
+   WIZCHIP.IF.BUS._write_data(IDM_AR1,(AddrSel & 0x00FF));	
+   for(i = 0 ; i < len; i++)
+      pBuf[i]	= WIZCHIP.IF.BUS._read_data(IDM_DR);
+   setMR(getMR() & ~MR_AI); 
+   
+#else
+   #error "Unknown _WIZCHIP_IO_MODE_ in W5100S. !!!!"
+#endif
+
+   WIZCHIP.CS._deselect();    //M20150601 : Moved Here.
+   WIZCHIP_CRITICAL_EXIT();
+}
+
+///////////////////////////////////
+// Socket N regsiter IO function //
+///////////////////////////////////
+
+uint16_t getSn_TX_FSR(uint8_t sn)
+{
+   uint16_t val=0,val1=0;
+   do
+   {
+      val1 = WIZCHIP_READ(Sn_TX_FSR(sn));
+      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
+      if (val1 != 0)
+      {
+        val = WIZCHIP_READ(Sn_TX_FSR(sn));
+        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_FSR(sn),1));
+      }
+   }while (val != val1);
+   return val;
+}
+
+
+uint16_t getSn_RX_RSR(uint8_t sn)
+{
+   uint16_t val=0,val1=0;
+   do
+   {
+      val1 = WIZCHIP_READ(Sn_RX_RSR(sn));
+      val1 = (val1 << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
+      if (val1 != 0)
+      {
+        val = WIZCHIP_READ(Sn_RX_RSR(sn));
+        val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RSR(sn),1));
+      }
+   }while (val != val1);
+   return val;
+}
+
+/////////////////////////////////////
+// Sn_TXBUF & Sn_RXBUF IO function //
+/////////////////////////////////////
+uint32_t getSn_RxBASE(uint8_t sn)
+{
+   int8_t  i;
+#if ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
+   uint32_t rxbase = _W5100S_IO_BASE_ + _WIZCHIP_IO_RXBUF_;
+#else   
+   uint32_t rxbase = _WIZCHIP_IO_RXBUF_;
+#endif   
+   for(i = 0; i < sn; i++)
+      rxbase += getSn_RxMAX(i);
+
+   return rxbase;
+}
+
+uint32_t getSn_TxBASE(uint8_t sn)
+{
+   int8_t  i;
+#if ( _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
+   uint32_t txbase = _W5100S_IO_BASE_ + _WIZCHIP_IO_TXBUF_;
+#else   
+   uint32_t txbase = _WIZCHIP_IO_TXBUF_;
+#endif   
+   for(i = 0; i < sn; i++)
+      txbase += getSn_TxMAX(i);
+   return txbase;
+}
+
+/**
+@brief  This function is being called by send() and sendto() function also. for copy the data form application buffer to Transmite buffer of the chip.
+
+This function read the Tx write pointer register and after copy the data in buffer update the Tx write pointer
+register. User should read upper byte first and lower byte later to get proper value.
+And this function is being used for copy the data form application buffer to Transmite
+buffer of the chip. It calculate the actual physical address where one has to write
+the data in transmite buffer. Here also take care of the condition while it exceed
+the Tx memory uper-bound of socket.
+
+*/
+void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
+{
+  uint16_t ptr;
+  uint16_t size;
+  uint16_t dst_mask;
+  uint16_t dst_ptr;
+
+  ptr = getSn_TX_WR(sn);
+
+  dst_mask = ptr & getSn_TxMASK(sn);
+  dst_ptr = getSn_TxBASE(sn) + dst_mask;
+  
+  if (dst_mask + len > getSn_TxMAX(sn)) 
+  {
+    size = getSn_TxMAX(sn) - dst_mask;
+    WIZCHIP_WRITE_BUF(dst_ptr, wizdata, size);
+    wizdata += size;
+    size = len - size;
+    dst_ptr = getSn_TxBASE(sn);
+    WIZCHIP_WRITE_BUF(dst_ptr, wizdata, size);
+  } 
+  else
+  {
+    WIZCHIP_WRITE_BUF(dst_ptr, wizdata, len);
+  }
+
+  ptr += len;
+
+  setSn_TX_WR(sn, ptr);  
+}
+
+
+/**
+@brief  This function is being called by recv() also. This function is being used for copy the data form Receive buffer of the chip to application buffer.
+
+This function read the Rx read pointer register
+and after copy the data from receive buffer update the Rx write pointer register.
+User should read upper byte first and lower byte later to get proper value.
+It calculate the actual physical address where one has to read
+the data from Receive buffer. Here also take care of the condition while it exceed
+the Rx memory uper-bound of socket.
+*/
+void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len)
+{
+  uint16_t ptr;
+  uint16_t size;
+  uint16_t src_mask;
+  uint16_t src_ptr;
+
+  ptr = getSn_RX_RD(sn);
+  
+  src_mask = (uint32_t)ptr & getSn_RxMASK(sn);
+  src_ptr = (getSn_RxBASE(sn) + src_mask);
+
+  
+  if( (src_mask + len) > getSn_RxMAX(sn) ) 
+  {
+    size = getSn_RxMAX(sn) - src_mask;
+    WIZCHIP_READ_BUF((uint32_t)src_ptr, (uint8_t*)wizdata, size);
+    wizdata += size;
+    size = len - size;
+	src_ptr = getSn_RxBASE(sn);
+    WIZCHIP_READ_BUF(src_ptr, (uint8_t*)wizdata, size);
+  } 
+  else
+  {
+    WIZCHIP_READ_BUF(src_ptr, (uint8_t*)wizdata, len);
+  }
+    
+  ptr += len;
+  
+  setSn_RX_RD(sn, ptr);
+}
+
+void wiz_recv_ignore(uint8_t sn, uint16_t len)
+{
+  uint16_t ptr;
+
+  ptr = getSn_RX_RD(sn);
+  
+  ptr += len;
+  setSn_RX_RD(sn,ptr);
+}
+
+void wiz_mdio_write(uint8_t PHYMDIO_regadr, uint16_t var)
+{
+    WIZCHIP_WRITE(PHYRAR,PHYMDIO_regadr);
+    WIZCHIP_WRITE(PHYDIR, (uint8_t)(var >> 8));
+    WIZCHIP_WRITE(PHYDIR+1, (uint8_t)(var));
+    WIZCHIP_WRITE(PHYACR, PHYACR_WRITE);
+    while(WIZCHIP_READ(PHYACR));  //wait for command complete
+}
+
+uint16_t wiz_mdio_read(uint8_t PHYMDIO_regadr)
+{
+    WIZCHIP_WRITE(PHYRAR,PHYMDIO_regadr);
+    WIZCHIP_WRITE(PHYACR, PHYACR_READ);
+    while(WIZCHIP_READ(PHYACR));  //wait for command complete
+    return ((uint16_t)WIZCHIP_READ(PHYDOR) << 8) | WIZCHIP_READ(PHYDOR+1);
+}
+
+void wiz_delay_ms(uint32_t milliseconds)
+{
+	uint32_t i;
+	for(i = 0 ; i < milliseconds ; i++)
+	{
+		//Write any values to clear the TCNTCLKR register
+		setTCNTCLKR(0xff);
+
+		// Wait until counter register value reaches 10.(10 = 1ms : TCNTR is 100us tick counter register)
+		while(getTCNTR() < 0x0a){}
+	}
+}
+
diff --git a/drivers/wiznet5k/ethernet/w5105/w5105.h b/drivers/wiznet5k/ethernet/w5105/w5105.h
new file mode 100644
index 000000000..730b0cd4d
--- /dev/null
+++ b/drivers/wiznet5k/ethernet/w5105/w5105.h
@@ -0,0 +1,3322 @@
+//* ****************************************************************************
+//! \file w5100S.h
+//! \brief W5100S HAL Header File.
+//! \version 1.0.0
+//! \date 2018/03/29
+//! \par  Revision history
+//!       <2018/03/29> 1st Release
+//! \author Peter
+//! \copyright
+//!
+//! Copyright (c)  2013, WIZnet Co., LTD.
+//! All rights reserved.
+//! 
+//! Redistribution and use in source and binary forms, with or without 
+//! modification, are permitted provided that the following conditions 
+//! are met: 
+//! 
+//!     * Redistributions of source code must retain the above copyright 
+//! notice, this list of conditions and the following disclaimer. 
+//!     * Redistributions in binary form must reproduce the above copyright
+//! notice, this list of conditions and the following disclaimer in the
+//! documentation and/or other materials provided with the distribution. 
+//!     * Neither the name of the <ORGANIZATION> nor the names of its 
+//! contributors may be used to endorse or promote products derived 
+//! from this software without specific prior written permission. 
+//! 
+//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
+//! THE POSSIBILITY OF SUCH DAMAGE.
+//
+//*****************************************************************************
+
+
+#ifndef	_w5105_H_
+#define	_w5105_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include "../wizchip_conf.h"
+
+/// \cond DOXY_APPLY_CODE
+#if   (_WIZCHIP_ == 5105)
+/// \endcond
+
+#define _WIZCHIP_SN_BASE_  (0x0400)
+#define _WIZCHIP_SN_SIZE_  (0x0100)
+#define _WIZCHIP_IO_TXBUF_ (0x4000) /* Internal Tx buffer address of the iinchip */
+#define _WIZCHIP_IO_RXBUF_ (0x6000) /* Internal Rx buffer address of the iinchip */
+
+
+#define WIZCHIP_CREG_BLOCK      	      0x00   ///< Common register block
+#define WIZCHIP_SREG_BLOCK(N)    	   (_WIZCHIP_SN_BASE_+ _WIZCHIP_SN_SIZE_*N) ///< Socket N register block
+
+#define WIZCHIP_OFFSET_INC(ADDR, N)    (ADDR + N) ///< Increase offset address
+
+#if (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_DIR_)
+   #define _W5100S_IO_BASE_     _WIZCHIP_IO_BASE_
+#elif (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)
+	#define IDM_OR             ((_WIZCHIP_IO_BASE  + 0x0000))
+	#define IDM_AR0            ((_WIZCHIP_IO_BASE_ + 0x0001))
+	#define IDM_AR1            ((_WIZCHIP_IO_BASE_ + 0x0002))
+	#define IDM_DR             ((_WIZCHIP_IO_BASE_ + 0x0003))
+	#define _W5100S_IO_BASE_    0x0000
+#elif (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
+   #define _W5100S_IO_BASE_    0x0000
+#endif
+
+///////////////////////////////////////
+// Definition For Legacy Chip Driver //
+///////////////////////////////////////
+#define IINCHIP_READ(ADDR)                WIZCHIP_READ(ADDR)               ///< The defined for legacy chip driver
+#define IINCHIP_WRITE(ADDR,VAL)           WIZCHIP_WRITE(ADDR,VAL)          ///< The defined for legacy chip driver
+#define IINCHIP_READ_BUF(ADDR,BUF,LEN)    WIZCHIP_READ_BUF(ADDR,BUF,LEN)   ///< The defined for legacy chip driver
+#define IINCHIP_WRITE_BUF(ADDR,BUF,LEN)   WIZCHIP_WRITE(ADDR,BUF,LEN)      ///< The defined for legacy chip driver
+
+
+//-----------    defgroup --------------------------------
+
+/**
+ * @defgroup W5100S W5100S
+ * @brief WHIZCHIP register defines and I/O functions of @b W5100S.
+ *
+ * - @ref WIZCHIP_register_W5100S: @ref Common_register_group_W5100S and @ref Socket_register_group_W5100S
+ * - @ref WIZCHIP_IO_Functions_W5100S: @ref Basic_IO_function_W5100S, @ref Common_register_access_function_W5100S and @ref Special_function_W5100S
+ */
+
+ /**
+ * @defgroup WIZCHIP_register_W5100S WIZCHIP register
+ * @ingroup W5100S
+ * @brief WIZCHIP register defines register group of <b> W5100S </b>.
+ *
+ * - \ref Common_register_group_W5100S : Common register group W5100S
+ * - \ref Socket_register_group_W5100S : \c SOCKET n register group W5100S
+ */
+
+
+/**
+ * @defgroup WIZCHIP_IO_Functions_W5100S WIZCHIP I/O functions
+ * @ingroup W5100S
+ * @brief This supports the basic I/O functions for \ref WIZCHIP_register_W5100S.
+ *
+ * - <b> Basic I/O function </b> \n
+ *   WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF(), wiz_recv_data(), wiz_recv_ignore(), wiz_send_data() \n\n
+ *
+ * - \ref Common_register_group_W5100S <b>access functions</b> \n
+ * 	-# @b Mode \n
+ *    getMR(), setMR()
+ * 	-# @b Interrupt \n
+ *    getIR(), setIR(), getIMR(), setIMR(),
+ * 	-# <b> Network Information </b> \n
+ *    getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR()
+ * 	-# @b Retransmission \n
+ *    getRCR(), setRCR(), getRTR(), setRTR()
+ * 	-# @b PPPoE \n
+ *    getPTIMER(), setPTIMER(), getPMAGIC(), getPMAGIC()
+ *
+ * - \ref Socket_register_group_W5100S <b>access functions</b> \n
+ *   -# <b> SOCKET control</b> \n
+ *      getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IR()
+ *   -# <b> SOCKET information</b> \n
+ *      getSn_SR(), getSn_DHAR(), setSn_DHAR(), getSn_PORT(), setSn_PORT(), getSn_DIPR(), setSn_DIPR(), getSn_DPORT(), setSn_DPORT()
+ *      getSn_MSSR(), setSn_MSSR()
+ *   -# <b> SOCKET communication </b> \n
+ *      getSn_RXMEM_SIZE(), setSn_RXMEM_SIZE(), getSn_TXMEM_SIZE(), setSn_TXMEM_SIZE() \n
+ *      getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
+ *      getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
+ *      getSn_TX_FSR(), getSn_RX_RSR()
+ *   -# <b> IP header field </b> \n
+ *      getSn_FRAG(), setSn_FRAG(),  getSn_TOS(), setSn_TOS() \n
+ *      getSn_TTL(), setSn_TTL()
+ */
+
+/**
+ * @defgroup Common_register_group_W5100S Common register
+ * @ingroup WIZCHIP_register_W5100S
+ * @brief Common register group\n
+ * It set the basic for the networking\n
+ * It set the configuration such as interrupt, network information, ICMP, etc.
+ * @details
+ * @sa MR : Mode register.
+ * @sa GAR, SUBR, SHAR, SIPR
+ * @sa IR, Sn_IR, _IMR_  : Interrupt.
+ * @sa _RTR_, _RCR_ : Data retransmission.
+ * @sa PTIMER, PMAGIC : PPPoE.
+ */
+
+
+ /**
+ * @defgroup Socket_register_group_W5100S Socket register
+ * @ingroup WIZCHIP_register_W5100S
+ * @brief Socket register group\n
+ * Socket register configures and control SOCKETn which is necessary to data communication.
+ * @details
+ * @sa Sn_MR, Sn_CR, Sn_IR : SOCKETn Control
+ * @sa Sn_SR, Sn_PORT, Sn_DHAR, Sn_DIPR, Sn_DPORT : SOCKETn Information
+ * @sa Sn_MSSR, Sn_TOS, Sn_TTL, Sn_FRAGR : Internet protocol.
+ * @sa Sn_RXMEM_SIZE, Sn_TXMEM_SIZE, Sn_TX_FSR, Sn_TX_RD, Sn_TX_WR, Sn_RX_RSR, Sn_RX_RD, Sn_RX_WR : Data communication
+ */
+
+ /**
+ * @defgroup Basic_IO_function_W5100S Basic I/O function
+ * @ingroup WIZCHIP_IO_Functions_W5100S
+ * @brief These are basic input/output functions to read values from register or write values to register.
+ */
+
+/**
+ * @defgroup Common_register_access_function_W5100S Common register access functions
+ * @ingroup WIZCHIP_IO_Functions_W5100S
+ * @brief These are functions to access <b>common registers</b>.
+ */
+
+/**
+ * @defgroup Socket_register_access_function_W5100S Socket register access functions
+ * @ingroup WIZCHIP_IO_Functions_W5100S
+ * @brief These are functions to access <b>socket registers</b>.
+ */
+
+ /**
+ * @defgroup Special_function_W5100S Special functions
+ * @ingroup WIZCHIP_IO_Functions_W5100S
+ * @brief These are special functions to access to the PHY
+ */
+
+ //-----------------------------------------------------------------------------------
+
+//----------------------------- W5100S Common Registers IOMAP -----------------------------
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Mode Register address(R/W)\n
+ * \ref MR is used for S/W reset, ping block mode, PPPoE mode and etc.
+ * @details Each bit of \ref MR defined as follows.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>RST</td> <td>Reserved</td> <td>WOL</td> <td>PB</td> <td>PPPoE</td> <td>Reserved</td> <td>AI</td> <td>IND</td> </tr>
+ * </table>
+ * - \ref MR_RST		 	: Reset
+ * - \ref MR_PB         	: Ping block
+ * - \ref MR_PPPOE      	: PPPoE mode
+ * - \ref MR_AI         	: Address Auto-Increment in Indirect Bus Interface
+ * - \ref MR_IND         	: Indirect Bus Interface mode
+ */
+#if _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_
+   #define MR					(_WIZCHIP_IO_BASE_ + (0x0000))  // Mode
+#else
+   #define MR					(_W5100S_IO_BASE_ + (0x0000))  // Mode
+#endif
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Gateway IP Register address(R/W)
+ * @details \ref GAR configures the default gateway address.
+ */
+#define GAR     			(_W5100S_IO_BASE_ + (0x0001))  // GW Address
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Subnet mask Register address(R/W)
+ * @details \ref SUBR configures the subnet mask address.
+ */
+#define SUBR    			(_W5100S_IO_BASE_ + (0x0005)) // SN Mask Address
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Source MAC Register address(R/W)
+ * @details \ref SHAR configures the source hardware address.
+ */
+#define SHAR    			(_W5100S_IO_BASE_ + (0x0009)) // Source Hardware Address
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Source IP Register address(R/W)
+ * @details \ref SIPR configures the source IP address.
+ */
+#define SIPR    			(_W5100S_IO_BASE_ + (0x000F)) // Source IP Address
+
+// Reserved					(_W5100S_IO_BASE_ + (0x0013))
+// Reserved					(_W5100S_IO_BASE_ + (0x0014))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Interrupt Register(R/W)
+ * @details \ref IR indicates the interrupt status. Each bit of \ref IR will be still until the bit will be written to by the host.
+ * If \ref IR is not equal to x00 INTn PIN is asserted to low until it is x00\n\n
+ * Each bit of \ref IR defined as follows.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>CONFLICT</td> <td>UNREACH</td> <td>PPPoE</td> <td>Reserved</td> <td>S3_INT</td> <td>S2_INT</td> <td>S1_INT</td> <td>S0_INT</td> </tr>
+ * </table>
+ * - \ref IR_CONFLICT : IP conflict
+ * - \ref IR_UNREACH  : Destination unreachable
+ * - \ref IR_PPPoE	 : PPPoE connection close
+ * - \ref IR_SOCK(3)  : SOCKET 3 Interrupt
+ * - \ref IR_SOCK(2)  : SOCKET 2 Interrupt
+ * - \ref IR_SOCK(1)  : SOCKET 1 Interrupt
+ * - \ref IR_SOCK(0)  : SOCKET 0 Interrupt
+ */
+#define IR					(_W5100S_IO_BASE_ + (0x0015)) // Interrupt
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Socket Interrupt Mask Register(R/W)
+ * @details Each bit of \ref _IMR_ corresponds to each bit of \ref IR.
+ * When a bit of \ref _IMR_ is and the corresponding bit of \ref IR is set, Interrupt will be issued.
+ */
+#define _IMR_    			(_W5100S_IO_BASE_ + (0x0016)) // Socket Interrupt Mask
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Timeout register address( 1 is 100us )(R/W)
+ * @details \ref _RTR_ configures the retransmission timeout period. The unit of timeout period is 100us and the default of \ref _RTR_ is x07D0or 000
+ * And so the default timeout period is 200ms(100us X 2000). During the time configured by \ref _RTR_, W5100S waits for the peer response
+ * to the packet that is transmitted by \ref Sn_CR (CONNECT, DISCON, CLOSE, SEND, SEND_MAC, SEND_KEEP command).
+ * If the peer does not respond within the \ref _RTR_ time, W5100S retransmits the packet or issues timeout.
+ */
+#define _RTR_     			(_W5100S_IO_BASE_ + (0x0017)) // Retry Time
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Retry count register(R/W)
+ * @details \ref _RCR_ configures the number of time of retransmission.
+ * When retransmission occurs as many as ref _RCR_+1 Timeout interrupt is issued (\ref Sn_IR_TIMEOUT = '1').
+ */
+#define _RCR_				(_W5100S_IO_BASE_ + (0x0019)) // Retry Count
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Receive Memory Size Register
+ * @details \ref RMSR register configures RX bufffer Size of the SOCKET
+ * The sum of the RX buffers can not exceed 8kB.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>S3-1</td> <td>S3-0</td> <td>S2-1</td> <td>S2-0</td> <td>S1-1</td> <td>S1-0</td> <td>S0-1</td> <td>S0-0</td> </tr>
+ * </table>
+ * <table>
+ * 		<tr> <td>Memory Size</td><td>Sn-1</td><td>Sn-0</td> </tr>
+ * 		<tr> <td>1KB</td><td>0</td><td>0</td> </tr>
+ * 		<tr> <td>2KB</td><td>0</td><td>1</td> </tr>
+ * 		<tr> <td>4KB</td><td>1</td><td>0</td> </tr>
+ * 		<tr> <td>8KB</td><td>1</td><td>1</td> </tr>
+ * </table>
+ */
+#define RMSR				(_W5100S_IO_BASE_ + (0x001A)) // Receive Memory Size
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Transmit Memory Size Register
+ * @details \ref TMSR register configures TX bufffer Size of the SOCKET
+ * The sum of the TX buffers can not exceed 8kB.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>S3-1</td> <td>S3-0</td> <td>S2-1</td> <td>S2-0</td> <td>S1-1</td> <td>S1-0</td> <td>S0-1</td> <td>S0-0</td> </tr>
+ * </table>
+ * <table>
+ * 		<tr> <td>Memory Size</td><td>Sn-1</td><td>Sn-0</td> </tr>
+ * 		<tr> <td>1KB</td><td>0</td><td>0</td> </tr>
+ * 		<tr> <td>2KB</td><td>0</td><td>1</td> </tr>
+ * 		<tr> <td>4KB</td><td>1</td><td>0</td> </tr>
+ * 		<tr> <td>8KB</td><td>1</td><td>1</td> </tr>
+ * </table>
+ */
+#define TMSR				(_W5100S_IO_BASE_ + (0x001B)) // Transmit Memory Size
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Interrupt register 2
+ * @details \ref IR2 indicates the interrupt status.
+ * Each bit of IR2 will be still until the bit will be written to by the host.
+ * <table>
+ * 		<tr>  <td>7:1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>Reserved</td> <td>WOL</td> </tr>
+ * </table>
+ * - \ref IR2_WOL : WOL MAGIC PACKET Interrupt Mask
+ */
+#define IR2					(_W5100S_IO_BASE_ + (0x0020))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Interrupt mask register 2
+ * @details \ref IMR2 Each bit of IMR2 corresponds to each bit of IR2.
+ * When a bit of IMR2 is and the corresponding bit of IR2 is set, Interrupt will be issued.
+ */
+#define IMR2				(_W5100S_IO_BASE_ + (0x0021))
+
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PPP LCP Request Timer register  in PPPoE mode(R)
+ * @details \ref PTIMER configures the time for sending LCP echo request. The unit of time is 25ms.
+ */
+#define PTIMER				(_W5100S_IO_BASE_ + (0x0028)) // PPP LCP RequestTimer
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PPP LCP Magic number register  in PPPoE mode(R)
+ * @details \ref PMAGIC configures the 4bytes magic number to be used in LCP negotiation.
+ */
+#define PMAGIC				(_W5100S_IO_BASE_ + (0x0029)) // PPP LCP Magic number
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Unreachable IP address register
+ * @details \ref
+ */
+#define UIPR				(_W5100S_IO_BASE_ + (0x002A))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Unreachable Port register
+ * @details \ref
+ */
+#define UPORTR				(_W5100S_IO_BASE_  + (0x002E))
+
+/* register for W5100S only */
+
+/*------------------------------------------ Common registers ------------------------------------------*/
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief MR2 Mode register 2
+ * @details \reg
+ */
+#define MR2					(_W5100S_IO_BASE_ + (0x0030))
+
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Destination Hardware address in PPPoE
+ * @details \reg
+ */
+#define PHAR				(_W5100S_IO_BASE_ + (0x0032))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Session ID in PPPoE
+ * @details \reg
+ */
+#define PSIDR				(_W5100S_IO_BASE_ + (0x0038))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Maximum receive Unit in PPPoE
+ * @details \reg
+ */
+#define PMRUR				(_W5100S_IO_BASE_ + (0x003A))
+
+
+/*------------------------------------------ PHY registers ------------------------------------------*/
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY status register
+ * @details \reg
+ */
+#define PHYSR				(_W5100S_IO_BASE_ + (0x003C))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY status register(hidden)
+ * @details \reg
+ */
+#define PHYSR1				(_W5100S_IO_BASE_ + (0x003D))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Address value
+ * @details \reg
+ */
+#define PHYAR				(_W5100S_IO_BASE_ + (0x003E))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Register address
+ * @details \reg
+ */
+#define PHYRAR				(_W5100S_IO_BASE_ + (0x003F))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Data input register
+ * @details \reg
+ */
+#define PHYDIR				(_W5100S_IO_BASE_ + (0x0040))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY data output register
+ * @details \reg
+ */
+#define PHYDOR				(_W5100S_IO_BASE_ + (0x0042))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Action register
+ * @details \reg
+ */
+#define PHYACR				(_W5100S_IO_BASE_ + (0x0044))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Division register
+ * @details \reg
+ */
+#define PHYDIVR				(_W5100S_IO_BASE_ + (0x0045))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Control register 0
+ * @details \reg
+ */
+#define PHYCR0					(_W5100S_IO_BASE_ + (0x0046))
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Control register 1
+ * @details \reg
+ */
+#define PHYCR1					(_W5100S_IO_BASE_ + (0x0047))
+
+/*------------------------------------------ Socket Less registers ------------------------------------------*/
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Socket-less control register
+ * @details \reg
+ */
+#define SLCR				(_W5100S_IO_BASE_ + (0x004C))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Socket-less retry time register
+ * @details \reg
+ */
+#define SLRTR				(_W5100S_IO_BASE_ + (0x004D))
+
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Socket-less retry count register
+ * @details \reg
+ */
+#define SLRCR				(_W5100S_IO_BASE_ + (0x004F))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Socket-less peer IP address register
+ * @details \reg
+ */
+#define SLPIPR				(_W5100S_IO_BASE_ + (0x0050))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Socket-less peer hardware address register
+ * @details \reg
+ */
+#define SLPHAR				(_W5100S_IO_BASE_ + (0x0054))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Ping sequence number register
+ * @details \reg
+ */
+#define PINGSEQR				(_W5100S_IO_BASE_ + (0x005A))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Ping ID register
+ * @details \reg
+ */
+#define PINGIDR				(_W5100S_IO_BASE_ + (0x005C))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Socket-less interrupt mask register
+ * @details \reg
+ */
+#define SLIMR				(_W5100S_IO_BASE_ + (0x005E))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief  Socket-less interrupt register
+ * @details \reg
+ */
+#define SLIR				(_W5100S_IO_BASE_ + (0x005F))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief DBGOUT(hidden)
+ * @details \reg
+ */
+#define DBGOUT				(_W5100S_IO_BASE_ + (0x0060))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief NICMAXCOLR(hidden)
+ * @details \reg
+ */
+#define NICMAXCOLR			(_W5100S_IO_BASE_ + (0x0063))
+/*------------------------------------------ CFG registers ------------------------------------------*/
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Chip Configuration locking register
+ * @details \reg
+ */
+#define CHIPLCKR				(_W5100S_IO_BASE_ + (0x0070))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Network Configuration locking register
+ * @details \reg
+ */
+#define NETLCKR				(_W5100S_IO_BASE_ + (0x0071))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief PHY Configuration locking register
+ * @details \reg
+ */
+#define PHYLCKR				(_W5100S_IO_BASE_ + (0x0072))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief version register
+ * @details \reg
+ */
+#define VERR				(_W5100S_IO_BASE_ + (0x0080))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Core 100us Counter register
+ * @details \reg
+ */
+#define TCNTR				(_W5100S_IO_BASE_ + (0x0082))
+
+/**
+ * @ingroup Common_register_group_W5100S
+ * @brief Core 100us Counter clear register
+ * @details \reg
+ */
+#define TCNTCLKR			(_W5100S_IO_BASE_ + (0x0088))
+
+//----------------------------- W5100S Socket Registers -----------------------------
+#define WIZCHIP_SREG_ADDR(sn, addr) (WIZCHIP_SREG_BLOCK(sn) + (addr))
+//--------------------------- For Backward Compatibility ---------------------------
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief socket Mode register(R/W)
+ * @details \ref Sn_MR configures the option or protocol type of Socket n.\n\n
+ * Each bit of \ref Sn_MR defined as the following.
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>MULTI</td> <td>MF</td> <td>ND/MC</td> <td>Reserved</td> <td>Protocol[3]</td> <td>Protocol[2]</td> <td>Protocol[1]</td> <td>Protocol[0]</td> </tr>
+ * </table>
+ * - \ref Sn_MR_MULTI	: Support UDP Multicasting
+ * - \ref Sn_MR_MF	   : Support MACRAW
+ * - \ref Sn_MR_ND		: No Delayed Ack(TCP) flag
+ * - \ref Sn_MR_MC   	: IGMP version used <b>in UDP mulitcasting</b>
+ * - <b>Protocol</b>
+ * <table>
+ * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
+ * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>Closed</td>   </tr>
+ * 		<tr>   <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>TCP</td>   </tr>
+ * 		<tr>   <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>UDP</td>   </tr>
+ * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
+ * </table>
+ * - <b>In case of Socket 0</b>
+ *  <table>
+ * 		<tr>   <td><b>Protocol[3]</b></td> <td><b>Protocol[2]</b></td> <td><b>Protocol[1]</b></td> <td><b>Protocol[0]</b></td> <td>@b Meaning</td>   </tr>
+ * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>MACRAW</td>   </tr>
+ * 		<tr>   <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>PPPoE</td>   </tr>
+ * </table>
+ *	 - \ref Sn_MR_MACRAW	: MAC LAYER RAW SOCK \n
+ *  - \ref Sn_MR_UDP		: UDP
+ *  - \ref Sn_MR_TCP		: TCP
+ *  - \ref Sn_MR_CLOSE	: Unused socket
+ *  @note MACRAW mode should be only used in Socket 0.
+ */
+#define Sn_MR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0000)) // socket Mode register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket command register(R/W)
+ * @details This is used to set the command for Socket n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
+ * After W5100S accepts the command, the \ref Sn_CR register is automatically cleared to 0x00.
+ * Even though \ref Sn_CR is cleared to 0x00, the command is still being processed.\n
+ * To check whether the command is completed or not, please check the \ref Sn_IR or \ref Sn_SR.
+ * - \ref Sn_CR_OPEN 		: Initialize or open socket.
+ * - \ref Sn_CR_LISTEN 		: Wait connection request in TCP mode(<b>Server mode</b>)
+ * - \ref Sn_CR_CONNECT 	: Send connection request in TCP mode(<b>Client mode</b>)
+ * - \ref Sn_CR_DISCON 		: Send closing request in TCP mode.
+ * - \ref Sn_CR_CLOSE   	: Close socket.
+ * - \ref Sn_CR_SEND    	: Update TX buffer pointer and send data.
+ * - \ref Sn_CR_SEND_MAC	: Send data with MAC address, so without ARP process.
+ * - \ref Sn_CR_SEND_KEEP 	: Send keep alive message.
+ * - \ref Sn_CR_RECV		: Update RX buffer pointer and receive data.
+ * - <b>In case of S0_MR(P3:P0) = S0_MR_PPPoE</b>
+ *  <table>
+ * 		<tr>   <td><b>Value</b></td> <td><b>Symbol</b></td> <td><b>Description</b></td></tr>
+ * 		<tr>   <td>0x23</td> <td>PCON</td> <td>PPPoE connection begins by transmitting PPPoE discovery packet</td>  </tr>
+ * 		<tr>   <td>0x24</td> <td>PDISCON</td> <td>Closes PPPoE connection</td>  </tr>
+ * 		<tr>   <td>0x25</td> <td>PCR</td> <td>In each phase, it transmits REQ message.</td> </tr>
+ * 		<tr>   <td>0x26</td> <td>PCN</td> <td>In each phase, it transmits NAK message.</td> </tr>
+ * 		<tr>   <td>0x27</td> <td>PCJ</td> <td>In each phase, it transmits REJECT message.</td> </tr>
+ * </table>
+ */
+#define Sn_CR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0001)) // channel Sn_CR register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket interrupt register(R)
+ * @details \ref Sn_IR indicates the status of Socket Interrupt such as establishment, termination, receiving data, timeout).\n
+ * When an interrupt occurs and the corresponding bit \ref IR_SOCK(N) in \ref _IMR_ are set, \ref IR_SOCK(N) in \ref IR becomes '1'.\n
+ * In order to clear the \ref Sn_IR bit, the host should write the bit to \n
+ * <table>
+ * 		<tr>  <td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td>   </tr>
+ * 		<tr>  <td>PRECV</td> <td>PFAIL</td> <td>PNEXT</td> <td>SEND_OK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
+ * </table>
+ * - \ref Sn_IR_PRECV : <b>PPP Receive Interrupt</b>
+ * - \ref Sn_IR_PFAIL : <b>PPP Fail Interrupt</b>
+ * - \ref Sn_IR_PNEXT : <b>PPP Next Phase Interrupt</b>
+ * - \ref Sn_IR_SENDOK : <b>SEND_OK Interrupt</b>
+ * - \ref Sn_IR_TIMEOUT : <b>TIMEOUT Interrupt</b>
+ * - \ref Sn_IR_RECV : <b>RECV Interrupt</b>
+ * - \ref Sn_IR_DISCON : <b>DISCON Interrupt</b>
+ * - \ref Sn_IR_CON : <b>CON Interrupt</b>
+ */
+#define Sn_IR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0002)) // channel interrupt register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket status register(R)
+ * @details \ref Sn_SR indicates the status of Socket n.\n
+ * The status of Socket n is changed by \ref Sn_CR or some special control packet as SYN, FIN packet in TCP.
+ * @par Normal status
+ * - \ref SOCK_CLOSED 		: Closed
+ * - \ref SOCK_INIT   		: Initiate state
+ * - \ref SOCK_LISTEN    	: Listen state
+ * - \ref SOCK_ESTABLISHED 	: Success to connect
+ * - \ref SOCK_CLOSE_WAIT   : Closing state
+ * - \ref SOCK_UDP   		: UDP socket
+ * - \ref SOCK_MACRAW  		: MAC raw mode socket
+ *@par Temporary status during changing the status of Socket n.
+ * - \ref SOCK_SYNSENT   	: This indicates Socket n sent the connect-request packet (SYN packet) to a peer.
+ * - \ref SOCK_SYNRECV    	: It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.
+ * - \ref SOCK_FIN_WAIT		: Connection state
+ * - \ref SOCK_CLOSING		: Closing state
+ * - \ref SOCK_TIME_WAIT	: Closing state
+ * - \ref SOCK_LAST_ACK 	: Closing state
+ */
+#define Sn_SR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0003)) // channel status register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief source port register(R/W)
+ * @details \ref Sn_PORT configures the source port number of Socket n.
+ * It is valid when Socket n is used in TCP/UDP mode. It should be set before OPEN command is ordered.
+*/
+#define Sn_PORT(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0004)) // source port register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Peer MAC register address(R/W)
+ * @details \ref Sn_DHAR configures the destination hardware address of Socket n when using SEND_MAC command in UDP mode or
+ * it indicates that it is acquired in ARP-process by CONNECT/SEND command.
+ */
+#define Sn_DHAR(sn)     (_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0006)) // Peer MAC register address
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Peer IP register address(R/W)
+ * @details \ref Sn_DIPR configures or indicates the destination IP address of Socket n. It is valid when Socket n is used in TCP/UDP mode.
+ * In TCP client mode, it configures an IP address of TCP server before CONNECT command.
+ * In TCP server mode, it indicates an IP address of TCP client after successfully establishing connection.
+ * In UDP mode, it configures an IP address of peer to be received the UDP packet by SEND or SEND_MAC command.
+ */
+#define Sn_DIPR(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x000C)) // Peer IP register address
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Peer port register address(R/W)
+ * @details \ref Sn_DPORT configures or indicates the destination port number of Socket n. It is valid when Socket n is used in TCP/UDP mode.
+ * In TCP clientmode, it configures the listen port number of TCP server before CONNECT command.
+ * In TCP Servermode, it indicates the port number of TCP client after successfully establishing connection.
+ * In UDP mode, it configures the port number of peer to be transmitted the UDP packet by SEND/SEND_MAC command.
+ */
+#define Sn_DPORT(sn)    (_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0010)) // Peer port register address
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Maximum Segment Size(Sn_MSSR0) register address(R/W)
+ * @details \ref Sn_MSSR configures or indicates the MTU(Maximum Transfer Unit) of Socket n.
+ */
+#define Sn_MSSR(sn)	   (_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0012)) // Maximum Segment Size(Sn_MSSR0) register address
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief IP Protocol(PROTO) Register(R/W)
+ * @details \ref Sn_PROTO that sets the protocol number field of the IP header at the IP layer. It is
+ * valid only in IPRAW mode, and ignored in other modes.
+ */
+#define Sn_PROTO(sn)	   (_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0014)) // Protocol of IP Header field register in IP raw mode
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief IP Type of Service(TOS) Register(R/W)
+ * @details \ref Sn_TOS configures the TOS(Type Of Service field in IP Header) of Socket n.
+ * It is set before OPEN command.
+ */
+#define Sn_TOS(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + 0x0015) // IP Type of Service(TOS) Register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief IP Time to live(TTL) Register(R/W)
+ * @details \ref Sn_TTL configures the TTL(Time To Live field in IP header) of Socket n.
+ * It is set before OPEN command.
+ */
+#define Sn_TTL(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0016)) // IP Time to live(TTL) Register
+
+// Reserved					(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0017))
+// Reserved					(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0018))
+// Reserved					(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0019))
+// Reserved					(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001A))
+// Reserved					(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001B))
+// Reserved					(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001C))
+// Reserved					(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001D))
+
+
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Receive memory size register(R/W)
+ * @details @ref Sn_RXBUF_SIZE configures the RX buffer block size of Socket n.
+ * Socket n RX Buffer Block size can be configured with 1,2,4 and 8Kbytes.
+ * If a different size is configured, the data cannot be normally received from a peer.
+ * Although Socket n RX Buffer Block size is initially configured to 2Kbytes,
+ * user can re-configure its size using @ref Sn_RXBUF_SIZE. The total sum of @ref Sn_RXBUF_SIZE can not be exceed 8Kbytes.
+ * When exceeded, the data reception error is occurred.
+ */
+#define Sn_RXBUF_SIZE(sn)   (_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001E))
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Transmit memory size register(R/W)
+ * @details @ref Sn_TXBUF_SIZE configures the TX buffer block size of Socket n. Socket n TX Buffer Block size can be configured with 1,2,4 and 8Kbytes.
+ * If a different size is configured, the data cannot be normally transmitted to a peer.
+ * Although Socket n TX Buffer Block size is initially configured to 2Kbytes,
+ * user can be re-configure its size using @ref Sn_TXBUF_SIZE. The total sum of @ref Sn_TXBUF_SIZE can not be exceed 8Kbytes.
+ * When exceeded, the data transmission error is occurred.
+ */
+#define Sn_TXBUF_SIZE(sn)   (_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x001F))
+
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Transmit free memory size register(R)
+ * @details \ref Sn_TX_FSR indicates the free size of Socket n TX Buffer Block. It is initialized to the configured size by \ref Sn_TXMEM_SIZE.
+ * Data bigger than \ref Sn_TX_FSR should not be saved in the Socket n TX Buffer because the bigger data overwrites the previous saved data not yet sent.
+ * Therefore, check before saving the data to the Socket n TX Buffer, and if data is equal or smaller than its checked size,
+ * transmit the data with SEND/SEND_MAC command after saving the data in Socket n TX buffer. But, if data is bigger than its checked size,
+ * transmit the data after dividing into the checked size and saving in the Socket n TX buffer.
+ */
+#define Sn_TX_FSR(sn)	(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0020)) // Transmit free memory size register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Transmit memory read pointer register address(R)
+ * @details \ref Sn_TX_RD is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001), it is re-initialized while connecting with TCP.
+ * After its initialization, it is auto-increased by SEND command.
+ * SEND command transmits the saved data from the current \ref Sn_TX_RD to the \ref Sn_TX_WR in the Socket n TX Buffer.
+ * After transmitting the saved data, the SEND command increases the \ref Sn_TX_RD as same as the \ref Sn_TX_WR.
+ * If its increment value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
+ * then the carry bit is ignored and will automatically update with the lower 16bits value.
+ */
+#define Sn_TX_RD(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0022)) // Transmit memory read pointer register address
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Transmit memory write pointer register address(R/W)
+ * @details \ref Sn_TX_WR is initialized by OPEN command. However, if Sn_MR(P[3:0]) is TCP mode(001), it is re-initialized while connecting with TCP.\n
+ * It should be read or be updated like as follows.\n
+ * 1. Read the starting address for saving the transmitting data.\n
+ * 2. Save the transmitting data from the starting address of Socket n TX buffer.\n
+ * 3. After saving the transmitting data, update \ref Sn_TX_WR to the increased value as many as transmitting data size.
+ * If the increment value exceeds the maximum value 0xFFFF(greater than 0x10000 and the carry bit occurs),
+ * then the carry bit is ignored and will automatically update with the lower 16bits value.\n
+ * 4. Transmit the saved data in Socket n TX Buffer by using SEND/SEND command
+ */
+#define Sn_TX_WR(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0024)) // Transmit memory write pointer register address
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Received data size register(R)
+ * @details \ref Sn_RX_RSR indicates the data size received and saved in Socket n RX Buffer.
+ * \ref Sn_RX_RSR does not exceed the \ref Sn_RXMEM_SIZE and is calculated as the difference between
+ * Socket n RX Write Pointer (\ref Sn_RX_WR)and Socket n RX Read Pointer (\ref Sn_RX_RD)
+ */
+#define Sn_RX_RSR(sn)	(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0026)) // Received data size register
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Read point of Receive memory(R/W)
+ * @details \ref Sn_RX_RD is initialized by OPEN command. Make sure to be read or updated as follows.\n
+ * 1. Read the starting save address of the received data.\n
+ * 2. Read data from the starting address of Socket n RX Buffer.\n
+ * 3. After reading the received data, Update \ref Sn_RX_RD to the increased value as many as the reading size.
+ * If the increment value exceeds the maximum value 0xFFFF, that is, is greater than 0x10000 and the carry bit occurs,
+ * update with the lower 16bits value ignored the carry bit.\n
+ * 4. Order RECV command is for notifying the updated \ref Sn_RX_RD to W5100S.
+ */
+#define Sn_RX_RD(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0028)) // Read point of Receive memory
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Write point of Receive memory(R)
+ * @details \ref Sn_RX_WR is initialized by OPEN command and it is auto-increased by the data reception.
+ * If the increased value exceeds the maximum value 0xFFFF, (greater than 0x10000 and the carry bit occurs),
+ * then the carry bit is ignored and will automatically update with the lower 16bits value.
+ */
+#define Sn_RX_WR(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x002A)) // Write point of Receive memory
+
+
+//todo
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket interrupt mask register
+ * @details Register address to configure the interrupt mask of the socket
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ *
+ */
+#define Sn_IMR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x002C))
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket fragment field register
+ * @details Register to configure the Fragment field of IP Header
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ */
+#define Sn_FRAGR(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x002D)) // and +1
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket Mode register 2
+ * @details Register to set mode 2
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ */
+#define Sn_MR2(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x002F))
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket n Keep Alive Timer Register
+ * @details Register to set the transmission period of keep alive packet.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ */
+#define Sn_KPALVTR(sn)		(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0030))
+
+/** todo delete
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket n Timer Status Register
+ * @details
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ */
+//#define Sn_TSR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0031))
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket n Retry Time-value Register
+ * @details Register to set the retry time value
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ */
+#define Sn_RTR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0032))
+
+/**
+ * @ingroup Socket_register_group_W5100S
+ * @brief Socket n Retry Count-value Register
+ * @details Register to set the retry count value
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ */
+#define Sn_RCR(sn)			(_W5100S_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (0x0034))
+
+
+/*----------------------------- W5100S Register values  -----------------------------*/
+
+/* MODE register values */
+/**
+ * @brief Reset
+ * @details If this bit is  All internal registers will be initialized. It will be automatically cleared as after S/W reset.
+ */
+#define MR_RST				0x80 ///< reset
+
+
+/**
+ * @brief Ping block
+ * @details 0 : Disable Ping block\n
+ * 1 : Enable Ping block\n
+ * If the bit is  it blocks the response to a ping request.
+ */
+#define MR_PB				0x10 ///< ping block
+
+/**
+ * @brief Enable PPPoE
+ * @details 0 : DisablePPPoE mode\n
+ * 1 : EnablePPPoE mode\n
+ * If you use ADSL, this bit should be '1'.
+ */
+#define MR_PPPOE			0x08 ///< enable pppoe
+
+/**
+ * @brief Address Auto-Increment in Indirect Bus Interface
+ * @details 0 : Disable auto-increment \n
+ * 1 : Enable auto-incremente \n
+ * At the Indirect Bus Interface mode, if this bit is set as the address will
+ * be automatically increased by 1 whenever read and write are performed.
+ */
+#define MR_AI				0x02 ///< auto-increment in indirect mode
+
+/**
+ * @brief Indirect Bus Interface mode
+ * @details 0 : Disable Indirect bus Interface mode \n
+ * 1 : Enable Indirect bus Interface mode \n
+ * If this bit is set as Indirect Bus Interface mode is set.
+ */
+#define MR_IND				0x01 ///< enable indirect mode
+
+/* IR register values */
+/**
+ * @brief Check IP conflict.
+ * @details Bit is set as when own source IP address is same with the sender IP address in the received ARP request.
+ */
+#define IR_CONFLICT			0x80 ///< check ip confict
+
+/**
+ * @brief Get the destination unreachable message in UDP sending.
+ * @details When receiving the ICMP (Destination port unreachable) packet, this bit is set as
+ * When this bit is  Destination Information such as IP address and Port number may be checked with the corresponding @ref UIPR & @ref UPORTR.
+ */
+#define IR_UNREACH			0x40 ///< check destination unreachable
+
+/**
+ * @brief Get the PPPoE close message.
+ * @details When PPPoE is disconnected during PPPoE mode, this bit is set.
+ */
+#define IR_PPPoE			0x20 ///< get the PPPoE close message
+
+/**
+ * @brief Socket interrupt bit
+ * @details Indicates whether each socket interrupt has occured.
+ */
+#define IR_SOCK(sn)		(0x01 << sn)	///< check socket interrupt
+
+/**
+ * @brief IP conflict interrupt mask bit
+ * @details If this bit is set, IP conflict interrupt is enabled.
+ */
+#define IMR_CONFLICT		0x80
+
+/**
+ * @brief Destination port unreachable interrupt mask bit
+ * @details If this bit is set, destination port unreachable interrupt is enabled.
+ */
+#define IMR_UNREACH			0x40
+
+/**
+ * @brief PADT/LCPT interrupt mask bit(PPPoE)
+ * @details If this bit is set, PADT/LCPT interrupt is enabled.
+ */
+#define IMR_PPPoE			0x20
+
+/**
+ * @brief Socket interrupt mask bit
+ * @details If this bit is set, each socket interrupt is enabled.
+ */
+#define IMR_SOCK(sn)		(0x01 << sn)
+
+/**
+ * @brief Socket-less command register bit
+ * @details ARP command
+ */
+#define SLCMD_ARP		(1<<1)
+
+/**
+ * @brief Socket-less command register bit
+ * @details ARP command
+ */
+#define SLCMD_PING		(1<<0)
+
+/**
+ * @brief Socket-less command interrupt and interrupt mask register bit
+ * @details Request command time out interrupt and interrupt mask
+ */
+#define SLIR_TIMEOUT		(1<<2)
+
+/**
+* @brief Socket less command interrupt and interrupt mask register bit
+* @details Socket less command ARP interrupt and interrupt mask
+*/
+#define SLIR_ARP (1<<1)
+
+/**
+* @brief Socket less command interrupt and interrupt mask register bit
+* @details Socket less command PING interrupt and interruptmask
+*/
+#define SLIR_PING (1<<0)
+
+
+
+// Sn_MR values
+/* Sn_MR Default values */
+/**
+ * @brief Unused socket
+ * @details This configures the protocol mode of Socket n.
+ */
+#define Sn_MR_CLOSE			0x00 ///< unused socket
+
+/**
+ * @brief TCP
+ * @details This configures the protocol mode of Socket n.
+ */
+#define Sn_MR_TCP			0x01 ///< TCP
+
+/**
+ * @brief UDP
+ * @details This configures the protocol mode of Socket n.
+ */
+#define Sn_MR_UDP       0x02 ///< UDP
+#define Sn_MR_IPRAW     0x03 ///< IP LAYER RAW SOCK
+
+/**
+ * @brief MAC LAYER RAW SOCK
+ * @details This configures the protocol mode of Socket n.
+ * @note MACRAW mode should be only used in Socket 0.
+ */
+#define Sn_MR_MACRAW		0x04 ///< MAC LAYER RAW SOCK
+
+/**
+ * @brief PPPoE
+ * @details This configures the protocol mode of Socket n.
+ * @note PPPoE mode should be only used in Socket 0.
+ */
+#define Sn_MR_PPPoE			0x05 ///< PPPoE
+
+/**
+ * @brief No Delayed Ack(TCP), Multicast flag
+ * @details 0 : Disable No Delayed ACK option\n
+ * 1 : Enable No Delayed ACK option\n
+ * This bit is applied only during TCP mode (P[3:0] = 001).\n
+ * When this bit is  It sends the ACK packet without delay as soon as a Data packet is received from a peer.\n
+ * When this bit is  It sends the ACK packet after waiting for the timeout time configured by \ref _RTR_.
+ */
+#define Sn_MR_ND			0x20 ///< No Delayed Ack(TCP) flag
+
+/**
+ * @brief Support UDP Multicasting
+ * @details 0 : using IGMP version 2\n
+ * 1 : using IGMP version 1\n
+ * This bit is applied only during UDP mode(P[3:0] = 010 and MULTI = '1')
+ * It configures the version for IGMP messages (Join/Leave/Report).
+ */
+#define Sn_MR_MC			Sn_MR_ND ///< Select IGMP version 1(0) or 2(1)
+
+/**
+ * @brief MAC filter enable in @ref Sn_MR_MACRAW mode
+ * @details 0 : disable MAC Filtering\n
+ * 1 : enable MAC Filtering\n
+ * This bit is applied only during MACRAW mode(P[3:0] = 100.\n
+ * When set as  W5100S can only receive broadcasting packet or packet sent to itself.
+ * When this bit is  W5100S can receive all packets on Ethernet.
+ * If user wants to implement Hybrid TCP/IP stack,
+ * it is recommended that this bit is set as for reducing host overhead to process the all received packets.
+ */
+#define Sn_MR_MF			0x40 ///< Use MAC filter
+#define Sn_MR_MFEN      Sn_MR_MF
+
+
+/* Sn_MR Default values */
+/**
+ * @brief Support UDP Multicasting
+ * @details 0 : disable Multicasting\n
+ * 1 : enable Multicasting\n
+ * This bit is applied only during UDP mode(P[3:0] = 010).\n
+ * To use multicasting, \ref Sn_DIPR & \ref Sn_DPORT should be respectively configured with the multicast group IP address & port number
+ * before Socket n is opened by OPEN command of \ref Sn_CR.
+ */
+#define Sn_MR_MULTI			0x80 ///< support multicating
+
+/* Sn_CR values */
+/**
+ * @brief Initialize or open socket
+ * @details Socket n is initialized and opened according to the protocol selected in Sn_MR(P3:P0).
+ * The table below shows the value of \ref Sn_SR corresponding to \ref Sn_MR.\n
+ * <table>
+ *   <tr>  <td>\b Sn_MR (P[3:0])</td> <td>\b Sn_SR</td>            		 </tr>
+ *   <tr>  <td>Sn_MR_CLOSE  (000)</td> <td>--</td>         	   		 </tr>
+ *   <tr>  <td>Sn_MR_TCP  (001)</td> <td>SOCK_INIT (0x13)</td>  		 </tr>
+ *   <tr>  <td>Sn_MR_UDP  (010)</td>  <td>SOCK_UDP (0x22)</td>  		 </tr>
+ *   <tr>  <td>S0_MR_IPRAW  (011)</td>  <td>SOCK_IPRAW (0x32)</td>  </tr>
+ *   <tr>  <td>S0_MR_MACRAW  (100)</td>  <td>SOCK_MACRAW (0x42)</td>  </tr>
+ *   <tr>  <td>S0_MR_PPPoE  (101)</td>  <td>SOCK_PPPoE (0x5F)</td>  </tr>
+ * </table>
+ */
+#define Sn_CR_OPEN			0x01 ///< initialize or open socket
+
+/**
+ * @brief Wait connection request in TCP mode(Server mode)
+ * @details This is valid only in TCP mode (Sn_MR(P3:P0) = \ref Sn_MR_TCP).//
+ * In this mode, Socket n operates as a 'TCP server' and waits for connection-request (SYN packet) from any 'TCP client'.//
+ * The \ref Sn_SR changes the state from SOCK_INIT to SOCKET_LISTEN.//
+ * When a 'TCP client' connection request is successfully established,
+ * the \ref Sn_SR changes from SOCK_LISTEN to SOCK_ESTABLISHED and the Sn_IR(0) becomes
+ * But when a 'TCP client' connection request is failed, Sn_IR(3) becomes and the status of \ref Sn_SR changes to SOCK_CLOSED.
+ */
+#define Sn_CR_LISTEN		0x02 ///< wait connection request in tcp mode(Server mode)
+
+/**
+ * @brief Send connection request in TCP mode(Client mode)
+ * @details  To connect, a connect-request (SYN packet) is sent to <b>TCP server</b>configured by \ref Sn_DIPR & Sn_DPORT(destination address & port).
+ * If the connect-request is successful, the \ref Sn_SR is changed to \ref SOCK_ESTABLISHED and the Sn_IR(0) becomes \n\n
+ * The connect-request fails in the following three cases.\n
+ * 1. When a @b ARPTO occurs (\ref Sn_IR[3] = '1') because destination hardware address is not acquired through the ARP-process.\n
+ * 2. When a @b SYN/ACK packet is not received and @b TCPTO (Sn_IR(3) ='1')\n
+ * 3. When a @b RST packet is received instead of a @b SYN/ACK packet. In these cases, \ref Sn_SR is changed to \ref SOCK_CLOSED.
+ * @note This is valid only in TCP mode and operates when Socket n acts as <b>TCP client</b>
+ */
+#define Sn_CR_CONNECT		0x04 ///< send connection request in tcp mode(Client mode)
+
+/**
+ * @brief Send closing request in TCP mode
+ * @details Regardless of <b>TCP server</b>or <b>TCP client</b> the DISCON command processes the disconnect-process (<b>Active close</b>or <b>Passive close</b>.\n
+ * @par Active close
+ * it transmits disconnect-request(FIN packet) to the connected peer\n
+ * @par Passive close
+ * When FIN packet is received from peer, a FIN packet is replied back to the peer.\n
+ * @details When the disconnect-process is successful (that is, FIN/ACK packet is received successfully), \ref Sn_SR is changed to \ref SOCK_CLOSED.\n
+ * Otherwise, TCPTO occurs (Sn_IR(3)='1') and then \ref Sn_SR is changed to \ref SOCK_CLOSED.
+ * @note Valid only in TCP mode.
+ */
+#define Sn_CR_DISCON		0x08 ///< send closing reqeuset in tcp mode
+
+/**
+ * @brief Close socket
+ * @details Sn_SR is changed to \ref SOCK_CLOSED.
+ */
+#define Sn_CR_CLOSE         0x10
+
+/**
+ * @brief Update TX buffer pointer and send data
+ * @details SEND transmits all the data in the Socket n TX buffer.\n
+ * For more details, please refer to Socket n TX Free Size Register (\ref Sn_TX_FSR), Socket n,
+ * TX Write Pointer Register(\ref Sn_TX_WR), and Socket n TX Read Pointer Register(\ref Sn_TX_RD).
+ */
+#define Sn_CR_SEND          0x20
+
+/**
+ * @brief Send data with MAC address, so without ARP process
+ * @details The basic operation is same as SEND.\n
+ * Normally SEND transmits data after destination hardware address is acquired by the automatic ARP-process(Address Resolution Protocol).\n
+ * But SEND_MAC transmits data without the automatic ARP-process.\n
+ * In this case, the destination hardware address is acquired from \ref Sn_DHAR configured by host, instead of APR-process.
+ * @note Valid only in UDP mode.
+ */
+#define Sn_CR_SEND_MAC      0x21
+
+/**
+ * @brief Send keep alive message
+ * @details It checks the connection status by sending 1byte keep-alive packet.\n
+ * If the peer can not respond to the keep-alive packet during timeout time, the connection is terminated and the timeout interrupt will occur.
+ * @note Valid only in TCP mode.
+ */
+#define Sn_CR_SEND_KEEP     0x22
+
+/**
+ * @brief Update RX buffer pointer and receive data
+ * @details RECV completes the processing of the received data in Socket n RX Buffer by using a RX read pointer register (\ref Sn_RX_RD).\n
+ * For more details, refer to Socket n RX Received Size Register (\ref Sn_RX_RSR), Socket n RX Write Pointer Register (\ref Sn_RX_WR),
+ * and Socket n RX Read Pointer Register (\ref Sn_RX_RD).
+ */
+#define Sn_CR_RECV          0x40
+
+/**
+ * @brief
+ * @details
+ */
+#define Sn_CR_IGMP_JOIN			0x23
+
+/**
+ * @brief
+ * @details
+ */
+#define Sn_CR_IGMP_LEAVE		0x24
+
+
+/* Sn_IR values */
+
+/**
+ * @brief SEND_OK Interrupt
+ * @details This is issued when SEND command is completed.
+ */
+#define Sn_IR_SENDOK		0x10 ///< complete sending
+
+/**
+ * @brief TIMEOUT Interrupt
+ * @details This is issued when ARPTO or TCPTO occurs.
+ */
+#define Sn_IR_TIMEOUT		0x08 ///< assert timeout
+
+/**
+ * @brief RECV Interrupt
+ * @details This is issued whenever data is received from a peer.
+ */
+#define Sn_IR_RECV          0x04
+
+/**
+ * @brief DISCON Interrupt
+ * @details This is issued when FIN or FIN/ACK packet is received from a peer.
+ */
+#define Sn_IR_DISCON        0x02
+
+/**
+ * @brief CON Interrupt
+ * @details This is issued one time when the connection with peer is successful and then \ref Sn_SR is changed to \ref SOCK_ESTABLISHED.
+ */
+#define Sn_IR_CON           0x01
+
+/* Sn_SR values */
+/**
+ * @brief Closed
+ * @details This indicates that Socket n is released.\n
+ * When DICON, CLOSE command is ordered, or when a timeout occurs, it is changed to \ref SOCK_CLOSED regardless of previous status.
+ */
+#define SOCK_CLOSED			0x00 ///< closed
+
+/**
+ * @brief Initiate state
+ * @details This indicates Socket n is opened with TCP mode.\n
+ * It is changed to \ref SOCK_INIT when Sn_MR(P[3:0]) = 001)and OPEN command is ordered.\n
+ * After \ref SOCK_INIT, user can use LISTEN /CONNECT command.
+ */
+#define SOCK_INIT 			0x13 ///< init state
+
+/**
+ * @brief Listen state
+ * @details This indicates Socket n is operating as <b>TCP server</b>mode and waiting for connection-request (SYN packet) from a peer (<b>TCP client</b>).\n
+ * It will change to \ref SOCK_ESTABLISHED when the connection-request is successfully accepted.\n
+ * Otherwise it will change to \ref SOCK_CLOSED after TCPTO occurred (Sn_IR(TIMEOUT) = '1').
+ */
+#define SOCK_LISTEN         0x14
+
+/**
+ * @brief Connection state
+ * @details This indicates Socket n sent the connect-request packet (SYN packet) to a peer.\n
+ * It is temporarily shown when \ref Sn_SR is changed from \ref SOCK_INIT to \ref SOCK_ESTABLISHED by CONNECT command.\n
+ * If connect-accept(SYN/ACK packet) is received from the peer at SOCK_SYNSENT, it changes to \ref SOCK_ESTABLISHED.\n
+ * Otherwise, it changes to \ref SOCK_CLOSED after TCPTO (\ref Sn_IR[TIMEOUT] = '1') is occurred.
+ */
+#define SOCK_SYNSENT        0x15
+
+/**
+ * @brief Connection state
+ * @details It indicates Socket n successfully received the connect-request packet (SYN packet) from a peer.\n
+ * If socket n sends the response (SYN/ACK  packet) to the peer successfully,  it changes to \ref SOCK_ESTABLISHED. \n
+ * If not, it changes to \ref SOCK_CLOSED after timeout occurs (\ref Sn_IR[TIMEOUT] = '1').
+ */
+#define SOCK_SYNRECV        0x16
+
+/**
+ * @brief Success to connect
+ * @details This indicates the status of the connection of Socket n.\n
+ * It changes to \ref SOCK_ESTABLISHED when the <b>TCP SERVER</b>processed the SYN packet from the <b>TCP CLIENT</b>during \ref SOCK_LISTEN, or
+ * when the CONNECT command is successful.\n
+ * During \ref SOCK_ESTABLISHED, DATA packet can be transferred using SEND or RECV command.
+ */
+#define SOCK_ESTABLISHED    0x17
+
+/**
+ * @brief Closing state
+ * @details These indicate Socket n is closing.\n
+ * These are shown in disconnect-process such as active-close and passive-close.\n
+ * When Disconnect-process is successfully completed, or when timeout occurs, these change to \ref SOCK_CLOSED.
+ */
+#define SOCK_FIN_WAIT       0x18
+
+/**
+ * @brief Closing state
+ * @details These indicate Socket n is closing.\n
+ * These are shown in disconnect-process such as active-close and passive-close.\n
+ * When Disconnect-process is successfully completed, or when timeout occurs, these change to \ref SOCK_CLOSED.
+ */
+#define SOCK_CLOSING        0x1A
+
+/**
+ * @brief Closing state
+ * @details These indicate Socket n is closing.\n
+ * These are shown in disconnect-process such as active-close and passive-close.\n
+ * When Disconnect-process is successfully completed, or when timeout occurs, these change to \ref SOCK_CLOSED.
+ */
+#define SOCK_TIME_WAIT      0x1B
+
+/**
+ * @brief Closing state
+ * @details This indicates Socket n received the disconnect-request (FIN packet) from the connected peer.\n
+ * This is half-closing status, and data can be transferred.\n
+ * For full-closing, DISCON command is used. But For just-closing, @ref Sn_CR_CLOSE command is used.
+ */
+#define SOCK_CLOSE_WAIT     0x1C
+
+/**
+ * @brief Closing state
+ * @details This indicates Socket n is waiting for the response (FIN/ACK packet) to the disconnect-request (FIN packet) by passive-close.\n
+ * It changes to \ref SOCK_CLOSED when Socket n received the response successfully, or when timeout occurs  (\ref Sn_IR[TIMEOUT] = '1').
+ */
+#define SOCK_LAST_ACK       0x1D
+
+/**
+ * @brief UDP socket
+ * @details This indicates Socket n is opened in UDP mode(Sn_MR(P[3:0]) = 010).\n
+ * It changes to SOCK_UDP when Sn_MR(P[3:0]) = 010 and @ref Sn_CR_OPEN command is ordered.\n
+ * Unlike TCP mode, data can be transfered without the connection-process.
+ */
+#define SOCK_UDP			0x22 ///< udp socket
+
+/**
+ * @brief IP raw mode socket
+ * @details TThe socket is opened in IPRAW mode. The SOCKET status is change to SOCK_IPRAW when @ref Sn_MR (P3:P0) is
+ * Sn_MR_IPRAW and @ref Sn_CR_OPEN command is used.\n
+ * IP Packet can be transferred without a connection similar to the UDP mode.
+*/
+#define SOCK_IPRAW			0x32 ///< ip raw mode socket
+
+/**
+ * @brief MAC raw mode socket
+ * @details This indicates Socket 0 is opened in MACRAW mode (@ref Sn_MR(P[3:0]) = '100' and n=0) and is valid only in Socket 0.\n
+ * It changes to SOCK_MACRAW when @ref Sn_MR(P[3:0]) = '100' and @ref Sn_CR_OPEN command is ordered.\n
+ * Like UDP mode socket, MACRAW mode Socket 0 can transfer a MAC packet (Ethernet frame) without the connection-process.
+ */
+#define SOCK_MACRAW			0x42 ///< mac raw mode socket
+
+/**
+ * @brief PPPoE mode socket
+ * @details It is the status that SOCKET0 is open as PPPoE mode. It is changed to SOCK_PPPoE in case of S0_CR=OPEN and S0_MR
+ * (P3:P0)=S0_MR_PPPoE.\n
+ * It is temporarily used at the PPPoE
+connection.
+ */
+#define SOCK_PPPOE			0x5F ///< pppoe socket
+
+// IP PROTOCOL
+#define IPPROTO_IP			0 ///< Dummy for IP
+#define IPPROTO_ICMP		   1 ///< Control message protocol
+#define IPPROTO_IGMP		   2 ///< Internet group management protocol
+#define IPPROTO_GGP			3 ///< GW^2 (deprecated)
+#define IPPROTO_TCP			6 ///< TCP
+#define IPPROTO_PUP			12 ///< PUP
+#define IPPROTO_UDP			17 ///< UDP
+#define IPPROTO_IDP			22 ///< XNS idp
+#define IPPROTO_ND			77 ///< UNOFFICIAL net disk protocol
+#define IPPROTO_RAW			255 ///< Raw IP packet
+
+
+
+/*----------------------------- W5100S !!Only!! Register values  -----------------------------*/
+
+//todo
+/* MODE2 register values */
+
+/**
+ * @brief	Clock select bit
+ * @details	With this bit, system clock can be selected to be 25Mhz or 100Mhz
+ * 1: 25Mhz
+ * 0: 100Mhz (default)
+ */
+#define MR2_CLKSEL				(1<<7)
+
+/**
+ * @brief	Interrupt pin enable bit
+ * @details	This bit enables interrupt.
+ * 1: Enable interrupt
+ * 0: Disable interrupt
+ */
+#define MR2_G_IEN				(1<<6)
+
+
+/**
+ * @brief	No TCP Reset Packet send
+ * @details This bit prevents sending reset packet.
+ * 1: Block TCP reset packet send
+ * 0: TCP Reset packet send
+ */
+#define MR2_NOTCPRST			(1<<5)
+
+/**
+ * @brief	Unreachable Packet Send Block bit
+ * @details	This bit prevents sending Destination Port Unreachable Packet.
+ * 1: Block Destination Port Unreachable Packet Send
+ * 0: Destination Port Unreachable Packet Send
+ */
+#define MR2_UDPURB				(1<<4)
+
+/**
+ * @brief Wake On LAN
+ * @details This bit enables WOL packet to be received.
+ * 1: WOL packet can be received.
+ * 0: WOL packet cannot be received.
+ */
+#define MR2_WOL					(1<<3)
+
+/**todo
+ * @brief MACRAW No Size Check
+ * @details
+ */
+#define MR2_MNOSCHK				(1<<2)
+
+/**
+ * @brief	UDP force ARP
+ * @details This bit can enables to force ARP for each send command.
+ * 1: UDP Force ARP Enable
+ * 0: UDP Force ARP Disable.
+ *
+ */
+#define MR2_UDPFARP				(1<<1)
+
+/**todo
+ * @brief	Skip SRC Hardware Address
+ * @details	This bit can enables to receive without checking the hardware address of the peer.
+ * 1:
+ */
+#define MR2_SSRCHA				(1<<0)
+
+
+
+/* Common interrupt register 2 values */
+
+/**todo
+ * @brief magic packet
+ * @details
+ */
+#define IR2_MGC				(1<<1)
+
+/**todo
+ * @brief Magic packet interrupt mask bit
+ * @details If this bit is set, each socket interrupt is enabled.
+ */
+#define IMR2_MGC			(1<<1)
+
+/**todo
+ * @brief
+ * @details
+ */
+//#define IR2_MGD				(1<<1) /* Reserved */
+
+
+/* PHY status register 0 values */
+
+/**todo
+ * @brief Ethernet CABLE OFF Signal
+ * @details
+ */
+#define PHYSR_CABOFF				(1<<7)
+
+/**todo
+ * @brief
+ * @details
+ */
+#define PHYSR_MD2				(1<<5)
+
+/**todo
+ * @brief
+ * @details
+ */
+#define PHYSR_MD1				(1<<4)
+
+/**todo
+ * @brief
+ * @details
+ */
+#define PHYSR_MD0				(1<<3)
+
+/**todo
+ * @brief
+ * @details
+ */
+#define PHYSR_DUP				(1<<2)
+
+/**todo
+ * @brief
+ * @details
+ */
+#define PHYSR_SPD				(1<<1)
+
+/**todo
+ * @brief LINKDONE register
+ * @details If 1 Linked successfully, if 0 no link
+ */
+#define PHYSR_LNK				(1<<0)
+
+
+/* PHY status register 10 values */
+
+/**
+ * @brieftodo
+ * @details
+ */
+#define PHYSR1_RXPG				(1<<2)
+
+/**
+ * @brieftodo
+ * @details
+ */
+#define PHYSR1_LPI				(1<<1)
+
+/**
+ * @brieftodo
+ * @details
+ */
+#define PHYSR1_CLDN				(1<<0)
+
+#define PHYCR_AUTONEGO_ENABLE	(0<<2)
+#define PHYCR_AUTONEGO_DISABLE	(1<<2)
+
+#define PHYCR_SPD_10			(1<<1)
+#define PHYCR_SPD_100			(0<<1)
+
+#define PHYCR_HALF_DUP			(1<<0)
+#define PHYCR_FULL_DUP			(0<<0)
+
+#define PHYCR1_RST				(0<<0)
+
+#define	PHYCR1_PWDN_ENABLE		(1<<5)
+#define	PHYCR1_PWDN_DISABLE		(0<<5)
+
+
+/* Socket n MODE register 2 values */
+
+/**
+ * @brief Broadcast Blocking bit in MACRAW mode
+ * @details In MACRAW mode, this bit is set to ????to block the broadcast packet.
+ */
+#define Sn_MR2_MBBLK  			(1<<6)
+
+/**
+ * @brief Multicast Blocking bit in MACRAW mode
+ * @details In MACRAW mode, this bit is set to ????to block the multicast packet.
+ */
+#define Sn_MR2_MMBLK  			(1<<5)
+
+/**
+ * @brief IPv6 packet Blocking bit in MACRAW mode
+ * @details In MACRAW mode, this bit is set to ????to block the IPv6 packet.
+ */
+#define Sn_MR2_IPV6BLK  		(1<<4)
+
+
+/**
+ * @brief Broadcast Blocking bit in UDP mode
+ * @details In UDP mode, this bit is set to ????to block the broadcast packet.
+ */
+#define Sn_MR2_UBBLK			(1<<1)
+
+
+/**
+ * @brief TCP Force PSH bit
+ * @details When the SOCKET transmits data in TCP mode, PSH Flag is set to all packets.
+ */
+#define Sn_MR2_FPSH			Sn_MR2_UBBLK
+
+/**
+ * @brief Unicast Blocking bit in UDP mode
+ * @details In UDP mode, this bit is set to ????to block the Unicast packet.
+ */
+#define Sn_MR2_UUBLK			(1<<0)
+
+/*----------------------------For PHY Control-------------------------------*/
+
+/********************/
+/* Register Address */
+/********************/
+
+//Basic mode control register, basic register
+#define PHYMDIO_BMCR				0x00
+
+//Basic mode status register, basic register
+#define PHYMDIO_BMSR				0x01
+
+//--------------------------------------Not used-------------------------------------------//
+////PHY identifier register 1, extended register
+//#define PHY_IDR1				0x02	//not used
+//
+////PHY identifier register 2, extended register
+//#define PHY_IDR2				0x03	//not used
+//
+////Auto-negotiation advertisement register, extended register
+//#define PHY_ANAR				0x04	//not used
+//
+////Auto-negotiation link partner ability register, extended register
+//#define PHY_ANLPAR				0x05	//not used
+//
+////Auto-negotiation expansion register, extended register
+//#define PHY_ANER				0x06	//not used
+//
+////Auto-negotiation next page transmit
+//#define PHY_ANNP				0x07	//not used
+//
+////Auto-negotiation link partner of the next page receive
+//#define PHY_ANLPNP				0x08	//not used
+//
+////MMD access control register
+//#define PHY_REGCR				0x09	//not used
+//
+////MMD access address data register
+//#define PHY_ADDAR				0x0e	//not used
+//--------------------------------------Not used-------------------------------------------//
+
+/********************/
+/* Bit definitions  */
+/********************/
+
+//For BMCR register
+#define BMCR_RESET				(1<<15)
+#define BMCR_MLOOPBACK			(1<<14)
+#define BMCR_SPEED				(1<<13)
+#define BMCR_AUTONEGO			(1<<12)
+#define BMCR_PWDN				(1<<11)
+#define BMCR_ISOLATE			(1<<10)
+#define BMCR_RSTNEGO			(1<<9)
+#define BMCR_DUP				(1<<8)
+#define BMCR_COLTEST			(1<<7)
+
+//For BMSR register
+#define BMSR_AUTONEGO_COMPL		(1<<5)
+#define BMSR_REMOTE_FAULT		(1<<4)
+#define BMSR_LINK_STATUS		(1<<2)
+#define BMSR_JAB_DETECT			(1<<1)
+#define EXTENDED_CAPA			(1<<0)
+
+//--------------------------------------Not used-------------------------------------------//
+////For ANAR register
+//#define ANAR_NP					(1<<15)
+//#define ANAR_ACK				(1<<14)
+//#define ANAR_RF					(1<<13)
+//#define ANAR_ASM				(3<<10)
+//#define ANAR_T4					(1<<9)
+//#define ANAR_TX_FD				(1<<8)
+//#define ANAR_TX_HD				(1<<7)
+//#define ANAR_10_FD				(1<<6)
+//#define ANAR_10_HD				(1<<5)
+//#define ANAR_SELECTOR			(0x1F<<0)
+//
+////For ANAR register
+//#define ANLPAR_NP				(1<<15)
+//#define ANLPAR_ACK				(1<<14)
+//#define ANLPAR_RF				(1<<13)
+//#define ANLPAR_LP_DIR			(1<<11)
+//#define ANLPAR_PAUSE			(1<<10)
+//#define ANLPAR_T4				(1<<9)
+//#define ANLPAR_TX_FD			(1<<8)
+//#define ANLPAR_TX_HD			(1<<7)
+//#define ANLPAR_10_FD			(1<<6)
+//#define ANLPAR_10_HD			(1<<5)
+//#define ANLPAR_SELECTOR			(0x1F<<0)
+
+/**/
+/* MDIO register*/
+//PCS_CTL_1			|		PCS control 1 register
+//PCS_STS_1			|		PCS status 1 register
+//EEE_ABILITY  		|		EEE capability register
+//WAKE_ER_CNTR		|		EEE wake error counter
+//EEE_ADVR 			|		EEE Advertisement register
+//EEE_LPAR 			|		EEE link partner ability register
+
+//--------------------------------------Not used-------------------------------------------//
+
+/********************/
+/*Functions for PHY */
+/********************/
+//todo move this definition to bit area
+#define PHYACR_READ			0x02
+#define PHYACR_WRITE		0x01
+
+
+
+
+/**
+ * @brief Enter a critical section
+ *
+ * @details It is provided to protect your shared code which are executed without distribution. \n \n
+ *
+ * In non-OS environment, It can be just implemented by disabling whole interrupt.\n
+ * In OS environment, You can replace it to critical section api supported by OS.
+ *
+ * \sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
+ * \sa WIZCHIP_CRITICAL_EXIT()
+ */
+#define WIZCHIP_CRITICAL_ENTER()    WIZCHIP.CRIS._enter()
+
+#ifdef _exit
+#undef _exit
+#endif
+
+/**
+ * @brief Exit a critical section
+ *
+ * @details It is provided to protect your shared code which are executed without distribution. \n\n
+ *
+ * In non-OS environment, It can be just implemented by disabling whole interrupt. \n
+ * In OS environment, You can replace it to critical section api supported by OS.
+ *
+ * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
+ * @sa WIZCHIP_CRITICAL_ENTER()
+ */
+#define WIZCHIP_CRITICAL_EXIT()     WIZCHIP.CRIS._exit()
+
+
+
+////////////////////////
+// Basic I/O Function //
+////////////////////////
+//
+//M20150601 :  uint16_t AddrSel --> uint32_t AddrSel
+//
+/**
+ * @ingroup Basic_IO_function_W5100S 
+ * @brief It reads 1 byte value from a register.
+ * @param AddrSel Register address
+ * @return The value of register
+ */
+uint8_t  WIZCHIP_READ (uint32_t AddrSel);
+
+/**
+ * @ingroup Basic_IO_function_W5100S
+ * @brief It writes 1 byte value to a register.
+ * @param AddrSel Register address
+ * @param wb Write data
+ * @return void
+ */
+void     WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
+
+/**
+ * @ingroup Basic_IO_function_W5100S
+ * @brief It reads sequence data from registers.
+ * @param AddrSel Register address
+ * @param pBuf Pointer buffer to read data
+ * @param len Data length
+ */
+void     WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
+
+/**
+ * @ingroup Basic_IO_function_W5100S
+ * @brief It writes sequence data to registers.
+ * @param AddrSel Register address
+ * @param pBuf Pointer buffer to write data
+ * @param len Data length
+ */
+void     WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, uint16_t len);
+
+
+/////////////////////////////////
+// Common Register IO function //
+/////////////////////////////////
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set Mode Register
+ * @param (uint8_t)mr The value to be set.
+ * @sa getMR()
+ */
+#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
+   #define setMR(mr) 	WIZCHIP_WRITE(MR,mr)
+#else
+   #define setMR(mr)    (*((uint8_t*)MR) = mr)
+#endif
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get @ref MR.
+ * @return uint8_t. The value of Mode register.
+ * @sa setMR()
+ */
+#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
+   #define getMR() 		WIZCHIP_READ(MR)
+#else
+   #define getMR()      (*(uint8_t*)MR)
+#endif
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set @ref GAR.
+ * @param (uint8_t*)gar Pointer variable to set gateway IP address. It should be allocated 4 bytes.
+ * @sa getGAR()
+ */
+#define setGAR(gar) \
+		WIZCHIP_WRITE_BUF(GAR,gar,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get @ref GAR.
+ * @param (uint8_t*)gar Pointer variable to get gateway IP address. It should be allocated 4 bytes.
+ * @sa setGAR()
+ */
+#define getGAR(gar) \
+		WIZCHIP_READ_BUF(GAR,gar,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set @ref SUBR.
+ * @param (uint8_t*)subr Pointer variable to set subnet mask address. It should be allocated 4 bytes.
+ * @note If subr is null pointer, set the backup subnet to SUBR. \n
+ *       If subr is 0.0.0.0, back up SUBR and clear it. \n
+ *       Otherwize, set subr to SUBR
+ * @sa getSUBR()
+ */
+#define setSUBR(subr) \
+      WIZCHIP_WRITE_BUF(SUBR,subr,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get @ref SUBR.
+ * @param (uint8_t*)subr Pointer variable to get subnet mask address. It should be allocated 4 bytes.
+ * @sa setSUBR()
+ */
+#define getSUBR(subr) \
+		WIZCHIP_READ_BUF(SUBR, subr, 4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set @ref SHAR.
+ * @param (uint8_t*)shar Pointer variable to set local MAC address. It should be allocated 6 bytes.
+ * @sa getSHAR()
+ */
+#define setSHAR(shar) \
+		WIZCHIP_WRITE_BUF(SHAR, shar, 6)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get @ref SHAR.
+ * @param (uint8_t*)shar Pointer variable to get local MAC address. It should be allocated 6 bytes.
+ * @sa setSHAR()
+ */
+#define getSHAR(shar) \
+		WIZCHIP_READ_BUF(SHAR, shar, 6)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set @ref SIPR.
+ * @param (uint8_t*)sipr Pointer variable to set local IP address. It should be allocated 4 bytes.
+ * @sa getSIPR()
+*/
+#define setSIPR(sipr) \
+		WIZCHIP_WRITE_BUF(SIPR, sipr, 4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get @ref SIPR.
+ * @param (uint8_t*)sipr Pointer variable to get local IP address. It should be allocated 4 bytes.
+ * @sa setSIPR()
+ */
+#define getSIPR(sipr) \
+		WIZCHIP_READ_BUF(SIPR, sipr, 4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref IR register
+ * @param (uint8_t)ir Value to set \ref IR register.
+ * @sa getIR()
+ */
+#define setIR(ir) \
+		WIZCHIP_WRITE(IR, (ir & 0xE0)) //peter 2016.11.07 unreachable interrupt bit added
+		//WIZCHIP_WRITE(IR, (ir & 0xA0))
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref IR register
+ * @return uint8_t. Value of \ref IR register.
+ * @sa setIR()
+ */
+#define getIR() \
+		(WIZCHIP_READ(IR) & 0xE0) //peter 2016.11.07 unreachable interrupt bit added
+		//(WIZCHIP_READ(IR) & 0xA0)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref _IMR_ register
+ * @param (uint8_t)imr Value to set @ref _IMR_ register.
+ * @sa getIMR()
+ */
+#define setIMR(imr) \
+		WIZCHIP_WRITE(_IMR_, imr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref _IMR_ register
+ * @return uint8_t. Value of @ref _IMR_ register.
+ * @sa setIMR()
+ */
+#define getIMR() \
+		WIZCHIP_READ(_IMR_)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref _RTR_ register
+ * @param (uint16_t)rtr Value to set @ref _RTR_ register.
+ * @sa getRTR()
+ */
+#define setRTR(rtr)   {\
+		WIZCHIP_WRITE(_RTR_,   (uint8_t)(rtr >> 8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1), (uint8_t) rtr); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref _RTR_ register
+ * @return uint16_t. Value of @ref _RTR_ register.
+ * @sa setRTR()
+ */
+#define getRTR() \
+		(((uint16_t)WIZCHIP_READ(_RTR_) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref _RCR_ register
+ * @param (uint8_t)rcr Value to set @ref _RCR_ register.
+ * @sa getRCR()
+ */
+#define setRCR(rcr) \
+		WIZCHIP_WRITE(_RCR_, rcr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref _RCR_ register
+ * @return uint8_t. Value of @ref _RCR_ register.
+ * @sa setRCR()
+ */
+#define getRCR() \
+		WIZCHIP_READ(_RCR_)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref RMSR register
+ * @sa getRMSR()
+ */
+#define setRMSR(rmsr)   \
+      WIZCHIP_WRITE(RMSR,rmsr) // Receicve Memory Size
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref RMSR register
+ * @return uint8_t. Value of @ref RMSR register.
+ * @sa setRMSR()
+ */
+ #define getRMSR()   \
+      WIZCHIP_READ(RMSR) // Receicve Memory Size
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref TMSR register
+ * @sa getTMSR()
+ */
+#define setTMSR(tmsr)   \
+      WIZCHIP_WRITE(TMSR,tmsr) // Receicve Memory Size
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref TMSR register
+ * @return uint8_t. Value of @ref TMSR register.
+ * @sa setTMSR()
+ */
+#define getTMSR()	\
+	WIZCHIP_READ(TMSR)
+
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PATR register
+ * @return uint16_t. Value to set \ref PATR register
+ */
+#define getPATR() \
+		(((uint16_t)WIZCHIP_READ(PATR) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(PATR,1)))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PPPALGO register
+ * @return uint8_t. Value to set \ref PPPALGO register
+ */
+#define getPPPALGO() \
+		WIZCHIP_READ(PPPALGO)
+
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PTIMER register
+ * @param (uint8_t)ptimer Value to set \ref PTIMER register.
+ * @sa getPTIMER()
+ */
+#define setPTIMER(ptimer) \
+		WIZCHIP_WRITE(PTIMER, ptimer)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PTIMER register
+ * @return uint8_t. Value of @ref PTIMER register.
+ * @sa setPTIMER()
+ */
+#define getPTIMER() \
+		WIZCHIP_READ(PTIMER)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PMAGIC register
+ * @param (uint8_t)pmagic Value to set @ref PMAGIC register.
+ * @sa getPMAGIC()
+ */
+#define setPMAGIC(pmagic) \
+		WIZCHIP_WRITE(PMAGIC, pmagic)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PMAGIC register
+ * @return uint8_t. Value of @ref PMAGIC register.
+ * @sa setPMAGIC()
+ */
+#define getPMAGIC() \
+		WIZCHIP_READ(PMAGIC)
+
+
+//todo Functions for W5100S
+
+/*----------------------------------------------------------------------*/
+/*								W5100S only								*/
+/*----------------------------------------------------------------------*/
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref IR2 register
+ * @param (uint8_t)ir2 Value to set @ref IR2 register.
+ * @sa getIR2()
+ */
+#define setIR2(ir2) \
+		WIZCHIP_WRITE(IR2, ir2)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref IR2 register
+ * @return uint8_t. Value of @ref IR2 register.
+ * @sa setIR2()
+ */
+#define getIR2() \
+		WIZCHIP_READ(IR2)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref IMR2 register
+ * @param (uint8_t)imr2 Value to set @ref IMR2 register.
+ * @sa setIMR2()
+ */
+#define setIMR2(imr2) \
+		WIZCHIP_WRITE(IMR2,imr2)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref IMR2 register
+ * @return uint8_t. Value of @ref IMR2 register.
+ * @sa getIMR2()
+ */
+#define getIMR2() \
+		WIZCHIP_READ(IMR2)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref UIPR(Unreachable IP Address Register) registers
+ * @param (uint8_t*)uipr Value to set @ref UIPR registers.
+ * @sa setUIPR()
+ */
+#define setUIPR(uipr) \
+		WIZCHIP_WRITE_BUF(UIPR,uipr,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref UIPR(Unreachable IP Address Register) registers
+ * @param (uint8_t*)uipr Value to get @ref UIPR registers
+ * @sa setUIPR()
+ */
+#define getUIPR(uipr) \
+		WIZCHIP_READ_BUF(UIPR,uipr,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref UPORTR(Unreachable Port Address Register) register
+ * @param (uint16_t)uportr Value to set @ref UPORTR register.
+ * @sa getUPORTR()
+ */
+#define	setUPORTR(uportr) {\
+		WIZCHIP_WRITE(UPORTR, (uint8_t)(uportr >> 8)); \
+		WIZCHIP_WRITE(UPORTR+1, (uint8_t) uportr); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref UPORTR(Unreachable Port Address Register) register
+ * @return uint16_t. Value of @ref UPORTR register.
+ * @sa setUPORTR()
+ */
+#define getUPORTR() \
+		(((uint16_t)WIZCHIP_READ(UPORTR) << 8) + WIZCHIP_READ(UPORTR+1))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref MR2 register
+ * @param (uint8_t)mr2 Value to set @ref MR2 registers.
+ * @sa getMR2()
+ */
+#define setMR2(mr2) \
+		WIZCHIP_WRITE(MR2,mr2)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref MR2 register
+ * @return uint8_t. Value of @ref MR2 register.
+ * @sa setMR2()
+ */
+#define getMR2() \
+		WIZCHIP_READ(MR2)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHAR registers
+ * @param (uint8_t*)phar Value to set @ref PHAR registers.
+ * @sa getPHAR()
+ */
+#define setPHAR(phar) \
+		WIZCHIP_WRITE_BUF(PHAR,phar,6)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHAR registers
+ * @param (uint8_t*)phar Pointer variable to get @ref PHAR registers.
+ * @sa setPHAR()
+ */
+#define getPHAR(phar) \
+		WIZCHIP_READ_BUF(PHAR,phar,6)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PSIDR register
+ * @param (uint16_t)psidr Value to set @ref PSIDR register.
+ * @sa getPSIDR()
+ */
+#define setPSIDR(psidr) {\
+		WIZCHIP_WRITE(PSIDR, (uint8_t)(psidr >> 8)); \
+		WIZCHIP_WRITE(PSIDR+1, (uint8_t) psidr); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PSIDR register
+ * @return uint16_t. Value of @ref PSIDR register.
+ * @sa setPSIDR()
+ */
+#define getPSIDR() \
+		(((uint16_t)WIZCHIP_READ(PSIDR) << 8) + WIZCHIP_READ(PSIDR+1))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PMRUR register
+ * @param (uint16_t)pmrur Value to set @ref PMRUR register.
+ * @sa getPMRUR()
+ */
+#define setPMRUR(pmrur) {\
+		WIZCHIP_WRITE(PMRUR, (uint8_t)(pmrur >> 8)); \
+		WIZCHIP_WRITE(PMRUR+1, (uint8_t) pmrur); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PMRUR register
+ * @return uint16_t. Value of @ref PMRUR register.
+ * @sa setPMRUR()
+ */
+#define getPMRUR() \
+		(((uint16_t)WIZCHIP_READ(PMRUR) << 8) + WIZCHIP_READ(PMRUR+1))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYSR register
+ * @return uint8_t. Value of @ref PHYSR register.
+ * @sa setPHYSR()
+ */
+#define getPHYSR()	\
+		WIZCHIP_READ(PHYSR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYSR1 register
+ * @return uint8_t. Value of @ref PHYSR1 register.
+ * @sa setPHYSR1()
+ */
+#define getPHYSR1()	\
+		WIZCHIP_READ(PHYSR1)
+
+/**
+ * For internal uses
+ * The address of the PHY is fixed as "0x0A".
+ */
+#define getPHYAR() \
+		WIZCHIP_READ(PHYAR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYRAR register
+ * @return uint8_t. Value of @ref PHYRAR register.
+ * @sa setPHYRAR()
+ */
+#define getPHYRAR() \
+		WIZCHIP_READ(PHYRAR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHYRR register
+ * @param (uint8_t)phyrar Value to set @ref PHYRR register.
+ * @sa getPHYRR()
+ */
+#define setPHYRR(phyrar) \
+		WIZCHIP_WRITE(PHYRAR, phyrar)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYDIR register
+ * @return uint16_t. Value of @ref PHYDIR register.
+ * @sa setPHYRAR()
+ */
+//read the value of the phy data input register
+#define getPHYDIR() \
+		(((uint16_t)WIZCHIP_READ(PHYDIR+1) << 8) + WIZCHIP_READ(PHYDIR))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHYDIR register
+ * @param (uint16_t)phydir Value to set @ref PHYDIR register.
+ * @sa getPHYDIR()
+ */
+//write the value of the phy data input register
+#define setPHYDIR(phydir) {\
+		WIZCHIP_WRITE(PHYDIR+1, (uint8_t)(phydir >> 8)); \
+		WIZCHIP_WRITE(PHYDIR, (uint8_t) phydir); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYDOR register
+ * @return uint16_t. Value of @ref PHYDOR register.
+ * @sa setPHYDOR()
+ */
+//read the value of the phy data output register
+#define getPHYDOR()	\
+		(((uint16_t)WIZCHIP_READ(PHYDOR+1) << 8) + WIZCHIP_READ(PHYDOR))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHYDOR register
+ * @param (uint16_t)phydor Value to set @ref PHYDOR register.
+ * @sa getPHYDOR()
+ */
+//write the value of the phy data output register
+#define setPHYDOR(phydor) {\
+		WIZCHIP_WRITE(PHYDOR, (uint8_t)(phydor >> 8)); \
+		WIZCHIP_WRITE(PHYDOR+1, (uint8_t) phydor); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYACR register
+ * @return uint8_t. Value of @ref PHYACR register.
+ * @sa setPHYACR()
+ */
+//read the value of the phy action register ***This register will be cleared automatically***
+#define getPHYACR() \
+		WIZCHIP_READ(PHYACR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHYACR register
+ * @param (uint8_t)phyacr Value to set @ref PHYACR register.
+ * @sa getPHYACR()
+ */
+//write the value of the phy action register
+#define setPHYACR(phyacr)	\
+		WIZCHIP_WRITE(PHYACR,phyacr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHYDIVR register
+ * @param (uint8_t)phydivr Value to set @ref PHYDIVR register.
+ * @sa getPHYDIVR()
+ */
+#define setPHYDIVR(phydivr)	\
+		WIZCHIP_WRITE(PHYDIVR, phydivr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYDIVR register
+ * @return uint8_t. Value of @ref PHYDIVR register.
+ * @sa setPHYDIVR()
+ */
+#define getPHYDIVR()	\
+		WIZCHIP_READ(PHYDIVR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHYCR0 register
+ * @param (uint8_t)phych0 Value to set @ref PHYCR0 register.
+ * @sa getPHYCR0()
+ */
+#define setPHYCR0(phych0)		\
+		WIZCHIP_WRITE(PHYCR0,phych0)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYCR0 register
+ * @return uint8_t. Value of @ref PHYCR0 register.
+ * @sa setPHYCR0()
+ */
+#define getPHYCR0()	\
+		WIZCHIP_READ(PHYCR0)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PHYCR1 register
+ * @param (uint8_t)phycr1 Value to set @ref PHYCR1 register.
+ * @sa getPHYCR1()
+ */
+#define setPHYCR1(phycr1)	\
+		WIZCHIP_WRITE(PHYCR1,phycr1)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PHYCR1 register
+ * @return uint8_t. Value of @ref PHYCR1 register.
+ * @sa setPHYCR1()
+ */
+#define getPHYCR1() \
+		WIZCHIP_READ(PHYCR1)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref SLCR register
+ * @param (uint8_t)rqcr Value to set @ref SLCR register.
+ * @sa getSLCR()
+ */
+#define setSLCR(rqcr)	\
+		WIZCHIP_WRITE(SLCR, rqcr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref RQCR register
+ * @return uint8_t. Value of @ref RQCR register.
+ * @sa setRQCR()
+ */
+#define getSLCR()	\
+		WIZCHIP_READ(RQCR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref SLRTR register
+ * @param (uint16_t)slrtr Value to set @ref SLRTR register.
+ * @sa getSLRTR()
+ */
+#define setSLRTR(slrtr)	\
+		WIZCHIP_WRITE(SLRTR, (uint8_t)(slrtr >> 8)); \
+		WIZCHIP_WRITE(SLRTR+1, (uint8_t) slrtr); \
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref SLRTR register
+ * @return uint16_t. Value of @ref SLRTR register.
+ * @sa setSLRTR()
+ */
+#define getSLRTR()	\
+		(((uint16_t)WIZCHIP_READ(SLRTR) << 8) + WIZCHIP_READ(SLRTR+1))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref SLRCR register
+ * @param (uint8_t)slrcr Value to set @ref SLRCR register.
+ * @sa getSLRCR()
+ */
+#define setSLRCR(slrcr)	\
+		WIZCHIP_WRITE(SLRCR,slrcr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref SLRCR register
+ * @return uint8_t. Value of @ref SLRCR register.
+ * @sa setSLRCR()
+ */
+#define getSLRCR()	\
+		WIZCHIP_READ(SLRCR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref SLPIPR registers
+ * @param (uint8_t*)slpipr Values to set @ref SLPIPR registers.
+ * @sa getSLPIPR()
+ */
+#define setSLPIPR(slpipr)	\
+		WIZCHIP_WRITE_BUF(SLPIPR,slpipr,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref SLPIPR registers
+ * @param (uint8_t*)slpipr Values to get @ref SLPIPR registers.
+ * @sa getSLPIPR()
+ */
+#define getSLPIPR(slpipr)	\
+		WIZCHIP_READ_BUF(SLPIPR,slpipr,4)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref SLPHAR registers
+ * @param (uint8_t*)slphar Values to set @ref SLPHAR registers.
+ * @sa getSLPHAR()
+ */
+#define setSLPHAR(slphar) \
+		WIZCHIP_WRITE_BUF(SLPHAR,slphar,6)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref SLPHAR registers
+ * @param (uint8_t*)slphar Values to get @ref SLPHAR registers.
+ * @sa getSLPHAR()
+ */
+#define getSLPHAR(slphar) \
+		WIZCHIP_READ_BUF(SLPHAR,slphar,6)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PINGSEQR register
+ * @param (uint16_t)pingseqr Value to set @ref PINGSEQR register.
+ * @sa getPINGSEQR()
+ */
+#define setPINGSEQR(pingseqr) {\
+		WIZCHIP_WRITE(PINGSEQR, (uint8_t)(pingseqr >> 8)); \
+		WIZCHIP_WRITE(PINGSEQR+1, (uint8_t) pingseqr); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PINGSEQR register
+ * @return uint16_t. Value of @ref PINGSEQR register.
+ * @sa setPINGSEQR()
+ */
+#define getPINGSEQR() \
+		(((uint16_t)WIZCHIP_READ(PINGSEQR) << 8) + WIZCHIP_READ(PINGSEQR+1))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref PINGIDR register
+ * @param (uint16_t)pingidr Value to set @ref PINGIDR register.
+ * @sa getPINGIDR()
+ */
+#define setPINGIDR(pingidr) {\
+		WIZCHIP_WRITE(PINGIDR, (uint8_t)(pingidr >> 8)); \
+		WIZCHIP_WRITE(PINGIDR+1, (uint8_t) pingidr); \
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref PINGIDR register
+ * @return uint16_t. Value of @ref PINGIDR register.
+ * @sa setPINGIDR()
+ */
+#define getPINGIDR()	\
+		(((uint16_t)WIZCHIP_READ(PINGIDR) << 8) + WIZCHIP_READ(PINGIDR+1))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref SLIMR register
+ * @param (uint8_t)slimr Value to set @ref SLIMR register.
+ * @sa getSLIMR()
+ */
+#define setSLIMR(slimr)	\
+		WIZCHIP_WRITE(SLIMR, slimr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref SLIMR register
+ * @return uint8_t. Value of @ref SLIMR register.
+ * @sa setSLIMR()
+ */
+#define getSLIMR()	\
+		WIZCHIP_READ(SLIMR)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref SLIR register
+ * @param (uint8_t)slir Value to set @ref SLIR register.
+ * @sa getSLIMR()
+ */
+#define setSLIR(slir)	\
+		WIZCHIP_WRITE(SLIR, slir)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref SLIMR register
+ * @return uint8_t. Value of @ref SLIMR register.
+ * @sa setSLIMR()
+ */
+#define getSLIR()	\
+		WIZCHIP_READ(SLIR)
+
+/*Hidden functions for W5100S*/
+#define setDBGOUT(dbgout) 	{\
+		WIZCHIP_WRITE(DBGOUT,(uint8_t)(dbgout >> 16));	\
+		WIZCHIP_WRITE(DBGOUT,(uint8_t)(dbgout >> 8));	\
+		WIZCHIP_WRITE(DBGOUT,(uint8_t)(dbgout));		\
+	}
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref NICMAXCOLR register
+ * @param (uint8_t)nicmaxcolr Value to set @ref NICMAXCOLR register.
+ * @sa getNICMAXCOLR()
+ */
+#define setNICMAXCOLR(nicmaxcolr)	\
+		WIZCHIP_WRITE(NICMAXCOLR,nicmaxcolr)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref NICMAXCOLR register
+ * @return uint8_t. Value of @ref NICMAXCOLR register.
+ * @sa setNICMAXCOLR()
+ */
+#define getNICMAXCOLR()	\
+		WIZCHIP_READ(NICMAXCOLR)
+
+/*Clock lock/unlock*/
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief LOCK Chip Information
+ * @sa CHIPULLOCK()
+ */
+#define CHIPLOCK()	\
+		WIZCHIP_WRITE(CHIPLCKR,0xff)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Unlock Chip Information
+ * @sa CHIPLOCK()
+ */
+#define CHIPUNLOCK()	\
+		WIZCHIP_WRITE(CHIPLCKR,0xCE)
+
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief LOCK Chip Information
+ * @sa CHIPULLOCK()
+ */
+/*Network information lock/unlock*/
+#define NETLOCK()	\
+		WIZCHIP_WRITE(NETLCKR,0x3A)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Unlock Chip Information
+ * @sa CHIPLOCK()
+ */
+#define NETUNLOCK()	\
+		WIZCHIP_WRITE(NETLCKR,0xC5)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Lock PHYCR0,CR1 Information
+ * @sa CHIPULLOCK()
+ */
+/*PHY CR0,CR1 lock/unlock*/
+#define PHYLOCK()	\
+		WIZCHIP_WRITE(PHYLCKR,0xff)
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Lock PHYCR0,CR1 Information
+ * @sa CHIPULLOCK()
+ */
+#define PHYUNLOCK()	\
+		WIZCHIP_WRITE(PHYLCKR,0x53)
+
+/**
+ * @ingroup Version register_access_function_W5100SS
+ * @brief Get version information.
+ * @return uint16_t. It must be "0x51"
+ */
+#define getVER() \
+		(WIZCHIP_READ(VERR))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Get \ref TCNTR register
+ * @return uint16_t. Value of @ref TCNTR register.
+ * @sa setNTCNTR()
+ */
+/*Get 100us internal counter*/
+#define getTCNTR()	\
+		(((uint16_t)WIZCHIP_READ(TCNTR) << 8) + WIZCHIP_READ(TCNTR+1))
+
+/**
+ * @ingroup Common_register_access_function_W5100S
+ * @brief Set \ref TCNTR register
+ * @param (uint8_t)
+  Value to set @ref TCNTR register.
+ * @sa getTCNTCLKR()
+ */
+/*Reset 100us internal counter(TCNTR)*/
+#define setTCNTCLKR(var)	\
+		WIZCHIP_WRITE(TCNTCLKR, var)
+
+/*w5100s only end*/
+
+
+
+
+
+///////////////////////////////////
+// Socket N register I/O function //
+///////////////////////////////////
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_MR register
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ * @param mr Value to set @ref Sn_MR
+ * @sa getSn_MR()
+ */
+#define setSn_MR(sn, mr) \
+		WIZCHIP_WRITE(Sn_MR(sn),mr)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_MR register
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b> expect <b>bit 4</b>.
+ * @return Value of @ref Sn_MR.
+ * @sa setSn_MR()
+ */
+#define getSn_MR(sn) \
+	WIZCHIP_READ(Sn_MR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_CR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)cr Value to set @ref Sn_CR
+ * @sa getSn_CR()
+ */
+#define setSn_CR(sn, cr) \
+		WIZCHIP_WRITE(Sn_CR(sn), cr)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_CR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_CR.
+ * @sa setSn_CR()
+ */
+#define getSn_CR(sn) \
+		WIZCHIP_READ(Sn_CR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_IR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)ir Value to set @ref Sn_IR
+ * @sa getSn_IR()
+ */
+#define setSn_IR(sn, ir) \
+		WIZCHIP_WRITE(Sn_IR(sn), ir)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_IR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_IR.
+ * @sa setSn_IR()
+ */
+#define getSn_IR(sn) \
+		WIZCHIP_READ(Sn_IR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_SR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_SR.
+ */
+#define getSn_SR(sn) \
+		WIZCHIP_READ(Sn_SR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_PORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)port Value to set @ref Sn_PORT.
+ * @sa getSn_PORT()
+ */
+#define setSn_PORT(sn, port)  { \
+		WIZCHIP_WRITE(Sn_PORT(sn),   (uint8_t)(port >> 8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1), (uint8_t) port); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_PORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_PORT.
+ * @sa setSn_PORT()
+ */
+#define getSn_PORT(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_PORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_PORT(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_DHAR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dhar Pointer variable to set socket n destination hardware address. It should be allocated 6 bytes.
+ * @sa getSn_DHAR()
+ */
+#define setSn_DHAR(sn, dhar) \
+		WIZCHIP_WRITE_BUF(Sn_DHAR(sn), dhar, 6)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_DHAR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dhar Pointer variable to get socket n destination hardware address. It should be allocated 6 bytes.
+ * @sa setSn_DHAR()
+ */
+#define getSn_DHAR(sn, dhar) \
+		WIZCHIP_READ_BUF(Sn_DHAR(sn), dhar, 6)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_DIPR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dipr Pointer variable to set socket n destination IP address. It should be allocated 4 bytes.
+ * @sa getSn_DIPR()
+ */
+#define setSn_DIPR(sn, dipr) \
+		WIZCHIP_WRITE_BUF(Sn_DIPR(sn), dipr, 4)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_DIPR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t*)dipr Pointer variable to get socket n destination IP address. It should be allocated 4 bytes.
+ * @sa SetSn_DIPR()
+ */
+#define getSn_DIPR(sn, dipr) \
+		WIZCHIP_READ_BUF(Sn_DIPR(sn), dipr, 4)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_DPORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)dport Value to set @ref Sn_DPORT
+ * @sa getSn_DPORT()
+ */
+#define setSn_DPORT(sn, dport) { \
+		WIZCHIP_WRITE(Sn_DPORT(sn),   (uint8_t) (dport>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1), (uint8_t)  dport); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_DPORT register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_DPORT.
+ * @sa setSn_DPORT()
+ */
+#define getSn_DPORT(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_DPORT(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_DPORT(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_MSSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)mss Value to set @ref Sn_MSSR
+ * @sa setSn_MSSR()
+ */
+#define setSn_MSSR(sn, mss) { \
+		WIZCHIP_WRITE(Sn_MSSR(sn),   (uint8_t)(mss>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1), (uint8_t) mss); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_MSSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_MSSR.
+ * @sa setSn_MSSR()
+ */
+#define getSn_MSSR(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_MSSR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_MSSR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_PROTO register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)proto Value to set \ref Sn_PROTO
+ * @sa getSn_PROTO()
+ */
+#define setSn_PROTO(sn, proto) \
+		WIZCHIP_WRITE(Sn_PROTO(sn), proto)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_PROTO register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_PROTO.
+ * @sa setSn_PROTO()
+ */
+#define getSn_PROTO(sn) \
+		WIZCHIP_READ(Sn_PROTO(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_TOS register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)tos Value to set @ref Sn_TOS
+ * @sa getSn_TOS()
+ */
+#define setSn_TOS(sn, tos) \
+		WIZCHIP_WRITE(Sn_TOS(sn), tos)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_TOS register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @return uint8_t. Value of Sn_TOS.
+ * @sa setSn_TOS()
+ */
+#define getSn_TOS(sn) \
+		WIZCHIP_READ(Sn_TOS(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_TTL register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @param (uint8_t)ttl Value to set @ref Sn_TTL
+ * @sa getSn_TTL()
+ */
+#define setSn_TTL(sn, ttl) \
+		WIZCHIP_WRITE(Sn_TTL(sn), ttl)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_TTL register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @return uint8_t. Value of @ref Sn_TTL.
+ * @sa setSn_TTL()
+ */
+#define getSn_TTL(sn) \
+		WIZCHIP_READ(Sn_TTL(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_RXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_ </b>.
+ * @param (uint8_t)rxmemsize Value to set \ref Sn_RXMEM_SIZE
+ * @sa getSn_RXMEM_SIZE()
+ */
+#define  setSn_RXMEM_SIZE(sn, rxmemsize) \
+      WIZCHIP_WRITE(RMSR, (WIZCHIP_READ(RMSR) & ~(0x03 << (2*sn))) | (rxmemsize << (2*sn)))
+#define setSn_RXBUF_SIZE(sn,rxmemsize) setSn_RXMEM_SIZE(sn,rxmemsize)
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_RXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_RXMEM.
+ * @sa setSn_RXMEM_SIZE()
+ */
+#define  getSn_RXMEM_SIZE(sn) \
+      ((WIZCHIP_READ(RMSR) & (0x03 << (2*sn))) >> (2*sn))
+#define  getSn_RXBUF_SIZE(sn) getSn_RXMEM_SIZE(sn)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_TXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint8_t)txmemsize Value to set \ref Sn_TXMEM_SIZE
+ * @sa getSn_TXMEM_SIZE()
+ */
+#define setSn_TXMEM_SIZE(sn, txmemsize) \
+      WIZCHIP_WRITE(TMSR, (WIZCHIP_READ(TMSR) & ~(0x03 << (2*sn))) | (txmemsize << (2*sn)))
+#define  setSn_TXBUF_SIZE(sn, txmemsize) setSn_TXMEM_SIZE(sn,txmemsize)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_TXMEM_SIZE register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of @ref Sn_TXMEM_SIZE.
+ * @sa setSn_TXMEM_SIZE()
+ */
+#define  getSn_TXMEM_SIZE(sn) \
+      ((WIZCHIP_READ(TMSR) & (0x03 << (2*sn))) >> (2*sn))
+#define  getSn_TXBUF_SIZE(sn) getSn_TXMEM_SIZE(sn)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_TX_FSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_TX_FSR.
+ */
+uint16_t getSn_TX_FSR(uint8_t sn);
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_TX_RD register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_TX_RD.
+ */
+#define getSn_TX_RD(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_TX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_RD(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_TX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)txwr Value to set @ref Sn_TX_WR
+ * @sa GetSn_TX_WR()
+ */
+#define setSn_TX_WR(sn, txwr) { \
+		WIZCHIP_WRITE(Sn_TX_WR(sn),   (uint8_t)(txwr>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1), (uint8_t) txwr); \
+		}
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_TX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_TX_WR.
+ * @sa setSn_TX_WR()
+ */
+#define getSn_TX_WR(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_TX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_TX_WR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_RX_RSR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_RX_RSR.
+ */
+uint16_t getSn_RX_RSR(uint8_t sn);
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_RX_RD register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)rxrd Value to set @ref Sn_RX_RD
+ * @sa getSn_RX_RD()
+ */
+#define setSn_RX_RD(sn, rxrd) { \
+		WIZCHIP_WRITE(Sn_RX_RD(sn),   (uint8_t)(rxrd>>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1), (uint8_t) rxrd); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_RX_RD register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @regurn uint16_t. Value of @ref Sn_RX_RD.
+ * @sa setSn_RX_RD()
+ */
+#define getSn_RX_RD(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_RX_RD(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_RD(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_RX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)rxwr Value to set \ref Sn_RX_WR
+ * @sa getSn_RX_WR()
+ */
+#define setSn_RX_WR(sn, rxwr) { \
+		WIZCHIP_WRITE(Sn_RX_WR(sn),   (uint8_t)(rxwr>>8)); \
+	   WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1), (uint8_t) rxwr); \
+	}
+
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_RX_WR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_RX_WR.
+ */
+#define getSn_RX_WR(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_RX_WR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RX_WR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set @ref Sn_FRAGR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)frag Value to set \ref Sn_FRAGR
+ * @sa getSn_FRAG()
+ */
+#define setSn_FRAGR(sn, fragr) { \
+		WIZCHIP_WRITE(Sn_FRAGR(sn),  (uint8_t)(fragr >>8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_FRAGR(sn),1), (uint8_t) fragr); \
+	}
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get @ref Sn_FRAGR register
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of @ref Sn_FRAGR.
+ * @sa setSn_FRAG()
+ */
+#define getSn_FRAGR(sn) \
+		(((uint16_t)WIZCHIP_READ(Sn_FRAGR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_FRAGR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the max RX buffer size of socket sn
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Max buffer size
+ */
+#define getSn_RxMAX(sn) \
+		((uint16_t)(0x0001 << getSn_RXMEM_SIZE(sn)) << 10)
+
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the max TX buffer size of socket sn
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Max buffer size
+ */
+#define getSn_TxMAX(sn) \
+		((uint16_t)(0x0001 << getSn_TXMEM_SIZE(sn)) << 10)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the mask of socket sn RX buffer.
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Mask value
+ */
+#define getSn_RxMASK(sn) \
+		(getSn_RxMAX(sn) - 1)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the mask of socket sn TX buffer
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Mask value
+ */
+#define getSn_TxMASK(sn) \
+		(getSn_TxMAX(sn) - 1)
+
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the base address of socket sn RX buffer.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of Socket n RX buffer base address.
+ */
+uint32_t getSn_RxBASE(uint8_t sn);
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the base address of socket sn TX buffer.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of Socket n TX buffer base address.
+ */
+uint32_t getSn_TxBASE(uint8_t sn);
+
+
+/*socket register W5100S only*/
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set the interrupt mask register of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)imr Value to set \ref Sn_IMR
+ * @sa getSn_IMR(sn)
+ */
+#define setSn_IMR(sn,imr)	\
+		WIZCHIP_WRITE(Sn_IMR(sn),imr)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the interrupt mask register of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of Socket n interrupt mask register.
+ */
+#define getSn_IMR(sn)	\
+		WIZCHIP_READ(Sn_IMR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set the Sn_MR2 value of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param mr2 Value of Sn_MR2 register to set.
+ */
+#define setSn_MR2(sn,mr2)	\
+		WIZCHIP_WRITE(Sn_MR2(sn), mr2)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the Sn_MR2 value of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of Socket n Sn_MR2 register.
+ */
+#define getSn_MR2(sn)	\
+		WIZCHIP_READ(Sn_MR2(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set the Sn_KPALVTR value of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param kpalvtr Value of the Sn_KPALVTR register to set.
+ */
+#define setSn_KPALVTR(sn,kpalvtr)	\
+		WIZCHIP_WRITE(Sn_KPALVTR(sn), kpalvtr)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the Sn_KPALVTR value of socket sn
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of the Sn_KPALVTR register.
+ */
+#define getSn_KPALVTR(sn)	\
+		WIZCHIP_READ(Sn_KPALVTR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the Sn_TSR register of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of the Socket n Sn_TSR register.
+ */
+#define	getSn_TSR(sn)	\
+		WIZCHIP_READ(Sn_TSR(sn))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set the Sn_RTR register of socket sn.
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param (uint16_t)rtr Value of the Socket n Sn_RTR register to set.
+ */
+#define	setSn_RTR(sn,rtr)	{ \
+		WIZCHIP_WRITE(Sn_RTR(sn),   (uint8_t)(rtr >> 8)); \
+		WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(Sn_RTR(sn),1), (uint8_t) rtr); \
+		}
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the Sn_RTR register of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint16_t. Value of the Socket n Sn_RTR register.
+ */
+#define getSn_RTR(sn)	\
+		(((uint16_t)WIZCHIP_READ(Sn_RTR(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(Sn_RTR(sn),1)))
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Set the Sn_RCR register of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of the Socket n Sn_RCR register to set.
+ */
+#define setSn_RCR(sn,rcr)	\
+		WIZCHIP_WRITE(Sn_RCR(sn),rcr)
+
+/**
+ * @ingroup Socket_register_access_function_W5100S
+ * @brief Get the Sn_RCR of socket sn.
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @return uint8_t. Value of the Socket n Sn_RCR.
+ */
+#define getSn_RCR(sn)	\
+		WIZCHIP_READ(Sn_RCR(sn))
+
+/////////////////////////////////////
+// Sn_TXBUF & Sn_RXBUF IO function //
+/////////////////////////////////////
+/**
+ * @ingroup Basic_IO_function_W5100S
+ * @brief It copies data to internal TX memory
+ *
+ * @details This function reads the Tx write pointer register and after that,
+ * it copies the <i>wizdata(pointer buffer)</i> of the length of <i>len(variable)</i> bytes to internal TX memory
+ * and updates the Tx write pointer register.
+ * This function is being called by send() and sendto() function also.
+ *
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param wizdata Pointer buffer to write data
+ * @param len Data length
+ * @sa wiz_recv_data()
+ */
+void wiz_send_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
+
+/**
+ * @ingroup Basic_IO_function_W5100S
+ * @brief It copies data to your buffer from internal RX memory
+ *
+ * @details This function read the Rx read pointer register and after that,
+ * it copies the received data from internal RX memory
+ * to <i>wizdata(pointer variable)</i> of the length of <i>len(variable)</i> bytes.
+ * This function is being called by recv() also.
+ *
+ * @param sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param wizdata Pointer buffer to read data
+ * @param len Data length
+ * @sa wiz_send_data()
+ */
+void wiz_recv_data(uint8_t sn, uint8_t *wizdata, uint16_t len);
+
+/**
+ * @ingroup Basic_IO_function_W5100S
+ * @brief It discard the received data in RX memory.
+ * @details It discards the data of the length of <i>len(variable)</i> bytes in internal RX memory.
+ * @param (uint8_t)sn Socket number. It should be <b>0 ~ @ref \_WIZCHIP_SOCK_NUM_</b>.
+ * @param len Data length
+ */
+void wiz_recv_ignore(uint8_t sn, uint16_t len);
+
+/**
+ * @ingroup Special_function_W5100S
+ * @brief Write data to the PHY via MDC/MDIO interface.
+ * @details Write command data to the PHY via MDC/MDIO interface.
+ * @param (uint8_t)PHYMDIO_regadr Address of the PHY register. It should be PHYMDIO_BMCR or PHYMDIO_BMSR.
+ * @param (uint16_t)var Data to write to the PHY register. Please refer to the bit definitions of the BMCR and BMSR register.
+ */
+void wiz_mdio_write(uint8_t PHYMDIO_regadr, uint16_t var);
+
+/**
+ * @ingroup Special_function_W5100S
+ * @brief Read data from the PHY via MDC/MDIO interface.
+ * @details Read command or status data from the PHY via MDC/MDIO interface.
+ * @param (uint8_t)PHYMDIO_regadr Address of the PHY register. It should be PHYMDIO_BMCR or PHYMDIO_BMSR.
+ * @return The value of the PHY register
+ */
+uint16_t wiz_mdio_read(uint8_t PHYMDIO_regadr);
+
+/**
+ * @ingroup Special_function_W5100S
+ * @brief Delay function
+ * @details Delay function using internal 100us timer of the W5100S
+ * @param (uint32_t)ms Time to delay in milliseconds.
+ */
+void wiz_delay_ms(uint32_t ms);
+
+/// @cond DOXY_APPLY_CODE
+#endif
+/// @endcond
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //_W5100S_H_
+
+
diff --git a/drivers/wiznet5k/ethernet/w5500/w5500.c b/drivers/wiznet5k/ethernet/w5500/w5500.c
index 3107b1b71..014cd4445 100644
--- a/drivers/wiznet5k/ethernet/w5500/w5500.c
+++ b/drivers/wiznet5k/ethernet/w5500/w5500.c
@@ -86,7 +86,6 @@ uint8_t  WIZCHIP_READ(uint32_t AddrSel)
    spi_data[2] = (AddrSel & 0x000000FF) >> 0;
    Chip_SSP_WriteFrames_Blocking(LPC_SSP0, spi_data, 3);
    Chip_SSP_ReadFrames_Blocking(LPC_SSP0, &ret, 1);
-
    WIZCHIP.CS._deselect();
    WIZCHIP_CRITICAL_EXIT();
    return ret;
diff --git a/drivers/wiznet5k/ethernet/w5500/w5500.h b/drivers/wiznet5k/ethernet/w5500/w5500.h
index c2afb180e..faab9e95a 100644
--- a/drivers/wiznet5k/ethernet/w5500/w5500.h
+++ b/drivers/wiznet5k/ethernet/w5500/w5500.h
@@ -834,7 +834,7 @@
  */
 #define Sn_MR_MACRAW                 0x04
 
-//#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
+#define Sn_MR_IPRAW                  0x03     /**< IP LAYER RAW SOCK */
 
 /**
  * @brief UDP
@@ -1124,7 +1124,7 @@
  */
 #define SOCK_UDP                     0x22
 
-//#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
+#define SOCK_IPRAW                   0x32     /**< IP raw mode socket */
 
 /**
  * @brief MAC raw mode socket
diff --git a/drivers/wiznet5k/ethernet/wizchip_conf.c b/drivers/wiznet5k/ethernet/wizchip_conf.c
<<<<<<< HEAD
index 3e54d2c90..9f6182f98 100644
=======
index 3e54d2c90..9e6633671 100644
>>>>>>> dev
--- a/drivers/wiznet5k/ethernet/wizchip_conf.c
+++ b/drivers/wiznet5k/ethernet/wizchip_conf.c
@@ -5,8 +5,12 @@
 //! \version 1.0.1
 //! \date 2013/10/21
 //! \par  Revision history
+//!       <2015/02/05> Notice
+//!        The version history is not updated after this point.
+//!        Download the latest version directly from GitHub. Please visit the our GitHub repository for ioLibrary.
+//!        >> https://github.com/Wiznet/ioLibrary_Driver
 //!       <2014/05/01> V1.0.1  Refer to M20140501
-//!        1. Explicit type casting in wizchip_bus_readbyte() & wizchip_bus_writebyte()
+//!        1. Explicit type casting in wizchip_bus_readdata() & wizchip_bus_writedata()
 //            Issued by Mathias ClauBen.
 //!           uint32_t type converts into ptrdiff_t first. And then recoverting it into uint8_t*
 //!           For remove the warning when pointer type size is not 32bit.
@@ -47,68 +51,110 @@
 //A20140501 : for use the type - ptrdiff_t
 #include <stddef.h>
 //
+#include "py/objlist.h"
+#include "py/runtime.h"
+#include "py/stream.h"
+#include "py/mperrno.h"
+#include "py/mphal.h"
+
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
 
 #include "wizchip_conf.h"
-#include "socket.h"
+
+/////////////
+//M20150401 : Remove ; in the default callback function such as wizchip_cris_enter(), wizchip_cs_select() and etc.
+/////////////
 
 /**
  * @brief Default function to enable interrupt.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	  wizchip_cris_enter(void)           {};
+//void 	  wizchip_cris_enter(void)           {};
+void 	  wizchip_cris_enter(void)           {}
+
 /**
  * @brief Default function to disable interrupt.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	  wizchip_cris_exit(void)          {};
+//void 	  wizchip_cris_exit(void)          {};
+void 	  wizchip_cris_exit(void)          {}
+
 /**
  * @brief Default function to select chip.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	wizchip_cs_select(void)            {};
+//void 	wizchip_cs_select(void)            {};
+void 	wizchip_cs_select(void)            {}
+
 /**
  * @brief Default function to deselect chip.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void 	wizchip_cs_deselect(void)          {};
+//void 	wizchip_cs_deselect(void)          {};
+void 	wizchip_cs_deselect(void)          {}
+
 /**
  * @brief Default function to read in direct or indirect interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
- //M20140501 : Explict pointer type casting
-//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *) AddrSel); };
-uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); };
+ //M20150601 : Rename the function for integrating with 5300
+//uint8_t wizchip_bus_readbyte(uint32_t AddrSel) { return * ((volatile uint8_t *)((ptrdiff_t) AddrSel)); }
+iodata_t wizchip_bus_readdata(uint32_t AddrSel) { return * ((volatile iodata_t *)((ptrdiff_t) AddrSel)); }
+
 /**
  * @brief Default function to write in direct or indirect interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
- 
-//M20140501 : Explict pointer type casting
-//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*) AddrSel) = wb; };
-void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; };
+//M20150601 : Rename the function for integrating with 5300
+//void 	wizchip_bus_writebyte(uint32_t AddrSel, uint8_t wb)  { *((volatile uint8_t*)((ptrdiff_t)AddrSel)) = wb; }
+void 	wizchip_bus_writedata(uint32_t AddrSel, iodata_t wb)  { *((volatile iodata_t*)((ptrdiff_t)AddrSel)) = wb; }
 
 /**
  * @brief Default function to read in SPI interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void wizchip_spi_readbytes(uint8_t *buf, uint32_t len) {}
+//uint8_t wizchip_spi_readbyte(void)        {return 0;};
+void wizchip_spi_readbyte(uint8_t *buf, uint32_t len) {}
+
 /**
  * @brief Default function to write in SPI interface.
  * @note This function help not to access wrong address. If you do not describe this function or register any functions,
  * null function is called.
  */
-void wizchip_spi_writebytes(const uint8_t *buf, uint32_t len) {}
+//void 	wizchip_spi_writebyte(uint8_t wb) {};
+void 	wizchip_spi_writebyte(const uint8_t *buf, uint32_t len) {}
+
+/**
+ * @brief Default function to burst read in SPI interface.
+ * @note This function help not to access wrong address. If you do not describe this function or register any functions,
+ * null function is called.
+ */
+//void 	wizchip_spi_readburst(uint8_t* pBuf, uint16_t len) 	{}; 
+void 	wizchip_spi_readburst(uint8_t* pBuf, uint16_t len) 	{}
+
+/**
+ * @brief Default function to burst write in SPI interface.
+ * @note This function help not to access wrong address. If you do not describe this function or register any functions,
+ * null function is called.
+ */
+//void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {};
+void 	wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len) {}
 
 /**
  * @\ref _WIZCHIP instance
  */
+//
+//M20150401 : For a compiler didnot support a member of structure
+//            Replace the assignment of struct members with the assingment of array
+//
+/*
 _WIZCHIP  WIZCHIP =
       {
       .id                  = _WIZCHIP_ID_,
@@ -122,10 +168,32 @@ _WIZCHIP  WIZCHIP =
 //    .IF.SPI._read_byte   = wizchip_spi_readbyte,
 //    .IF.SPI._write_byte  = wizchip_spi_writebyte
       };
+*/      
+_WIZCHIP  WIZCHIP =
+{
+    _WIZCHIP_IO_MODE_,
+    _WIZCHIP_ID_ ,
+    {
+        wizchip_cris_enter,
+        wizchip_cris_exit
+    },
+    {
+        wizchip_cs_select,
+        wizchip_cs_deselect
+    },
+    {
+        {
+            //M20150601 : Rename the function 
+            //wizchip_bus_readbyte,
+            //wizchip_bus_writebyte
+            wizchip_bus_readdata,
+            wizchip_bus_writedata
+        },
+
+    }
+};
+
 
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-static uint8_t    _SUBN_[4];     // subnet
-#endif
 static uint8_t    _DNS_[4];      // DNS server ip address
 static dhcp_mode  _DHCP_;        // DHCP mode
 
@@ -157,10 +225,13 @@ void reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void))
    }
 }
 
-void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb))
+//M20150515 : For integrating with 5300
+//void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb))
+void reg_wizchip_bus_cbfunc(iodata_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, iodata_t wb))
 {
    while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_BUS_));
-   
+   //M20150601 : Rename call back function for integrating with 5300
+   /*
    if(!bus_rb || !bus_wb)
    {
       WIZCHIP.IF.BUS._read_byte   = wizchip_bus_readbyte;
@@ -171,6 +242,17 @@ void reg_wizchip_bus_cbfunc(uint8_t(*bus_rb)(uint32_t addr), void (*bus_wb)(uint
       WIZCHIP.IF.BUS._read_byte   = bus_rb;
       WIZCHIP.IF.BUS._write_byte  = bus_wb;
    }
+   */
+   if(!bus_rb || !bus_wb)
+   {
+      WIZCHIP.IF.BUS._read_data   = wizchip_bus_readdata;
+      WIZCHIP.IF.BUS._write_data  = wizchip_bus_writedata;
+   }
+   else
+   {
+      WIZCHIP.IF.BUS._read_data   = bus_rb;
+      WIZCHIP.IF.BUS._write_data  = bus_wb;
+   }
 }
 
 void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(const uint8_t *, uint32_t))
<<<<<<< HEAD
@@ -179,8 +254,8 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
=======
@@ -179,8 +261,8 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
>>>>>>> dev
    
    if(!spi_rb || !spi_wb)
    {
-      WIZCHIP.IF.SPI._read_bytes   = wizchip_spi_readbytes;
-      WIZCHIP.IF.SPI._write_bytes  = wizchip_spi_writebytes;
+      WIZCHIP.IF.SPI._read_bytes   = wizchip_spi_readbyte;
+      WIZCHIP.IF.SPI._write_bytes  = wizchip_spi_writebyte;
    }
    else
    {
<<<<<<< HEAD
@@ -188,10 +263,29 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
=======
@@ -188,10 +270,29 @@ void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(
>>>>>>> dev
       WIZCHIP.IF.SPI._write_bytes  = spi_wb;
    }
 }
+/*
+// 20140626 Eric Added for SPI burst operations
+void reg_wizchip_spiburst_cbfunc(void (*spi_rb)(uint8_t* pBuf, uint16_t len), void (*spi_wb)(uint8_t* pBuf, uint16_t len))
+{
+   while(!(WIZCHIP.if_mode & _WIZCHIP_IO_MODE_SPI_));
 
+   if(!spi_rb || !spi_wb)
+   {
+      WIZCHIP.IF.SPI._read_burst   = wizchip_spi_readburst;
+      WIZCHIP.IF.SPI._write_burst  = wizchip_spi_writeburst;
+   }
+   else
+   {
+      WIZCHIP.IF.SPI._read_burst   = spi_rb;
+      WIZCHIP.IF.SPI._write_burst  = spi_wb;
+   }
+}
+*/
 int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
 {
+#if	_WIZCHIP_ == 5105 || _WIZCHIP_ == 5200 || _WIZCHIP_ == 5500
    uint8_t tmp = 0;
+#endif
    uint8_t* ptmp[2] = {0,0};
    switch(cwtype)
    {
@@ -217,7 +318,9 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
       case CW_GET_INTRMASK:
          *((intr_kind*)arg) = wizchip_getinterruptmask();
          break;
-   #if _WIZCHIP_ > 5100
+   //M20150601 : This can be supported by 5200, 5500
+   //#if _WIZCHIP_ > 5100
+   #if (_WIZCHIP_ == 5200 || _WIZCHIP_ == 5500)
       case CW_SET_INTRTIME:
          setINTLEVEL(*(uint16_t*)arg);
          break;
@@ -231,9 +334,10 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
          ((uint8_t*)arg)[2] = WIZCHIP.id[2];
          ((uint8_t*)arg)[3] = WIZCHIP.id[3];
          ((uint8_t*)arg)[4] = WIZCHIP.id[4];
-         ((uint8_t*)arg)[5] = 0;
+         ((uint8_t*)arg)[5] = WIZCHIP.id[5];
+         ((uint8_t*)arg)[6] = 0;
          break;
-   #if _WIZCHIP_ ==  5500
+   #if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5500
       case CW_RESET_PHY:
          wizphy_reset();
          break;
@@ -248,6 +352,7 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
       case CW_SET_PHYPOWMODE:
          return wizphy_setphypmode(*(uint8_t*)arg);
    #endif
+   #if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5200 || _WIZCHIP_ == 5500
       case CW_GET_PHYPOWMODE:
          tmp = wizphy_getphypmode();
          if((int8_t)tmp == -1) return -1;
@@ -258,6 +363,7 @@ int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg)
          if((int8_t)tmp == -1) return -1;
          *(uint8_t*)arg = tmp;
          break;
+   #endif      
       default:
          return -1;
    }
@@ -297,10 +403,21 @@ void wizchip_sw_reset(void)
 {
    uint8_t gw[4], sn[4], sip[4];
    uint8_t mac[6];
+//A20150601
+#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
+   uint16_t mr = (uint16_t)getMR();
+   setMR(mr | MR_IND);
+#endif
+//
    getSHAR(mac);
    getGAR(gw);  getSUBR(sn);  getSIPR(sip);
    setMR(MR_RST);
    getMR(); // for delay
+//A2015051 : For indirect bus mode 
+#if _WIZCHIP_IO_MODE_  == _WIZCHIP_IO_MODE_BUS_INDIR_
+   setMR(mr | MR_IND);
+#endif
+//
    setSHAR(mac);
    setGAR(gw);
    setSUBR(sn);
@@ -310,29 +427,82 @@ void wizchip_sw_reset(void)
 int8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize)
 {
    int8_t i;
+#if _WIZCHIP_ < 5200
+   int8_t j;
+#endif
    int8_t tmp = 0;
    wizchip_sw_reset();
    if(txsize)
    {
       tmp = 0;
-      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         tmp += txsize[i];
-      if(tmp > 16) return -1;
-      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         setSn_TXBUF_SIZE(i, txsize[i]);
+   //M20150601 : For integrating with 5300
+   #if _WIZCHIP_ == 5300
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+			if(txsize[i] >= 64) return -1;   //No use 64KB even if 5300 support max 64KB memory allocation
+			tmp += txsize[i];
+			if(tmp > 128) return -1;
+		}
+		if(tmp % 8) return -1;
+   #else
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+			tmp += txsize[i];
+
+		#if _WIZCHIP_ < 5200	//2016.10.28 peter add condition for 5100 and 5105
+			if(tmp > 8) return -1;
+		#else
+			if(tmp > 16) return -1;
+		#endif
+		}
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+		#if _WIZCHIP_ < 5200	//2016.10.28 peter add condition for 5100
+			j = 0;
+			while((txsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
+			setSn_TXBUF_SIZE(i, j);
+		#else
+			setSn_TXBUF_SIZE(i, txsize[i]);
+		#endif
+		}
+
+	#endif
    }
+
    if(rxsize)
    {
       tmp = 0;
+   #if _WIZCHIP_ == 5300
       for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         tmp += rxsize[i];
-      if(tmp > 16) return -1;
-      for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
-         setSn_RXBUF_SIZE(i, rxsize[i]);
+		{
+			if(rxsize[i] >= 64) return -1;   //No use 64KB even if 5300 support max 64KB memory allocation
+			tmp += rxsize[i];
+			if(tmp > 128) return -1;
+		}
+		if(tmp % 8) return -1;
+   #else
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+			tmp += rxsize[i];
+		#if _WIZCHIP_ < 5200	//2016.10.28 peter add condition for 5100 and 5105
+			if(tmp > 8) return -1;
+		#else
+			if(tmp > 16) return -1;
+		#endif
+		}
+
+		for(i = 0 ; i < _WIZCHIP_SOCK_NUM_; i++)
+		{
+		#if _WIZCHIP_ < 5200	// add condition for 5100
+			j = 0;
+			while((rxsize[i] >> j != 1)&&(txsize[i] !=0)){j++;}
+			setSn_RXBUF_SIZE(i, j);
+		#else
+			setSn_RXBUF_SIZE(i, rxsize[i]);
+		#endif
+		}
+	#endif
    }
-
-   WIZCHIP_EXPORT(socket_reset)();
-
    return 0;
 }
 
@@ -351,12 +521,20 @@ void wizchip_clrinterrupt(intr_kind intr)
    sir &= 0x0F;
 #endif
 
-#if _WIZCHIP_ == 5100
+#if _WIZCHIP_ <= 5105
    ir |= sir;
    setIR(ir);
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_ == 5300
+   setIR( ((((uint16_t)ir) << 8) | (((uint16_t)sir) & 0x00FF)) );
 #else
    setIR(ir);
-   setSIR(sir);
+//M20200227 : For clear
+   //setSIR(sir);
+   for(ir=0; ir<8; ir++){
+       if(sir & (0x01 <<ir) ) setSn_IR(ir, 0xff);
+   }
+
 #endif   
 }
 
@@ -365,15 +543,22 @@ intr_kind wizchip_getinterrupt(void)
    uint8_t ir  = 0;
    uint8_t sir = 0;
    uint16_t ret = 0;
-#if _WIZCHIP_ == 5100
+#if _WIZCHIP_ <= 5105
    ir = getIR();
-   sir = ir 0x0F;
+   sir = ir & 0x0F;
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_  == 5300
+   ret = getIR();
+   ir = (uint8_t)(ret >> 8);
+   sir = (uint8_t)ret;
 #else
    ir  = getIR();
    sir = getSIR();
 #endif         
 
-#if _WIZCHIP_ < 5500
+//M20150601 : For Integrating with 5300
+//#if _WIZCHIP_ < 5500
+#if _WIZCHIP_ < 5200
    ir &= ~(1<<4); // IK_WOL
 #endif
 #if _WIZCHIP_ == 5200
@@ -397,11 +582,11 @@ void wizchip_setinterruptmask(intr_kind intr)
    
 #if _WIZCHIP_ < 5200
    simr &= 0x0F;
-#endif
-
-#if _WIZCHIP_ == 5100
    imr |= simr;
    setIMR(imr);
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_ == 5300
+   setIMR( ((((uint16_t)imr) << 8) | (((uint16_t)simr) & 0x00FF)) );
 #else
    setIMR(imr);
    setSIMR(simr);
@@ -413,9 +598,14 @@ intr_kind wizchip_getinterruptmask(void)
    uint8_t imr  = 0;
    uint8_t simr = 0;
    uint16_t ret = 0;
-#if _WIZCHIP_ == 5100
+#if _WIZCHIP_ < 5200
    imr  = getIMR();
-   simr = imr 0x0F;
+   simr = imr & 0x0F;
+//A20150601 : For integrating with 5300
+#elif _WIZCHIP_ == 5300
+   ret = getIMR();
+   imr = (uint8_t)(ret >> 8);
+   simr = (uint8_t)ret;
 #else
    imr  = getIMR();
    simr = getSIMR();
@@ -434,17 +624,17 @@ intr_kind wizchip_getinterruptmask(void)
 
 int8_t wizphy_getphylink(void)
 {
-   int8_t tmp;
-#if   _WIZCHIP_ == 5200
+   int8_t tmp = PHY_LINK_OFF;
+#if _WIZCHIP_ == 5105
+   if(getPHYSR() & PHYSR_LNK)
+	   tmp = PHY_LINK_ON;
+#elif   _WIZCHIP_ ==5200
    if(getPHYSTATUS() & PHYSTATUS_LINK)
       tmp = PHY_LINK_ON;
-   else
-      tmp = PHY_LINK_OFF;
 #elif _WIZCHIP_ == 5500
    if(getPHYCFGR() & PHYCFGR_LNK_ON)
       tmp = PHY_LINK_ON;
-   else
-      tmp = PHY_LINK_OFF;
+
 #else
    tmp = -1;
 #endif
@@ -462,7 +652,7 @@ int8_t wizphy_getphypmode(void)
       else          
          tmp = PHY_POWER_NORM;
    #elif _WIZCHIP_ == 5500
-      if(getPHYCFGR() & PHYCFGR_OPMDC_PDOWN)
+      if((getPHYCFGR() & PHYCFGR_OPMDC_ALLA) == PHYCFGR_OPMDC_PDOWN)
          tmp = PHY_POWER_DOWN;
       else 
          tmp = PHY_POWER_NORM;
@@ -473,13 +663,95 @@ int8_t wizphy_getphypmode(void)
 }
 #endif
 
+#if _WIZCHIP_ == 5105
+void wizphy_reset(void)
+{
+	uint16_t tmp = wiz_mdio_read(PHYMDIO_BMCR);
+	tmp |= BMCR_RESET;
+	wiz_mdio_write(PHYMDIO_BMCR, tmp);
+	while(wiz_mdio_read(PHYMDIO_BMCR)&BMCR_RESET){}
+}
+
+void wizphy_setphyconf(wiz_PhyConf* phyconf)
+{
+   uint16_t tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   if(phyconf->mode == PHY_MODE_AUTONEGO)
+      tmp |= BMCR_AUTONEGO;
+   else
+   {
+	  tmp &= ~BMCR_AUTONEGO;
+      if(phyconf->duplex == PHY_DUPLEX_FULL)
+      {
+    	  tmp |= BMCR_DUP;
+      }
+      else
+      {
+    	  tmp &= ~BMCR_DUP;
+      }
+      if(phyconf->speed == PHY_SPEED_100)
+      {
+    	  tmp |= BMCR_SPEED;
+      }
+      else
+      {
+    	  tmp &= ~BMCR_SPEED;
+      }
+   }
+   wiz_mdio_write(PHYMDIO_BMCR, tmp);
+}
+
+void wizphy_getphyconf(wiz_PhyConf* phyconf)
+{
+   uint16_t tmp = 0;
+   tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   phyconf->by   = PHY_CONFBY_SW;
+   if(tmp & BMCR_AUTONEGO)
+   {
+	   phyconf->mode = PHY_MODE_AUTONEGO;
+   }
+   else
+   {
+	   phyconf->mode = PHY_MODE_MANUAL;
+	   if(tmp&BMCR_DUP) phyconf->duplex = PHY_DUPLEX_FULL;
+	   else phyconf->duplex = PHY_DUPLEX_HALF;
+	   if(tmp&BMCR_SPEED) phyconf->speed = PHY_SPEED_100;
+	   else phyconf->speed = PHY_SPEED_10;
+   }
+}
+
+int8_t wizphy_setphypmode(uint8_t pmode)
+{
+   uint16_t tmp = 0;
+   tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   if( pmode == PHY_POWER_DOWN)
+   {
+      tmp |= BMCR_PWDN;
+   }
+   else
+   {
+	   tmp &= ~BMCR_PWDN;
+   }
+   wiz_mdio_write(PHYMDIO_BMCR, tmp);
+   tmp = wiz_mdio_read(PHYMDIO_BMCR);
+   if( pmode == PHY_POWER_DOWN)
+   {
+      if(tmp & BMCR_PWDN) return 0;
+   }
+   else
+   {
+      if((tmp & BMCR_PWDN) != BMCR_PWDN) return 0;
+   }
+   return -1;
+}
+
+#endif
 #if _WIZCHIP_ == 5500
 void wizphy_reset(void)
 {
    uint8_t tmp = getPHYCFGR();
    tmp &= PHYCFGR_RST;
    setPHYCFGR(tmp);
-   tmp = getPHYCFGR(); 
+   tmp = getPHYCFGR();
    tmp |= ~PHYCFGR_RST;
    setPHYCFGR(tmp);
 }
@@ -592,12 +864,6 @@ void wizchip_setnetinfo(wiz_NetInfo* pnetinfo)
    setGAR(pnetinfo->gw);
    setSUBR(pnetinfo->sn);
    setSIPR(pnetinfo->ip);
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-   _SUBN_[0] = pnetinfo->sn[0];
-   _SUBN_[1] = pnetinfo->sn[1];
-   _SUBN_[2] = pnetinfo->sn[2];
-   _SUBN_[3] = pnetinfo->sn[3];
-#endif
    _DNS_[0] = pnetinfo->dns[0];
    _DNS_[1] = pnetinfo->dns[1];
    _DNS_[2] = pnetinfo->dns[2];
@@ -611,12 +877,6 @@ void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
    getGAR(pnetinfo->gw);
    getSUBR(pnetinfo->sn);
    getSIPR(pnetinfo->ip);
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-   pnetinfo->sn[0] = _SUBN_[0];
-   pnetinfo->sn[1] = _SUBN_[1];
-   pnetinfo->sn[2] = _SUBN_[2];
-   pnetinfo->sn[3] = _SUBN_[3];
-#endif
    pnetinfo->dns[0]= _DNS_[0];
    pnetinfo->dns[1]= _DNS_[1];
    pnetinfo->dns[2]= _DNS_[2];
@@ -624,16 +884,10 @@ void wizchip_getnetinfo(wiz_NetInfo* pnetinfo)
    pnetinfo->dhcp  = _DHCP_;
 }
 
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-uint8_t *wizchip_getsubn(void) {
-    return _SUBN_;
-}
-#endif
-
 int8_t wizchip_setnetmode(netmode_type netmode)
 {
    uint8_t tmp = 0;
-#if _WIZCHIP_ != 5500   
+#if _WIZCHIP_ != 5500
    if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK)) return -1;
 #else
    if(netmode & ~(NM_WAKEONLAN | NM_PPPOE | NM_PINGBLOCK | NM_FORCEARP)) return -1;
@@ -659,4 +913,4 @@ void wizchip_gettimeout(wiz_NetTimeout* nettime)
 {
    nettime->retry_cnt = getRCR();
    nettime->time_100us = getRTR();
-}
+}
\ No newline at end of file
diff --git a/drivers/wiznet5k/ethernet/wizchip_conf.h b/drivers/wiznet5k/ethernet/wizchip_conf.h
index 4a7a7bd69..350b34f10 100644
--- a/drivers/wiznet5k/ethernet/wizchip_conf.h
+++ b/drivers/wiznet5k/ethernet/wizchip_conf.h
@@ -5,6 +5,10 @@
 //! \version 1.0.0
 //! \date 2013/10/21
 //! \par  Revision history
+//!       <2015/02/05> Notice
+//!        The version history is not updated after this point.
+//!        Download the latest version directly from GitHub. Please visit the our GitHub repository for ioLibrary.
+//!        >> https://github.com/Wiznet/ioLibrary_Driver
 //!       <2013/10/21> 1st Release
 //! \author MidnightCow
 //! \copyright
@@ -32,7 +36,7 @@
 //! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 //! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 //! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 //! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 //! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
 //! THE POSSIBILITY OF SUCH DAMAGE.
@@ -50,14 +54,21 @@
 #ifndef  _WIZCHIP_CONF_H_
 #define  _WIZCHIP_CONF_H_
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #include <stdint.h>
 /**
  * @brief Select WIZCHIP.
- * @todo You should select one, \b 5100, \b 5200 ,\b 5500 or etc. \n\n
- *       ex> <code> #define \_WIZCHIP_      5500 </code>
+ * @todo You should select one, \b 5100, \b 5105, \b 5200, \b 5300, \b 5500 or etc. \n\n
+ *       ex> <code> #define \_WIZCHIP_      W5500 </code>
  */
+
+
+
 #ifndef _WIZCHIP_
-#define _WIZCHIP_                      5200   // 5100, 5200, 5500
+#define _WIZCHIP_                      5200   // 5100, 5200, 5500,5105(w5100s)
 #endif
 
 #define _WIZCHIP_IO_MODE_NONE_         0x0000
@@ -73,7 +84,7 @@
 
 #define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) /**< SPI interface mode for variable length data*/
 #define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) /**< SPI interface mode for fixed length data mode*/
-
+#define _WIZCHIP_IO_MODE_SPI_5500_     (_WIZCHIP_IO_MODE_SPI_ + 3) /**< SPI interface mode for fixed length data mode*/
 
 #if   (_WIZCHIP_ == 5100)
    #define _WIZCHIP_ID_                "W5100\0"
@@ -81,19 +92,41 @@
  * @brief Define interface mode.
  * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
  */
+// 	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
+//	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
+   	   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
 
-// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
-// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
-   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
+//A20150601 : Define the unit of IO DATA.   
+   typedef   uint8_t   iodata_t;
+//A20150401 : Indclude W5100.h file
+   #include "W5100/w5100.h"
 
+#elif (_WIZCHIP_ == 5105)
+#define _WIZCHIP_ID_                "W5100S\0"
+/**
+* @brief Define interface mode.
+* @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
+*/
+//	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
+	//#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_5500_
+	#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
+
+//A20150601 : Define the unit of IO DATA.
+   typedef   uint8_t   iodata_t;
+//A20150401 : Indclude W5100.h file
+	#include "w5105/w5105.h"
 #elif (_WIZCHIP_ == 5200)
    #define _WIZCHIP_ID_                "W5200\0"
 /**
  * @brief Define interface mode.
- * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
+ * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ or @ref \	_WIZCHIP_IO_MODE_BUS_INDIR_
  */
+#ifndef _WIZCHIP_IO_MODE_
 // #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
    #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_
+#endif
+//A20150601 : Define the unit of IO DATA.   
+   typedef   uint8_t   iodata_t;
    #include "w5200/w5200.h"
 #elif (_WIZCHIP_ == 5500)
   #define _WIZCHIP_ID_                 "W5500\0"
@@ -102,8 +135,8 @@
  * @brief Define interface mode. \n
  * @todo Should select interface mode as chip. 
  *        - @ref \_WIZCHIP_IO_MODE_SPI_ \n
- *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
- *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == 5500 \n
+ *          -@ref \_WIZCHIP_IO_MODE_SPI_VDM_ : Valid only in @ref \_WIZCHIP_ == W5500 \n
+ *          -@ref \_WIZCHIP_IO_MODE_SPI_FDM_ : Valid only in @ref \_WIZCHIP_ == W5500 \n
  *        - @ref \_WIZCHIP_IO_MODE_BUS_ \n
  *          - @ref \_WIZCHIP_IO_MODE_BUS_DIR_ \n
  *          - @ref \_WIZCHIP_IO_MODE_BUS_INDIR_ \n
@@ -111,10 +144,42 @@
  *        ex> <code> #define \_WIZCHIP_IO_MODE_ \_WIZCHIP_IO_MODE_SPI_VDM_ </code>
  *       
  */
+#ifndef _WIZCHIP_IO_MODE_
    //#define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_FDM_
    #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_SPI_VDM_
+#endif
+//A20150601 : Define the unit of IO DATA.   
+   typedef   uint8_t   iodata_t;
    #include "w5500/w5500.h"
-#else 
+#elif ( _WIZCHIP_ == W5300)
+   #define _WIZCHIP_ID_                 "W5300\0"
+/**
+ * @brief Define interface mode.
+ * @todo you should select interface mode as chip. Select one of @ref \_WIZCHIP_IO_MODE_SPI_ , @ref \_WIZCHIP_IO_MODE_BUS_DIR_ or @ref \_WIZCHIP_IO_MODE_BUS_INDIR_
+ */
+#ifndef _WIZCHIP_IO_MODE_
+   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_DIR_
+// #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
+#endif
+
+//A20150601 : Define the unit and bus width of IO DATA. 
+   /**
+    * @brief Select the data width 8 or 16 bits.
+    * @todo you should select the bus width. Select one of 8 or 16.
+    */
+   #ifndef _WIZCHIP_IO_BUS_WIDTH_
+   #define _WIZCHIP_IO_BUS_WIDTH_       16  // 8
+   #endif
+   #if _WIZCHIP_IO_BUS_WIDTH_ == 8
+      typedef   uint8_t   iodata_t;
+   #elif _WIZCHIP_IO_BUS_WIDTH_ == 16
+      typedef   uint16_t   iodata_t;
+   #else
+      #error "Unknown _WIZCHIP_IO_BUS_WIDTH_. It should be 8 or 16."	
+   #endif
+//
+   #include "W5300/w5300.h"
+#else
    #error "Unknown defined _WIZCHIP_. You should define one of 5100, 5200, and 5500 !!!"
 #endif
 
@@ -128,9 +193,20 @@
  *       @ref \_WIZCHIP_IO_MODE_BUS_DIR_, @ref \_WIZCHIP_IO_MODE_BUS_INDIR_). \n\n
  *       ex> <code> #define \_WIZCHIP_IO_BASE_      0x00008000 </code>
  */
-#define _WIZCHIP_IO_BASE_              0x00000000  // 
+#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_
+//	#define _WIZCHIP_IO_BASE_				0x60000000	// for 5100S IND
+	#define _WIZCHIP_IO_BASE_				0x68000000	// for W5300
+#elif _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_
+	#define _WIZCHIP_IO_BASE_				0x00000000	// for 5100S SPI
+#endif
+
+#ifndef _WIZCHIP_IO_BASE_
+#define _WIZCHIP_IO_BASE_              0x00000000  // 0x8000
+#endif
 
-#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
+//M20150401 : Typing Error
+//#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS
+#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_
    #ifndef _WIZCHIP_IO_BASE_
       #error "You should be define _WIZCHIP_IO_BASE to fit your system memory map."
    #endif
@@ -153,7 +229,7 @@
 typedef struct __WIZCHIP
 {
    uint16_t  if_mode;               ///< host interface mode
-   uint8_t   id[6];                 ///< @b WIZCHIP ID such as @b 5100, @b 5200, @b 5500, and so on.
+   uint8_t   id[8];                 ///< @b WIZCHIP ID such as @b 5100, @b 5100S, @b 5200, @b 5500, and so on.
    /**
     * The set of critical section callback func.
     */
@@ -163,7 +239,7 @@ typedef struct __WIZCHIP
       void (*_exit) (void);         ///< critial section exit  
    }CRIS;  
    /**
-    *  The set of @ref\_WIZCHIP_ select control callback func.
+    *  The set of @ref \_WIZCHIP_ select control callback func.
     */
    struct _CS
    {
@@ -177,12 +253,19 @@ typedef struct __WIZCHIP
    {	 
       /**
        * For BUS interface IO
-       */  
+       */
+      //M20156501 : Modify the function name for integrating with W5300
+      //struct
+      //{
+      //   uint8_t  (*_read_byte)  (uint32_t AddrSel);
+      //   void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
+      //}BUS;      
       struct
       {
-         uint8_t  (*_read_byte)  (uint32_t AddrSel);
-         void     (*_write_byte) (uint32_t AddrSel, uint8_t wb);
+         iodata_t  (*_read_data)   (uint32_t AddrSel);
+         void      (*_write_data)  (uint32_t AddrSel, iodata_t wb);
       }BUS;      
+
       /**
        * For SPI interface IO
        */
@@ -190,6 +273,8 @@ typedef struct __WIZCHIP
       {
          void (*_read_bytes)  (uint8_t *buf, uint32_t len);
          void (*_write_bytes) (const uint8_t *buf, uint32_t len);
+       //  void    (*_read_burst)  (uint8_t* pBuf, uint16_t len);
+       //  void    (*_write_burst) (uint8_t* pBuf, uint16_t len);
       }SPI;
       // To be added
       //
@@ -205,7 +290,7 @@ extern _WIZCHIP  WIZCHIP;
 typedef enum
 {
    CW_RESET_WIZCHIP,   ///< Resets WIZCHIP by softly
-   CW_INIT_WIZCHIP,    ///< Inializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
+   CW_INIT_WIZCHIP,    ///< Initializes to WIZCHIP with SOCKET buffer size 2 or 1 dimension array typed uint8_t.
    CW_GET_INTERRUPT,   ///< Get Interrupt status of WIZCHIP
    CW_CLR_INTERRUPT,   ///< Clears interrupt
    CW_SET_INTRMASK,    ///< Masks interrupt
@@ -214,15 +299,19 @@ typedef enum
    CW_GET_INTRTIME,    ///< Set interval time between the current and next interrupt. 
    CW_GET_ID,          ///< Gets WIZCHIP name.
 
-#if _WIZCHIP_ ==  5500
-   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5000
-   CW_SET_PHYCONF,     ///< When PHY configured by interal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000 
-   CW_GET_PHYCONF,     ///< Get PHY operation mode in interal register. Valid Only W5000
-   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5000
-   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as noraml and down when PHYSTATUS.OPMD == 1. Valid Only W5000
-#endif
-   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal
-   CW_GET_PHYLINK      ///< Get PHY Link status
+//D20150601 : For no modification your application code
+//#if _WIZCHIP_ ==  W5500
+   CW_RESET_PHY,       ///< Resets internal PHY. Valid Only W5500
+   CW_SET_PHYCONF,     ///< When PHY configured by internal register, PHY operation mode (Manual/Auto, 10/100, Half/Full). Valid Only W5000
+   CW_GET_PHYCONF,     ///< Get PHY operation mode in internal register. Valid Only W5500
+   CW_GET_PHYSTATUS,   ///< Get real PHY status on operating. Valid Only W5500
+   CW_SET_PHYPOWMODE,  ///< Set PHY power mode as normal and down when PHYSTATUS.OPMD == 1. Valid Only W5500
+//#endif
+//D20150601 : For no modification your application code
+//#if _WIZCHIP_ == W5200 || _WIZCHIP_ == W5500
+   CW_GET_PHYPOWMODE,  ///< Get PHY Power mode as down or normal, Valid Only W5100, W5200
+   CW_GET_PHYLINK      ///< Get PHY Link status, Valid Only W5100, W5200
+//#endif
 }ctlwizchip_type;
 
 /**
@@ -247,14 +336,16 @@ typedef enum
  */
 typedef enum
 {
-#if _WIZCHIP_ > 5200
+#if   _WIZCHIP_ == 5500
    IK_WOL               = (1 << 4),   ///< Wake On Lan by receiving the magic packet. Valid in W500.
+#elif _WIZCHIP_ == 5300
+   IK_FMTU              = (1 << 4),   ///< Received a ICMP message (Fragment MTU)   
 #endif   
 
    IK_PPPOE_TERMINATED  = (1 << 5),   ///< PPPoE Disconnected
 
 #if _WIZCHIP_ != 5200
-   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreable, No use in W5200
+   IK_DEST_UNREACH      = (1 << 6),   ///< Destination IP & Port Unreachable, No use in W5200
 #endif   
 
    IK_IP_CONFLICT       = (1 << 7),   ///< IP conflict occurred
@@ -263,17 +354,17 @@ typedef enum
    IK_SOCK_1            = (1 << 9),   ///< Socket 1 interrupt
    IK_SOCK_2            = (1 << 10),  ///< Socket 2 interrupt
    IK_SOCK_3            = (1 << 11),  ///< Socket 3 interrupt
-#if _WIZCHIP_ > 5100   
+#if _WIZCHIP_ > 5105
    IK_SOCK_4            = (1 << 12),  ///< Socket 4 interrupt, No use in 5100
    IK_SOCK_5            = (1 << 13),  ///< Socket 5 interrupt, No use in 5100
    IK_SOCK_6            = (1 << 14),  ///< Socket 6 interrupt, No use in 5100
    IK_SOCK_7            = (1 << 15),  ///< Socket 7 interrupt, No use in 5100
 #endif   
 
-#if _WIZCHIP_ > 5100
-   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrpt
+#if _WIZCHIP_ > 5105
+   IK_SOCK_ALL          = (0xFF << 8) ///< All Socket interrupt
 #else
-   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrpt 
+   IK_SOCK_ALL          = (0x0F << 8) ///< All Socket interrupt
 #endif      
 }intr_kind;
 
@@ -291,7 +382,7 @@ typedef enum
 #define PHY_POWER_DOWN           1     ///< PHY power down mode 
 
 
-#if _WIZCHIP_ == 5500 
+#if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5500
 /**
  * @ingroup DATA_TYPE
  *  It configures PHY configuration when CW_SET PHYCONF or CW_GET_PHYCONF in W5500,  
@@ -339,7 +430,7 @@ typedef struct wiz_NetInfo_t
  */
 typedef enum
 {
-#if _WIZCHIP_ == 5500   
+#if _WIZCHIP_ == 5500
    NM_FORCEARP    = (1<<1),  ///< Force to APP send whenever udp data is sent. Valid only in W5500
 #endif   
    NM_WAKEONLAN   = (1<<5),  ///< Wake On Lan 
@@ -385,18 +476,30 @@ void reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
  *or register your functions.
  *@note If you do not describe or register, null function is called.
  */
-void reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
+//M20150601 : For integrating with W5300
+//void reg_wizchip_bus_cbfunc(uint8_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, uint8_t wb));
+void reg_wizchip_bus_cbfunc(iodata_t (*bus_rb)(uint32_t addr), void (*bus_wb)(uint32_t addr, iodata_t wb));
 
 /**
  *@brief Registers call back function for SPI interface.
- *@param spi_rb : callback function to read byte usig SPI 
- *@param spi_wb : callback function to write byte usig SPI 
+ *@param spi_rb : callback function to read byte using SPI
+ *@param spi_wb : callback function to write byte using SPI
  *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
  *or register your functions.
  *@note If you do not describe or register, null function is called.
  */
 void reg_wizchip_spi_cbfunc(void (*spi_rb)(uint8_t *, uint32_t), void (*spi_wb)(const uint8_t *, uint32_t));
 
+/**
+ *@brief Registers call back function for SPI interface.
+ *@param spi_rb : callback function to burst read using SPI
+ *@param spi_wb : callback function to burst write using SPI
+ *@todo Describe \ref wizchip_spi_readbyte and \ref wizchip_spi_writebyte function
+ *or register your functions.
+ *@note If you do not describe or register, null function is called.
+ */
+void reg_wizchip_spiburst_cbfunc(void (*spi_rb)(uint8_t* pBuf, uint16_t len), void (*spi_wb)(uint8_t* pBuf, uint16_t len));
+
 /**
  * @ingroup extra_functions
  * @brief Controls to the WIZCHIP.
@@ -470,12 +573,13 @@ void wizchip_setinterruptmask(intr_kind intr);
  */
 intr_kind wizchip_getinterruptmask(void);
 
+//todo
 #if _WIZCHIP_ > 5100
    int8_t wizphy_getphylink(void);              ///< get the link status of phy in WIZCHIP. No use in W5100
    int8_t wizphy_getphypmode(void);             ///< get the power mode of PHY in WIZCHIP. No use in W5100
 #endif
 
-#if _WIZCHIP_ == 5500
+#if _WIZCHIP_ == 5105 || _WIZCHIP_ == 5500
    void   wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
 /**
  * @ingroup extra_functions
@@ -517,10 +621,6 @@ void wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
  */
 void wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
 
-#if _WIZCHIP_ == 5200   // for W5200 ARP errata
-uint8_t *wizchip_getsubn(void);
-#endif
-
 /**
  * @ingroup extra_functions
  * @brief Set the network mode such WOL, PPPoE, Ping Block, and etc. 
@@ -537,18 +637,21 @@ netmode_type wizchip_getnetmode(void);
 
 /**
  * @ingroup extra_functions
- * @brief Set retry time value(@ref RTR) and retry count(@ref RCR).
- * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
- * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
+ * @brief Set retry time value(@ref _RTR_) and retry count(@ref _RCR_).
+ * @details @ref _RTR_ configures the retransmission timeout period and @ref _RCR_ configures the number of time of retransmission.  
+ * @param nettime @ref _RTR_ value and @ref _RCR_ value. Refer to @ref wiz_NetTimeout. 
  */
 void wizchip_settimeout(wiz_NetTimeout* nettime);
 
 /**
  * @ingroup extra_functions
- * @brief Get retry time value(@ref RTR) and retry count(@ref RCR).
- * @details @ref RTR configures the retransmission timeout period and @ref RCR configures the number of time of retransmission.  
- * @param nettime @ref RTR value and @ref RCR value. Refer to @ref wiz_NetTimeout. 
+ * @brief Get retry time value(@ref _RTR_) and retry count(@ref _RCR_).
+ * @details @ref _RTR_ configures the retransmission timeout period and @ref _RCR_ configures the number of time of retransmission.  
+ * @param nettime @ref _RTR_ value and @ref _RCR_ value. Refer to @ref wiz_NetTimeout. 
  */
 void wizchip_gettimeout(wiz_NetTimeout* nettime);
+#ifdef __cplusplus
+ }
+#endif
 
-#endif   // _WIZCHIP_CONF_H_
+#endif   // _WIZCHIP_CONF_H_
\ No newline at end of file
diff --git a/drivers/wiznet5k/internet/dhcp/dhcp.c b/drivers/wiznet5k/internet/dhcp/dhcp.c
index 574758259..dfc057bb8 100644
--- a/drivers/wiznet5k/internet/dhcp/dhcp.c
+++ b/drivers/wiznet5k/internet/dhcp/dhcp.c
@@ -51,13 +51,15 @@
 
 //#include "Ethernet/socket.h"
 //#include "Internet/DHCP/dhcp.h"
-#include "../../Ethernet/socket.h"
+#include "../../ethernet/socket.h"
 #include "dhcp.h"
-
+#include "py/mphal.h"
+//#include "py/runtime.h"
 /* If you want to display debug & processing message, Define _DHCP_DEBUG_ in dhcp.h */
 
 #ifdef _DHCP_DEBUG_
    #include <stdio.h>
+
 #endif   
 
 /* DHCP state machine. */
@@ -258,6 +260,8 @@ void default_ip_assign(void)
    setSIPR(DHCP_allocated_ip);
    setSUBR(DHCP_allocated_sn);
    setGAR (DHCP_allocated_gw);
+   setSHAR(DHCP_CHADDR);
+
 }
 
 /* The default handler of ip changed */
@@ -403,12 +407,12 @@ void send_DHCP_DISCOVER(void)
 	ip[1] = 255;
 	ip[2] = 255;
 	ip[3] = 255;
-
+    
 #ifdef _DHCP_DEBUG_
 	printf("> Send DHCP_DISCOVER\r\n");
 #endif
+	WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 
-	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 }
 
 /* SEND DHCP REQUEST */
@@ -503,7 +507,7 @@ void send_DHCP_REQUEST(void)
 	printf("> Send DHCP_REQUEST\r\n");
 #endif
 	
-	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
+	WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 
 }
 
@@ -564,7 +568,7 @@ void send_DHCP_DECLINE(void)
 	printf("\r\n> Send DHCP_DECLINE\r\n");
 #endif
 
-	sendto(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
+	WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, RIP_MSG_SIZE, ip, DHCP_SERVER_PORT);
 }
 
 /* PARSE REPLY pDHCPMSG */
@@ -576,17 +580,20 @@ int8_t parseDHCPMSG(void)
 
 	uint8_t * p;
 	uint8_t * e;
-	uint8_t type;
+	int8_t type=0;
 	uint8_t opt_len;
    
    if((len = getSn_RX_RSR(DHCP_SOCKET)) > 0)
    {
-   	len = recvfrom(DHCP_SOCKET, (uint8_t *)pDHCPMSG, len, svr_addr, &svr_port);
+   	len = WIZCHIP_EXPORT(recvfrom)(DHCP_SOCKET, (uint8_t *)pDHCPMSG, len, svr_addr, &svr_port);
    #ifdef _DHCP_DEBUG_   
       printf("DHCP message : %d.%d.%d.%d(%d) %d received. \r\n",svr_addr[0],svr_addr[1],svr_addr[2], svr_addr[3],svr_port, len);
    #endif   
    }
-   else return 0;
+   else 
+   {
+	   return 0;
+   }
 	if (svr_port == DHCP_SERVER_PORT) {
       // compare mac address
 		if ( (pDHCPMSG->chaddr[0] != DHCP_CHADDR[0]) || (pDHCPMSG->chaddr[1] != DHCP_CHADDR[1]) ||
@@ -673,11 +680,10 @@ uint8_t DHCP_run(void)
 {
 	uint8_t  type;
 	uint8_t  ret;
-
 	if(dhcp_state == STATE_DHCP_STOP) return DHCP_STOPPED;
 
 	if(getSn_SR(DHCP_SOCKET) != SOCK_UDP)
-	   socket(DHCP_SOCKET, Sn_MR_UDP, DHCP_CLIENT_PORT, 0x00);
+	   WIZCHIP_EXPORT(socket)(DHCP_SOCKET, Sn_MR_UDP, DHCP_CLIENT_PORT, 0x00);
 
 	ret = DHCP_RUNNING;
 	type = parseDHCPMSG();
@@ -692,7 +698,7 @@ uint8_t DHCP_run(void)
    		dhcp_state = STATE_DHCP_DISCOVER;
    		break;
 		case STATE_DHCP_DISCOVER :
-			if (type == DHCP_OFFER){
+		if (type == DHCP_OFFER){
 #ifdef _DHCP_DEBUG_
 				printf("> Receive DHCP_OFFER\r\n");
 #endif
@@ -801,32 +807,36 @@ uint8_t DHCP_run(void)
 
 void    DHCP_stop(void)
 {
-   close(DHCP_SOCKET);
+   WIZCHIP_EXPORT(close)(DHCP_SOCKET);
    dhcp_state = STATE_DHCP_STOP;
 }
 
 uint8_t check_DHCP_timeout(void)
 {
 	uint8_t ret = DHCP_RUNNING;
-	
+	DHCP_time_handler();
 	if (dhcp_retry_count < MAX_DHCP_RETRY) {
 		if (dhcp_tick_next < dhcp_tick_1s) {
 
 			switch ( dhcp_state ) {
 				case STATE_DHCP_DISCOVER :
-//					printf("<<timeout>> state : STATE_DHCP_DISCOVER\r\n");
+				#ifdef _DHCP_DEBUG_
+					printf("<<timeout>> state : STATE_DHCP_DISCOVER\r\n");
+				#endif
 					send_DHCP_DISCOVER();
 				break;
 		
 				case STATE_DHCP_REQUEST :
-//					printf("<<timeout>> state : STATE_DHCP_REQUEST\r\n");
-
+				#ifdef _DHCP_DEBUG_
+					printf("<<timeout>> state : STATE_DHCP_REQUEST\r\n");
+				#endif
 					send_DHCP_REQUEST();
 				break;
 
 				case STATE_DHCP_REREQUEST :
-//					printf("<<timeout>> state : STATE_DHCP_REREQUEST\r\n");
-					
+				#ifdef _DHCP_DEBUG_
+					printf("<<timeout>> state : STATE_DHCP_REREQUEST\r\n");
+				#endif
 					send_DHCP_REQUEST();
 				break;
 		
@@ -837,6 +847,7 @@ uint8_t check_DHCP_timeout(void)
 			dhcp_tick_1s = 0;
 			dhcp_tick_next = dhcp_tick_1s + DHCP_WAIT_TIME;
 			dhcp_retry_count++;
+			
 		}
 	} else { // timeout occurred
 
@@ -869,7 +880,7 @@ int8_t check_DHCP_leasedIP(void)
 
 	// IP conflict detection : ARP request - ARP reply
 	// Broadcasting ARP Request for check the IP conflict using UDP sendto() function
-	ret = sendto(DHCP_SOCKET, (uint8_t *)"CHECK_IP_CONFLICT", 17, DHCP_allocated_ip, 5000);
+	ret = WIZCHIP_EXPORT(sendto)(DHCP_SOCKET, (uint8_t *)"CHECK_IP_CONFLICT", 17, DHCP_allocated_ip, 5000);
 
 	// RCR value restore
 	setRCR(tmp);
@@ -896,6 +907,7 @@ int8_t check_DHCP_leasedIP(void)
 void DHCP_init(uint8_t s, uint8_t * buf)
 {
    uint8_t zeroip[4] = {0,0,0,0};
+   
    getSHAR(DHCP_CHADDR);
    if((DHCP_CHADDR[0] | DHCP_CHADDR[1]  | DHCP_CHADDR[2] | DHCP_CHADDR[3] | DHCP_CHADDR[4] | DHCP_CHADDR[5]) == 0x00)
    {
@@ -933,6 +945,7 @@ void reset_DHCP_timeout(void)
 
 void DHCP_time_handler(void)
 {
+	mp_hal_delay_ms(100);
 	dhcp_tick_1s++;
 }
 
diff --git a/drivers/wiznet5k/internet/dns/dns.c b/drivers/wiznet5k/internet/dns/dns.c
index c0ad570c0..397620070 100644
--- a/drivers/wiznet5k/internet/dns/dns.c
+++ b/drivers/wiznet5k/internet/dns/dns.c
@@ -56,11 +56,10 @@
 //#include "Internet/DNS/dns.h"
 #include "../../ethernet/socket.h"
 #include "dns.h"
-
+#include "py/mphal.h"
 #ifdef _DNS_DEBUG_
-   #include <stdio.h>
+   //#include <stdio.h>
 #endif
-
 #define	INITRTT		2000L	/* Initial smoothed response time */
 #define	MAXCNAME	   (MAX_DOMAIN_NAME + (MAX_DOMAIN_NAME>>1))	   /* Maximum amount of cname recursion */
 
@@ -121,9 +120,9 @@ uint8_t* pDNSMSG;       // DNS message buffer
 uint8_t  DNS_SOCKET;    // SOCKET number for DNS
 uint16_t DNS_MSGID;     // DNS message ID
 
-extern uint32_t HAL_GetTick(void);
+//extern uint32_t HAL_GetTick(void);
 uint32_t hal_sys_tick;
-
+volatile uint32_t dns_tick_1s      = 0;   
 /* converts uint16_t from network buffer to a host byte order integer. */
 uint16_t get16(uint8_t * s)
 {
@@ -470,6 +469,11 @@ int16_t dns_makequery(uint16_t op, char * name, uint8_t * buf, uint16_t len)
 
 	return ((int16_t)((uint32_t)(cp) - (uint32_t)(buf)));
 }
+void DNS_time_handler(void)
+{
+	mp_hal_delay_ms(100);
+	dns_tick_1s++;
+}
 
 /*
  *              CHECK DNS TIMEOUT
@@ -483,13 +487,15 @@ int16_t dns_makequery(uint16_t op, char * name, uint8_t * buf, uint16_t len)
 int8_t check_DNS_timeout(void)
 {
 	static uint8_t retry_count;
-
-    uint32_t tick = HAL_GetTick();
-	if(tick - hal_sys_tick >= DNS_WAIT_TIME * 1000)
+    // TEST
+//uint32_t tick = HAL_GetTick();
+	DNS_time_handler();
+	if(dns_tick_1s - hal_sys_tick >= DNS_WAIT_TIME * 1000)
 	{
-		hal_sys_tick = tick;
+		hal_sys_tick = dns_tick_1s;
 		if(retry_count >= MAX_DNS_RETRY) {
 			retry_count = 0;
+			dns_tick_1s = 0;
 			return -1; // timeout occurred
 		}
 		retry_count++;
@@ -517,9 +523,11 @@ int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns)
 	uint8_t ip[4];
 	uint16_t len, port;
 	int8_t ret_check_timeout;
-
-        hal_sys_tick = HAL_GetTick();
-   
+    // TEST
+       // hal_sys_tick = HAL_GetTick();
+	    DNS_time_handler();
+        hal_sys_tick = dns_tick_1s;
+	
    // Socket open
    WIZCHIP_EXPORT(socket)(DNS_SOCKET, Sn_MR_UDP, 0, 0);
 
@@ -529,7 +537,6 @@ int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns)
 
 	len = dns_makequery(0, (char *)name, pDNSMSG, MAX_DNS_BUF_SIZE);
 	WIZCHIP_EXPORT(sendto)(DNS_SOCKET, pDNSMSG, len, dns_ip, IPPORT_DOMAIN);
-
 	while (1)
 	{
 		if ((len = getSn_RX_RSR(DNS_SOCKET)) > 0)
@@ -545,14 +552,12 @@ int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns)
 		// Check Timeout
 		ret_check_timeout = check_DNS_timeout();
 		if (ret_check_timeout < 0) {
-
 #ifdef _DNS_DEBUG_
 			printf("> DNS Server is not responding : %d.%d.%d.%d\r\n", dns_ip[0], dns_ip[1], dns_ip[2], dns_ip[3]);
 #endif
 			return 0; // timeout occurred
 		}
 		else if (ret_check_timeout == 0) {
-
 #ifdef _DNS_DEBUG_
 			printf("> DNS Timeout\r\n");
 #endif
diff --git a/drivers/wiznet5k/internet/dns/dns.h b/drivers/wiznet5k/internet/dns/dns.h
index de0039515..d9c507611 100644
--- a/drivers/wiznet5k/internet/dns/dns.h
+++ b/drivers/wiznet5k/internet/dns/dns.h
@@ -65,7 +65,7 @@
  * @todo SHOULD BE defined it equal as or greater than your Domain name length + null character(1)
  * @note SHOULD BE careful to stack overflow because it is allocated 1.5 times as MAX_DOMAIN_NAME in stack.
  */
-#define  MAX_DOMAIN_NAME   32       // for example "www.google.com"
+#define  MAX_DOMAIN_NAME   100       // for example "www.google.com"
 
 #define	MAX_DNS_RETRY     2        ///< Requery Count
 #define	DNS_WAIT_TIME     4        ///< Wait response time. unit 1s.
@@ -92,5 +92,6 @@ void DNS_init(uint8_t s, uint8_t * buf);
  * @note This function blocks until success or fail. max time = @ref MAX_DNS_RETRY * @ref DNS_WAIT_TIME
  */
 int8_t DNS_run(uint8_t * dns_ip, uint8_t * name, uint8_t * ip_from_dns);
+void DNS_time_handler(void);
 
 #endif	/* _DNS_H_ */
diff --git a/extmod/axtls-include/axtls_os_port.h b/extmod/axtls-include/axtls_os_port.h
index ef2683acf..836609940 100644
--- a/extmod/axtls-include/axtls_os_port.h
+++ b/extmod/axtls-include/axtls_os_port.h
@@ -51,5 +51,5 @@
 // For esp8266 port: use the hardware RNG.
 #define PLATFORM_RNG_U8()               (*WDEV_HWRNG)
 #endif
-
+void gettimeofday(struct timeval* t, void* timezone);
 #endif // AXTLS_OS_PORT_H
diff --git a/extmod/extmod.cmake b/extmod/extmod.cmake
index 67f7d8fd3..d1c257215 100644
--- a/extmod/extmod.cmake
+++ b/extmod/extmod.cmake
@@ -2,6 +2,8 @@
 
 set(MICROPY_EXTMOD_DIR "${MICROPY_DIR}/extmod")
 set(MICROPY_OOFATFS_DIR "${MICROPY_DIR}/lib/oofatfs")
+set(MICROPY_AXTLS_DIR "${MICROPY_DIR}/lib/axtls")
+INCLUDE_DIRECTORIES(${MICROPY_AXTLS_DIR}  ${MICROPY_AXTLS_DIR}/crypto ${MICROPY_AXTLS_DIR}/ssl ${MICROPY_EXTMOD_DIR}/axtls-include)
 
 set(MICROPY_SOURCE_EXTMOD
     ${MICROPY_DIR}/shared/libc/abort_.c
diff --git a/extmod/modnetwork.c b/extmod/modnetwork.c
index 1f242de86..4567746ef 100644
--- a/extmod/modnetwork.c
+++ b/extmod/modnetwork.c
@@ -71,7 +71,7 @@ mp_obj_t mod_network_find_nic(const uint8_t *ip) {
     for (mp_uint_t i = 0; i < MP_STATE_PORT(mod_network_nic_list).len; i++) {
         mp_obj_t nic = MP_STATE_PORT(mod_network_nic_list).items[i];
         // TODO check IP suitability here
-        // mod_network_nic_type_t *nic_type = (mod_network_nic_type_t*)mp_obj_get_type(nic);
+        //mod_network_nic_type_t *nic_type = (mod_network_nic_type_t*)mp_obj_get_type(nic);
         return nic;
     }
 
@@ -89,10 +89,14 @@ STATIC const mp_rom_map_elem_t mp_module_network_globals_table[] = {
 
     // Defined per port in mpconfigport.h
     MICROPY_PORT_NETWORK_INTERFACES
-
+#if MICROPY_PY_WIZNET5K
+    { MP_ROM_QSTR(MP_QSTR_WIZNET5K), MP_ROM_PTR(&mod_network_nic_type_wiznet5k) },
+#endif
     // Constants
+#if MICROPY_PY_NETWORK_CYW43
     { MP_ROM_QSTR(MP_QSTR_STA_IF), MP_ROM_INT(MOD_NETWORK_STA_IF) },
     { MP_ROM_QSTR(MP_QSTR_AP_IF), MP_ROM_INT(MOD_NETWORK_AP_IF) },
+#endif
 };
 
 STATIC MP_DEFINE_CONST_DICT(mp_module_network_globals, mp_module_network_globals_table);
@@ -149,7 +153,7 @@ mp_obj_t mod_network_nic_ifconfig(struct netif *netif, size_t n_args, const mp_o
         netutils_parse_ipv4_addr(items[2], (uint8_t *)&netif->gw, NETUTILS_BIG);
         ip_addr_t dns;
         netutils_parse_ipv4_addr(items[3], (uint8_t *)&dns, NETUTILS_BIG);
-        dns_setserver(0, &dns);
+        //dns_setserver(0, &dns);
         return mp_const_none;
     }
 }
diff --git a/extmod/modusocket.c b/extmod/modusocket.c
index a42b3213f..5c9c67355 100644
--- a/extmod/modusocket.c
+++ b/extmod/modusocket.c
@@ -36,7 +36,6 @@
 #include "modnetwork.h"
 
 #if MICROPY_PY_NETWORK && MICROPY_PY_USOCKET && !MICROPY_PY_LWIP
-
 /******************************************************************************/
 // socket class
 
@@ -458,20 +457,41 @@ STATIC const mp_obj_type_t socket_type = {
 
 /******************************************************************************/
 // usocket module
-
 // function usocket.getaddrinfo(host, port)
-STATIC mp_obj_t mod_usocket_getaddrinfo(mp_obj_t host_in, mp_obj_t port_in) {
+STATIC mp_obj_t mod_usocket_getaddrinfo(size_t n_args, const mp_obj_t *args) {
     size_t hlen;
-    const char *host = mp_obj_str_get_data(host_in, &hlen);
-    mp_int_t port = mp_obj_get_int(port_in);
+    const char *host = mp_obj_str_get_data(args[0], &hlen);
+    mp_int_t port = mp_obj_get_int(args[1]);
     uint8_t out_ip[MOD_NETWORK_IPADDR_BUF_SIZE];
     bool have_ip = false;
 
+    // if constraints were passed then check they are compatible with the supported params
+    if (n_args > 2) {
+        mp_int_t family = mp_obj_get_int(args[2]);
+        mp_int_t type = 0;
+        mp_int_t proto = 0;
+        mp_int_t flags = 0;
+        if (n_args > 3) {
+            type = mp_obj_get_int(args[3]);
+            if (n_args > 4) {
+                proto = mp_obj_get_int(args[4]);
+                if (n_args > 5) {
+                    flags = mp_obj_get_int(args[5]);
+                }
+            }
+        }
+        if (!((family == 0 || family == MOD_NETWORK_AF_INET)
+              && (type == 0 || type == MOD_NETWORK_SOCK_STREAM)
+              && proto == 0
+              && flags == 0)) {
+            mp_warning(MP_WARN_CAT(RuntimeWarning), "unsupported getaddrinfo constraints");
+        }
+    }
     if (hlen > 0) {
         // check if host is already in IP form
         nlr_buf_t nlr;
         if (nlr_push(&nlr) == 0) {
-            netutils_parse_ipv4_addr(host_in, out_ip, NETUTILS_BIG);
+            netutils_parse_ipv4_addr(args[0], out_ip, NETUTILS_BIG);
             have_ip = true;
             nlr_pop();
         } else {
@@ -494,7 +514,6 @@ STATIC mp_obj_t mod_usocket_getaddrinfo(mp_obj_t host_in, mp_obj_t port_in) {
             }
         }
     }
-
     if (!have_ip) {
         mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT("no available NIC"));
     }
@@ -507,7 +526,7 @@ STATIC mp_obj_t mod_usocket_getaddrinfo(mp_obj_t host_in, mp_obj_t port_in) {
     tuple->items[4] = netutils_format_inet_addr(out_ip, port, NETUTILS_BIG);
     return mp_obj_new_list(1, (mp_obj_t *)&tuple);
 }
-STATIC MP_DEFINE_CONST_FUN_OBJ_2(mod_usocket_getaddrinfo_obj, mod_usocket_getaddrinfo);
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_usocket_getaddrinfo_obj, 2, 6, mod_usocket_getaddrinfo);
 
 STATIC const mp_rom_map_elem_t mp_module_usocket_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_usocket) },
diff --git a/extmod/modussl_axtls.c b/extmod/modussl_axtls.c
index 9d5934206..4aaa9c997 100644
--- a/extmod/modussl_axtls.c
+++ b/extmod/modussl_axtls.c
@@ -32,9 +32,7 @@
 #include "py/objstr.h"
 
 #if MICROPY_PY_USSL && MICROPY_SSL_AXTLS
-
 #include "ssl.h"
-
 typedef struct _mp_obj_ssl_socket_t {
     mp_obj_base_t base;
     mp_obj_t sock;
@@ -87,8 +85,7 @@ STATIC const char *const ssl_error_tab2[] = {
 STATIC NORETURN void ussl_raise_error(int err) {
     MP_STATIC_ASSERT(SSL_NOT_OK - 3 == SSL_EAGAIN);
     MP_STATIC_ASSERT(SSL_ERROR_CONN_LOST - 18 == SSL_ERROR_NOT_SUPPORTED);
-
-    // Check if err corresponds to something in one of the error string tables.
+    // Check if err corresponds to something in one of the error string tables .
     const char *errstr = NULL;
     if (SSL_NOT_OK >= err && err >= SSL_EAGAIN) {
         errstr = ssl_error_tab1[SSL_NOT_OK - err];
@@ -128,26 +125,27 @@ STATIC mp_obj_ssl_socket_t *ussl_socket_new(mp_obj_t sock, struct ssl_args *args
     o->bytes_left = 0;
     o->sock = sock;
     o->blocking = true;
-
     uint32_t options = SSL_SERVER_VERIFY_LATER;
     if (!args->do_handshake.u_bool) {
         options |= SSL_CONNECT_IN_PARTS;
     }
+    
     if (args->key.u_obj != mp_const_none) {
         options |= SSL_NO_DEFAULT_KEY;
+        
     }
+    
     if ((o->ssl_ctx = ssl_ctx_new(options, SSL_DEFAULT_CLNT_SESS)) == NULL) {
         mp_raise_OSError(MP_EINVAL);
     }
-
     if (args->key.u_obj != mp_const_none) {
         size_t len;
         const byte *data = (const byte *)mp_obj_str_get_data(args->key.u_obj, &len);
         int res = ssl_obj_memory_load(o->ssl_ctx, SSL_OBJ_RSA_KEY, data, len, NULL);
         if (res != SSL_OK) {
+            
             mp_raise_ValueError(MP_ERROR_TEXT("invalid key"));
         }
-
         data = (const byte *)mp_obj_str_get_data(args->cert.u_obj, &len);
         res = ssl_obj_memory_load(o->ssl_ctx, SSL_OBJ_X509_CERT, data, len, NULL);
         if (res != SSL_OK) {
@@ -159,16 +157,15 @@ STATIC mp_obj_ssl_socket_t *ussl_socket_new(mp_obj_t sock, struct ssl_args *args
         o->ssl_sock = ssl_server_new(o->ssl_ctx, (long)sock);
     } else {
         SSL_EXTENSIONS *ext = ssl_ext_new();
-
-        if (args->server_hostname.u_obj != mp_const_none) {
+    
+    if (args->server_hostname.u_obj != mp_const_none) {
             ext->host_name = (char *)mp_obj_str_get_str(args->server_hostname.u_obj);
         }
-
+    
         o->ssl_sock = ssl_client_new(o->ssl_ctx, (long)sock, NULL, 0, ext);
-
         if (args->do_handshake.u_bool) {
             int r = ssl_handshake_status(o->ssl_sock);
-
+        
             if (r != SSL_OK) {
                 if (r == SSL_CLOSE_NOTIFY) { // EOF
                     r = MP_ENOTCONN;
@@ -241,7 +238,7 @@ STATIC mp_uint_t ussl_socket_read(mp_obj_t o_in, void *buf, mp_uint_t size, int
 
 STATIC mp_uint_t ussl_socket_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {
     mp_obj_ssl_socket_t *o = MP_OBJ_TO_PTR(o_in);
-
+    
     if (o->ssl_sock == NULL) {
         *errcode = EBADF;
         return MP_STREAM_ERROR;
@@ -340,8 +337,7 @@ STATIC mp_obj_t mod_ssl_wrap_socket(size_t n_args, const mp_obj_t *pos_args, mp_
 
     struct ssl_args args;
     mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,
-        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args);
-
+    MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args);
     return MP_OBJ_FROM_PTR(ussl_socket_new(sock, &args));
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_KW(mod_ssl_wrap_socket_obj, 1, mod_ssl_wrap_socket);
diff --git a/lib/axtls b/lib/axtls
--- a/lib/axtls
+++ b/lib/axtls
@@ -1 +1 @@
-Subproject commit 531cab9c278c947d268bd4c94ecab9153a961b43
+Subproject commit 531cab9c278c947d268bd4c94ecab9153a961b43-dirty
diff --git a/ports/rp2/CMakeLists.txt b/ports/rp2/CMakeLists.txt
index 0009ab2cd..3024fd781 100644
--- a/ports/rp2/CMakeLists.txt
+++ b/ports/rp2/CMakeLists.txt
@@ -53,6 +53,10 @@ pico_sdk_init()
 
 include(${MICROPY_DIR}/py/usermod.cmake)
 
+if (MICROPY_PY_WIZNET5K)
+   INCLUDE_DIRECTORIES(${MICROPY_DIR}/drivers/wiznet5k/ ${MICROPY_DIR}/drivers/wiznet5k/ethernet/w${MICROPY_PY_WIZNET5K}) 
+endif()
+
 add_executable(${MICROPY_TARGET})
 
 set(MICROPY_QSTRDEFS_PORT
@@ -75,19 +79,52 @@ set(MICROPY_SOURCE_LIB
     ${MICROPY_DIR}/shared/runtime/stdout_helpers.c
     ${MICROPY_DIR}/shared/runtime/sys_stdio_mphal.c
     ${MICROPY_DIR}/shared/timeutils/timeutils.c
-)
+    # axtls
+    ${MICROPY_DIR}/lib/axtls/ssl/loader.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/tls1.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/tls1_svr.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/tls1_clnt.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/x509.c
+    ${MICROPY_DIR}/lib/axtls/ssl/openssl.c 
+    ${MICROPY_DIR}/lib/axtls/ssl/os_port.c
+    ${MICROPY_DIR}/lib/axtls/ssl/asn1.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/aes.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/bigint.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/crypto_misc.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/md5.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/rsa.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/sha1.c 
+    ${MICROPY_DIR}/lib/axtls/crypto/hmac.c 
 
-set(MICROPY_SOURCE_DRIVERS
-    ${MICROPY_DIR}/drivers/bus/softspi.c
-    ${MICROPY_DIR}/drivers/dht/dht.c
 )
 
+
+if (MICROPY_PY_WIZNET5K)
+    set(MICROPY_SOURCE_DRIVERS
+        ${MICROPY_DIR}/drivers/bus/softspi.c
+    	${MICROPY_DIR}/drivers/wiznet5k/ethernet/w${MICROPY_PY_WIZNET5K}/w${MICROPY_PY_WIZNET5K}.c
+        ${MICROPY_DIR}/drivers/wiznet5k/ethernet/socket.c
+        ${MICROPY_DIR}/drivers/wiznet5k/ethernet/wizchip_conf.c
+        ${MICROPY_DIR}/drivers/wiznet5k/internet/dns/dns.c
+        ${MICROPY_DIR}/drivers/wiznet5k/internet/dhcp/dhcp.c
+        ${MICROPY_DIR}/extmod/modnetwork.c
+        ${MICROPY_DIR}/extmod/modusocket.c
+        ${PROJECT_SOURCE_DIR}/modnwwiznet5k.c
+#        ${MICROPY_DIR}/drivers/dht/dht.c
+      )
+else()
+    set(MICROPY_SOURCE_DRIVERS
+        ${MICROPY_DIR}/drivers/bus/softspi.c
+#        ${MICROPY_DIR}/drivers/dht/dht.c
+       )
+	
+endif()
 set(MICROPY_SOURCE_PORT
     fatfs_port.c
     machine_adc.c
-    machine_bitstream.c
+ #   machine_bitstream.c
     machine_i2c.c
-    machine_i2s.c
+ #   machine_i2s.c
     machine_pin.c
     machine_rtc.c
     machine_spi.c
@@ -113,9 +150,12 @@ set(MICROPY_SOURCE_QSTR
     ${MICROPY_SOURCE_USERMOD}
     ${MICROPY_DIR}/shared/runtime/mpirq.c
     ${MICROPY_DIR}/shared/runtime/sys_stdio_mphal.c
+    ${MICROPY_DIR}/extmod/modnetwork.c
+    ${MICROPY_DIR}/extmod/modusocket.c
+    ${MICROPY_DIR}/extmod/modussl_axtls.c
     ${PROJECT_SOURCE_DIR}/machine_adc.c
     ${PROJECT_SOURCE_DIR}/machine_i2c.c
-    ${PROJECT_SOURCE_DIR}/machine_i2s.c
+ #   ${PROJECT_SOURCE_DIR}/machine_i2s.c
     ${PROJECT_SOURCE_DIR}/machine_pin.c
     ${PROJECT_SOURCE_DIR}/machine_rtc.c
     ${PROJECT_SOURCE_DIR}/machine_spi.c
@@ -123,6 +163,7 @@ set(MICROPY_SOURCE_QSTR
     ${PROJECT_SOURCE_DIR}/machine_uart.c
     ${PROJECT_SOURCE_DIR}/machine_wdt.c
     ${PROJECT_SOURCE_DIR}/modmachine.c
+    ${PROJECT_SOURCE_DIR}/modnwwiznet5k.c
     ${PROJECT_SOURCE_DIR}/modrp2.c
     ${PROJECT_SOURCE_DIR}/moduos.c
     ${PROJECT_SOURCE_DIR}/modutime.c
@@ -191,30 +232,30 @@ if(MICROPY_BLUETOOTH_NIMBLE)
     list(APPEND MICROPY_INC_CORE ${NIMBLE_INCLUDE})
 endif()
 
-if (MICROPY_PY_NETWORK_NINAW10)
-    target_compile_definitions(${MICROPY_TARGET} PRIVATE
-        MICROPY_PY_NETWORK_NINAW10=1
-    )
-
-    target_include_directories(${MICROPY_TARGET} PRIVATE
-        ${MICROPY_DIR}/drivers/ninaw10/
-    )
-
-    # Enable NINA-W10 WiFi and Bluetooth drivers.
-    list(APPEND MICROPY_SOURCE_DRIVERS
-        ${MICROPY_DIR}/drivers/ninaw10/nina_bt_hci.c
-        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_drv.c
-        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_bsp.c
-    )
-
-    list(APPEND MICROPY_SOURCE_EXTMOD
-        ${MICROPY_DIR}/extmod/network_ninaw10.c
-    )
-
-    list(APPEND MICROPY_SOURCE_QSTR
-        ${MICROPY_DIR}/extmod/network_ninaw10.c
-    )
-endif()
+#if (MICROPY_PY_NETWORK_NINAW10)
+#    target_compile_definitions(${MICROPY_TARGET} PRIVATE
+#        MICROPY_PY_NETWORK_NINAW10=1
+#    )
+#
+#    target_include_directories(${MICROPY_TARGET} PRIVATE
+#        ${MICROPY_DIR}/drivers/ninaw10/
+#    )
+#
+#    # Enable NINA-W10 WiFi and Bluetooth drivers.
+#    list(APPEND MICROPY_SOURCE_DRIVERS
+#        ${MICROPY_DIR}/drivers/ninaw10/nina_bt_hci.c
+#        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_drv.c
+#        ${MICROPY_DIR}/drivers/ninaw10/nina_wifi_bsp.c
+#    )
+#
+#    list(APPEND MICROPY_SOURCE_EXTMOD
+#        ${MICROPY_DIR}/extmod/network_ninaw10.c
+#    )
+#
+#    list(APPEND MICROPY_SOURCE_QSTR
+#        ${MICROPY_DIR}/extmod/network_ninaw10.c
+#    )
+#endif()
 
 # Define mpy-cross flags and frozen manifest
 set(MICROPY_CROSS_FLAGS -march=armv7m)
@@ -231,14 +272,26 @@ target_sources(${MICROPY_TARGET} PRIVATE
 )
 
 target_link_libraries(${MICROPY_TARGET} usermod)
-
-target_include_directories(${MICROPY_TARGET} PRIVATE
-    ${MICROPY_INC_CORE}
-    ${MICROPY_INC_USERMOD}
-    ${MICROPY_BOARD_DIR}
-    "${PROJECT_SOURCE_DIR}"
-    "${CMAKE_BINARY_DIR}"
-)
+if (MICROPY_PY_WIZNET5K) 
+    target_include_directories(${MICROPY_TARGET} PRIVATE
+       ${MICROPY_INC_CORE}
+       ${MICROPY_INC_USERMOD}
+       ${MICROPY_BOARD_DIR}
+       "${PROJECT_SOURCE_DIR}"
+       "${CMAKE_BINARY_DIR}"
+       "${MICROPY_DIR}/driver/wiznet5k"
+       "${MICROPY_AXTLS_DIR}"
+    )
+else()
+    target_include_directories(${MICROPY_TARGET} PRIVATE
+        ${MICROPY_INC_CORE}
+        ${MICROPY_INC_USERMOD}
+        ${MICROPY_BOARD_DIR}
+        "${PROJECT_SOURCE_DIR}"
+        "${CMAKE_BINARY_DIR}"
+    )  
+endif()
+target_link_libraries(${MICROPY_TARGET} )
 
 target_compile_options(${MICROPY_TARGET} PRIVATE
     -Wall
@@ -258,20 +311,37 @@ set_source_files_properties(
     PROPERTIES
     COMPILE_OPTIONS "-Wno-error=array-bounds;-Wno-error=unused-but-set-variable"
 )
-
-target_compile_definitions(${MICROPY_TARGET} PRIVATE
-    FFCONF_H=\"${MICROPY_OOFATFS_DIR}/ffconf.h\"
-    LFS1_NO_MALLOC LFS1_NO_DEBUG LFS1_NO_WARN LFS1_NO_ERROR LFS1_NO_ASSERT
-    LFS2_NO_MALLOC LFS2_NO_DEBUG LFS2_NO_WARN LFS2_NO_ERROR LFS2_NO_ASSERT
-    PICO_FLOAT_PROPAGATE_NANS=1
-    PICO_STACK_SIZE=0x2000
-    PICO_CORE1_STACK_SIZE=0
-    PICO_PROGRAM_NAME="MicroPython"
-    PICO_NO_PROGRAM_VERSION_STRING=1 # do it ourselves in main.c
-    MICROPY_BUILD_TYPE="${CMAKE_C_COMPILER_ID} ${CMAKE_C_COMPILER_VERSION} ${CMAKE_BUILD_TYPE}"
-    PICO_NO_BI_STDIO_UART=1 # we call it UART REPL
-    PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1
-)
+if (MICROPY_PY_WIZNET5K)
+    target_compile_definitions(${MICROPY_TARGET} PRIVATE
+        FFCONF_H=\"${MICROPY_OOFATFS_DIR}/ffconf.h\"
+        LFS1_NO_MALLOC LFS1_NO_DEBUG LFS1_NO_WARN LFS1_NO_ERROR LFS1_NO_ASSERT
+        LFS2_NO_MALLOC LFS2_NO_DEBUG LFS2_NO_WARN LFS2_NO_ERROR LFS2_NO_ASSERT
+        PICO_FLOAT_PROPAGATE_NANS=1
+        PICO_STACK_SIZE=0x2000
+        PICO_CORE1_STACK_SIZE=0
+        PICO_PROGRAM_NAME="MicroPython"
+        PICO_NO_PROGRAM_VERSION_STRING=1 # do it ourselves in main.c
+        MICROPY_BUILD_TYPE="${CMAKE_C_COMPILER_ID} ${CMAKE_C_COMPILER_VERSION} ${CMAKE_BUILD_TYPE}"
+        PICO_NO_BI_STDIO_UART=1 # we call it UART REPL
+        PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1
+        -D_WIZCHIP_=${MICROPY_PY_WIZNET5K}
+        -DMICROPY_PY_WIZNET5K=${MICROPY_PY_WIZNET5K}
+   )
+else()
+    target_compile_definitions(${MICROPY_TARGET} PRIVATE
+        FFCONF_H=\"${MICROPY_OOFATFS_DIR}/ffconf.h\"
+        LFS1_NO_MALLOC LFS1_NO_DEBUG LFS1_NO_WARN LFS1_NO_ERROR LFS1_NO_ASSERT
+        LFS2_NO_MALLOC LFS2_NO_DEBUG LFS2_NO_WARN LFS2_NO_ERROR LFS2_NO_ASSERT
+        PICO_FLOAT_PROPAGATE_NANS=1
+        PICO_STACK_SIZE=0x2000
+        PICO_CORE1_STACK_SIZE=0
+        PICO_PROGRAM_NAME="MicroPython"
+        PICO_NO_PROGRAM_VERSION_STRING=1 # do it ourselves in main.c
+        MICROPY_BUILD_TYPE="${CMAKE_C_COMPILER_ID} ${CMAKE_C_COMPILER_VERSION} ${CMAKE_BUILD_TYPE}"
+        PICO_NO_BI_STDIO_UART=1 # we call it UART REPL
+        PICO_RP2040_USB_DEVICE_ENUMERATION_FIX=1
+   )
+endif()
 
 target_link_libraries(${MICROPY_TARGET}
     ${PICO_SDK_COMPONENTS}
diff --git a/ports/rp2/Makefile b/ports/rp2/Makefile
index 2af13bfbb..9d8cd7482 100644
--- a/ports/rp2/Makefile
+++ b/ports/rp2/Makefile
@@ -5,10 +5,12 @@
 BOARD ?= PICO
  
 BUILD ?= build-$(BOARD)
+MICROPY_PY_WIZNET5K ?= 5105
 
 $(VERBOSE)MAKESILENT = -s
 
 CMAKE_ARGS = -DMICROPY_BOARD=$(BOARD)
+CMAKE_ARGS += -DMICROPY_PY_WIZNET5K=$(MICROPY_PY_WIZNET5K)
 
 ifdef USER_C_MODULES
 CMAKE_ARGS += -DUSER_C_MODULES=${USER_C_MODULES}
@@ -20,8 +22,9 @@ all:
 
 clean:
 	$(RM) -rf $(BUILD)
+	$(RM) -rf out.log
 
-GIT_SUBMODULES += lib/pico-sdk lib/tinyusb
+GIT_SUBMODULES += lib/pico-sdk lib/tinyusb lib/axtls
 
 submodules:
 	$(MAKE) -f ../../py/mkrules.mk GIT_SUBMODULES="$(GIT_SUBMODULES)" submodules
diff --git a/ports/rp2/boards/manifest.py b/ports/rp2/boards/manifest.py
index b0e5e3155..a7850d269 100644
--- a/ports/rp2/boards/manifest.py
+++ b/ports/rp2/boards/manifest.py
@@ -1,5 +1,7 @@
 freeze("$(PORT_DIR)/modules")
 freeze("$(MPY_DIR)/drivers/onewire")
-freeze("$(MPY_DIR)/drivers/dht", "dht.py")
+#freeze('$(MPY_DIR)/drivers/dht', 'dht.py')
+freeze('$(MPY_DIR)/tools','upip.py')
+freeze('$(MPY_DIR)/tools','upip_utarfile.py',opt=3)
 include("$(MPY_DIR)/extmod/uasyncio/manifest.py")
-include("$(MPY_DIR)/drivers/neopixel/manifest.py")
+#include("$(MPY_DIR)/drivers/neopixel/manifest.py")
diff --git a/ports/rp2/machine_i2s.c b/ports/rp2/machine_i2s.c
index ec64f72ec..9561a4070 100644
--- a/ports/rp2/machine_i2s.c
+++ b/ports/rp2/machine_i2s.c
@@ -227,13 +227,13 @@ STATIC uint8_t dma_get_bits(i2s_mode_t mode, int8_t bits);
 STATIC void dma_irq0_handler(void);
 STATIC void dma_irq1_handler(void);
 STATIC mp_obj_t machine_i2s_deinit(mp_obj_t self_in);
-
+/*
 void machine_i2s_init0(void) {
     for (uint8_t i = 0; i < MAX_I2S_RP2; i++) {
         MP_STATE_PORT(machine_i2s_obj[i]) = NULL;
     }
 }
-
+*/
 // Ring Buffer
 // Thread safe when used with these constraints:
 // - Single Producer, Single Consumer
diff --git a/ports/rp2/machine_pin.h b/ports/rp2/machine_pin.h
new file mode 100644
index 000000000..2932933e6
--- /dev/null
+++ b/ports/rp2/machine_pin.h
@@ -0,0 +1,54 @@
+
+#include "py/obj.h"
+
+
+#include "hardware/irq.h"
+#include "hardware/regs/intctrl.h"
+#include "hardware/structs/iobank0.h"
+#include "hardware/structs/padsbank0.h"
+
+#include "py/runtime.h"
+#include "py/mphal.h"
+#include "shared/runtime/mpirq.h"
+#include "modmachine.h"
+#include "extmod/virtpin.h"
+
+#define GPIO_MODE_IN (0)
+#define GPIO_MODE_OUT (1)
+#define GPIO_MODE_OPEN_DRAIN (2)
+#define GPIO_MODE_ALT (3)
+
+// These can be or'd together.
+#define GPIO_PULL_UP (1)
+#define GPIO_PULL_DOWN (2)
+
+#define GPIO_IRQ_ALL (0xf)
+
+// Macros to access the state of the hardware.
+#define GPIO_GET_FUNCSEL(id) ((iobank0_hw->io[(id)].ctrl & IO_BANK0_GPIO0_CTRL_FUNCSEL_BITS) >> IO_BANK0_GPIO0_CTRL_FUNCSEL_LSB)
+#define GPIO_IS_OUT(id) (sio_hw->gpio_oe & (1 << (id)))
+#define GPIO_IS_PULL_UP(id) (padsbank0_hw->io[(id)] & PADS_BANK0_GPIO0_PUE_BITS)
+#define GPIO_IS_PULL_DOWN(id) (padsbank0_hw->io[(id)] & PADS_BANK0_GPIO0_PDE_BITS)
+
+// Open drain behaviour is simulated.
+#define GPIO_IS_OPEN_DRAIN(id) (machine_pin_open_drain_mask & (1 << (id)))
+
+typedef struct _machine_pin_obj_t {
+    mp_obj_base_t base;
+    uint32_t id;
+} machine_pin_obj_t;
+
+typedef struct _machine_pin_irq_obj_t {
+    mp_irq_obj_t base;
+    uint32_t flags;
+    uint32_t trigger;
+} machine_pin_irq_obj_t;
+mp_hal_pin_obj_t mp_hal_get_pin_obj(mp_obj_t obj);
+
+
+void machine_pin_init(void);
+void machine_pin_deinit(void);
+
+
+
+
diff --git a/ports/rp2/machine_spi.c b/ports/rp2/machine_spi.c
index 332f44694..4e7fa787e 100644
--- a/ports/rp2/machine_spi.c
+++ b/ports/rp2/machine_spi.c
@@ -24,51 +24,9 @@
  * THE SOFTWARE.
  */
 
-#include "py/runtime.h"
-#include "py/mphal.h"
-#include "py/mperrno.h"
-#include "extmod/machine_spi.h"
-#include "modmachine.h"
 
-#include "hardware/spi.h"
-#include "hardware/dma.h"
-
-#define DEFAULT_SPI_BAUDRATE    (1000000)
-#define DEFAULT_SPI_POLARITY    (0)
-#define DEFAULT_SPI_PHASE       (0)
-#define DEFAULT_SPI_BITS        (8)
-#define DEFAULT_SPI_FIRSTBIT    (SPI_MSB_FIRST)
-
-#ifndef MICROPY_HW_SPI0_SCK
-#define MICROPY_HW_SPI0_SCK     (6)
-#define MICROPY_HW_SPI0_MOSI    (7)
-#define MICROPY_HW_SPI0_MISO    (4)
-#endif
-
-#ifndef MICROPY_HW_SPI1_SCK
-#define MICROPY_HW_SPI1_SCK     (10)
-#define MICROPY_HW_SPI1_MOSI    (11)
-#define MICROPY_HW_SPI1_MISO    (8)
-#endif
-
-#define IS_VALID_PERIPH(spi, pin)   ((((pin) & 8) >> 3) == (spi))
-#define IS_VALID_SCK(spi, pin)      (((pin) & 3) == 2 && IS_VALID_PERIPH(spi, pin))
-#define IS_VALID_MOSI(spi, pin)     (((pin) & 3) == 3 && IS_VALID_PERIPH(spi, pin))
-#define IS_VALID_MISO(spi, pin)     (((pin) & 3) == 0 && IS_VALID_PERIPH(spi, pin))
-
-typedef struct _machine_spi_obj_t {
-    mp_obj_base_t base;
-    spi_inst_t *const spi_inst;
-    uint8_t spi_id;
-    uint8_t polarity;
-    uint8_t phase;
-    uint8_t bits;
-    uint8_t firstbit;
-    uint8_t sck;
-    uint8_t mosi;
-    uint8_t miso;
-    uint32_t baudrate;
-} machine_spi_obj_t;
+#include "machine_spi.h"
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
 
 STATIC machine_spi_obj_t machine_spi_obj[] = {
     {
@@ -208,8 +166,8 @@ STATIC void machine_spi_init(mp_obj_base_t *self_in, size_t n_args, const mp_obj
         spi_set_format(self->spi_inst, self->bits, self->polarity, self->phase, self->firstbit);
     }
 }
-
-STATIC void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest) {
+#if 0
+ void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest) {
     machine_spi_obj_t *self = (machine_spi_obj_t *)self_in;
     // Use DMA for large transfers if channels are available
     const size_t dma_min_size_threshold = 32;
@@ -221,11 +179,16 @@ STATIC void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8
         chan_rx = dma_claim_unused_channel(false);
     }
     bool use_dma = chan_rx >= 0 && chan_tx >= 0;
+	if(use_dma==1)
+		printf("chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
+	else if(chan_rx >=0 || chan_tx >=0)
+		printf("Not DMA : chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
     // note src is guaranteed to be non-NULL
     bool write_only = dest == NULL;
 
     if (use_dma) {
         uint8_t dev_null;
+		printf("Use Dma\r\n");
         dma_channel_config c = dma_channel_get_default_config(chan_tx);
         channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
         channel_config_set_dreq(&c, spi_get_index(self->spi_inst) ? DREQ_SPI1_TX : DREQ_SPI0_TX);
@@ -247,27 +210,121 @@ STATIC void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8
             false);
 
         dma_start_channel_mask((1u << chan_rx) | (1u << chan_tx));
+		printf("1\r\n");
         dma_channel_wait_for_finish_blocking(chan_rx);
+		printf("2\r\n");
         dma_channel_wait_for_finish_blocking(chan_tx);
+		printf("3\r\n");
     }
 
     // If we have claimed only one channel successfully, we should release immediately
     if (chan_rx >= 0) {
+		printf("4\r\n");
         dma_channel_unclaim(chan_rx);
+		printf("5\r\n");
     }
     if (chan_tx >= 0) {
+		printf("6\r\n");
         dma_channel_unclaim(chan_tx);
+		printf("7\r\n");
     }
 
     if (!use_dma) {
+		//printf("Not Use Dma\r\n");
         // Use software for small transfers, or if couldn't claim two DMA channels
         if (write_only) {
+			//printf("4\r\n");
             spi_write_blocking(self->spi_inst, src, len);
+			//printf("5\r\n");
         } else {
+			//printf("6\r\n");
             spi_write_read_blocking(self->spi_inst, src, dest, len);
+			//printf("7\r\n");
         }
     }
 }
+#else
+ void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest) {
+    machine_spi_obj_t *self = (machine_spi_obj_t *)self_in;
+    // Use DMA for large transfers if channels are available
+    const size_t dma_min_size_threshold = 32;
+    int chan_tx = -1;
+    int chan_rx = -1;
+    if (len >= dma_min_size_threshold) {
+        // Use two DMA channels to service the two FIFOs
+        chan_tx = dma_claim_unused_channel(false);
+        chan_rx = dma_claim_unused_channel(false);
+    }
+    bool use_dma = chan_rx >= 0 && chan_tx >= 0;
+	/*if(use_dma==1)
+		printf("chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
+	else if(chan_rx >=0 || chan_tx >=0)
+		printf("Not DMA : chan_tx = %d , chan_rx = %d\r\n",chan_tx,chan_rx);
+    */
+    // note src is guaranteed to be non-NULL
+    bool write_only = dest == NULL;
+
+    if (use_dma) {
+        uint8_t dev_null;
+        dma_channel_config c = dma_channel_get_default_config(chan_tx);
+        channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
+        channel_config_set_dreq(&c, spi_get_index(self->spi_inst) ? DREQ_SPI1_TX : DREQ_SPI0_TX);
+        dma_channel_configure(chan_tx, &c,
+            &spi_get_hw(self->spi_inst)->dr,
+            write_only ? src : &dev_null,
+            len,
+            false);
+
+        c = dma_channel_get_default_config(chan_rx);
+        channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
+        channel_config_set_dreq(&c, spi_get_index(self->spi_inst) ? DREQ_SPI1_RX : DREQ_SPI0_RX);
+        channel_config_set_read_increment(&c, false);
+        channel_config_set_write_increment(&c, !write_only);
+        dma_channel_configure(chan_rx, &c,
+            write_only ? &dev_null : dest,
+            &spi_get_hw(self->spi_inst)->dr,
+            len,
+            false);
+
+        dma_start_channel_mask((1u << chan_rx) | (1u << chan_tx));
+        dma_channel_wait_for_finish_blocking(chan_rx);
+        //dma_channel_wait_for_finish_blocking(chan_tx);
+    }
+
+    // If we have claimed only one channel successfully, we should release immediately
+    if (chan_rx >= 0) {
+        dma_channel_unclaim(chan_rx);
+    }
+    if (chan_tx >= 0) {
+        dma_channel_unclaim(chan_tx);
+    }
+
+    if (!use_dma) {
+		//printf("Not Use Dma\r\n");
+        // Use software for small transfers, or if couldn't claim two DMA channels
+        if (write_only) {
+			//printf("4\r\n");
+            spi_write_blocking(self->spi_inst, src, len);
+			//printf("5\r\n");
+        } else {
+			//printf("6\r\n");
+            spi_write_read_blocking(self->spi_inst, src, dest, len);
+			//printf("7\r\n");
+        }
+    }
+}
+#endif
+
+machine_spi_obj_t *spi_from_mp_obj(mp_obj_t o) {
+ if (mp_obj_is_type(o, &machine_spi_type)) {
+        machine_spi_obj_t *self = MP_OBJ_TO_PTR(o);
+        //return self->spi_inst;
+        return self;
+    } else {
+        mp_raise_TypeError(MP_ERROR_TEXT("expecting an SPI object"));
+    }
+}
+
 
 STATIC const mp_machine_spi_p_t machine_spi_p = {
     .init = machine_spi_init,
diff --git a/ports/rp2/machine_spi.h b/ports/rp2/machine_spi.h
new file mode 100644
index 000000000..802703da2
--- /dev/null
+++ b/ports/rp2/machine_spi.h
@@ -0,0 +1,99 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2013, 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+
+#include "drivers/bus/spi.h"
+#include "py/runtime.h"
+#include "py/mphal.h"
+#include "py/mperrno.h"
+#include "extmod/machine_spi.h"
+#include "modmachine.h"
+#include "hardware/spi.h"
+#include "hardware/dma.h"
+
+
+#define DEFAULT_SPI_BAUDRATE    (1000000)
+#define DEFAULT_SPI_POLARITY    (0)
+#define DEFAULT_SPI_PHASE       (0)
+#define DEFAULT_SPI_BITS        (8)
+#define DEFAULT_SPI_FIRSTBIT    (SPI_MSB_FIRST)
+/*
+#ifndef MICROPY_HW_SPI0_SCK
+#define MICROPY_HW_SPI0_SCK     (6)
+#define MICROPY_HW_SPI0_MOSI    (7)
+#define MICROPY_HW_SPI0_MISO    (4)
+#endif
+
+#ifndef MICROPY_HW_SPI1_SCK
+#define MICROPY_HW_SPI1_SCK     (10)
+#define MICROPY_HW_SPI1_MOSI    (11)
+#define MICROPY_HW_SPI1_MISO    (8)
+#endif
+*/
+
+//#ifndef MICROPY_HW_SPI0_SCK
+#define MICROPY_HW_SPI0_SCK     (18)
+#define MICROPY_HW_SPI0_MOSI    (16)
+#define MICROPY_HW_SPI0_MISO    (19)
+//#endif
+
+//#ifndef MICROPY_HW_SPI1_SCK
+#define MICROPY_HW_SPI1_SCK     (10)
+#define MICROPY_HW_SPI1_MOSI    (11)
+#define MICROPY_HW_SPI1_MISO    (8)
+//#endif
+
+#define IS_VALID_PERIPH(spi, pin)   ((((pin) & 8) >> 3) == (spi))
+#define IS_VALID_SCK(spi, pin)      (((pin) & 3) == 2 && IS_VALID_PERIPH(spi, pin))
+#define IS_VALID_MOSI(spi, pin)     (((pin) & 3) == 3 && IS_VALID_PERIPH(spi, pin))
+#define IS_VALID_MISO(spi, pin)     (((pin) & 3) == 0 && IS_VALID_PERIPH(spi, pin))
+
+
+typedef struct _machine_spi_obj_t {
+    mp_obj_base_t base;
+    spi_inst_t *const spi_inst;
+    uint8_t spi_id;
+    uint8_t polarity;
+    uint8_t phase;
+    uint8_t bits;
+    uint8_t firstbit;
+    uint8_t sck;
+    uint8_t mosi;
+    uint8_t miso;
+    uint32_t baudrate;
+} machine_spi_obj_t;
+
+/*
+void machine_spi_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind);
+void machine_spi_init(mp_obj_base_t *self_in, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args);
+void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest);
+const spi_inst_t *spi_from_mp_obj(mp_obj_t o);
+*/
+
+machine_spi_obj_t *spi_from_mp_obj(mp_obj_t o);
+void machine_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest);
+
+
diff --git a/ports/rp2/main.c b/ports/rp2/main.c
index 84f23af23..001a3e9e2 100644
--- a/ports/rp2/main.c
+++ b/ports/rp2/main.c
@@ -50,8 +50,8 @@
 #include "hardware/structs/rosc.h"
 
 extern uint8_t __StackTop, __StackBottom;
-static char gc_heap[192 * 1024];
-
+//static char gc_heap[192 * 1024]; 
+static char gc_heap[50 * 1024]; //irina
 // Embed version info in the binary in machine readable form
 bi_decl(bi_program_version_string(MICROPY_GIT_TAG));
 
@@ -106,7 +106,7 @@ int main(int argc, char **argv) {
         readline_init0();
         machine_pin_init();
         rp2_pio_init();
-        machine_i2s_init0();
+       // machine_i2s_init0();
 
         #if MICROPY_PY_BLUETOOTH
         mp_bluetooth_hci_init();
diff --git a/ports/rp2/modmachine.c b/ports/rp2/modmachine.c
index 9d6178a0f..0cd8dbf1c 100644
--- a/ports/rp2/modmachine.c
+++ b/ports/rp2/modmachine.c
@@ -167,7 +167,7 @@ STATIC const mp_rom_map_elem_t machine_module_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR_ADC),                 MP_ROM_PTR(&machine_adc_type) },
     { MP_ROM_QSTR(MP_QSTR_I2C),                 MP_ROM_PTR(&machine_hw_i2c_type) },
     { MP_ROM_QSTR(MP_QSTR_SoftI2C),             MP_ROM_PTR(&mp_machine_soft_i2c_type) },
-    { MP_ROM_QSTR(MP_QSTR_I2S),                 MP_ROM_PTR(&machine_i2s_type) },
+  //  { MP_ROM_QSTR(MP_QSTR_I2S),                 MP_ROM_PTR(&machine_i2s_type) },
     { MP_ROM_QSTR(MP_QSTR_Pin),                 MP_ROM_PTR(&machine_pin_type) },
     { MP_ROM_QSTR(MP_QSTR_PWM),                 MP_ROM_PTR(&machine_pwm_type) },
     { MP_ROM_QSTR(MP_QSTR_RTC),                 MP_ROM_PTR(&machine_rtc_type) },
diff --git a/ports/rp2/modmachine.h b/ports/rp2/modmachine.h
index af02cd193..49fd67bed 100644
--- a/ports/rp2/modmachine.h
+++ b/ports/rp2/modmachine.h
@@ -5,7 +5,7 @@
 
 extern const mp_obj_type_t machine_adc_type;
 extern const mp_obj_type_t machine_hw_i2c_type;
-extern const mp_obj_type_t machine_i2s_type;
+//extern const mp_obj_type_t machine_i2s_type;
 extern const mp_obj_type_t machine_pin_type;
 extern const mp_obj_type_t machine_rtc_type;
 extern const mp_obj_type_t machine_spi_type;
diff --git a/ports/rp2/modnwwiznet5k.c b/ports/rp2/modnwwiznet5k.c
new file mode 100644
<<<<<<< HEAD
index 000000000..4ca59e838
--- /dev/null
+++ b/ports/rp2/modnwwiznet5k.c
@@ -0,0 +1,621 @@
=======
index 000000000..94714beb3
--- /dev/null
+++ b/ports/rp2/modnwwiznet5k.c
@@ -0,0 +1,627 @@
>>>>>>> dev
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+
+#include <stdint.h>
+#include <string.h>
+
+#include "py/objlist.h"
+#include "py/runtime.h"
+#include "py/stream.h"
+#include "py/mperrno.h"
+#include "py/mphal.h"
+#include "shared/netutils/netutils.h"
+#include "extmod/modnetwork.h"
+#include "machine_spi.h"
+#include "machine_pin.h"
+//#include "pin.h"
+#include "modmachine.h"
+#include "hardware/spi.h"
+
+#if MICROPY_PY_WIZNET5K && !MICROPY_PY_LWIP
+#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)
+#include "ethernet/wizchip_conf.h"
+#include "ethernet/socket.h"
+#include "internet/dns/dns.h"
+#include "internet/dhcp/dhcp.h"
+
+typedef struct _wiznet5k_obj_t {
+    mp_obj_base_t base;
+    mp_uint_t cris_state;
+    machine_spi_obj_t *spi;
+    machine_pin_obj_t cs;
+    machine_pin_obj_t rst;
+    wiz_NetInfo netinfo;
+    uint8_t socket_used;
+} wiznet5k_obj_t;
+
+wiznet5k_obj_t wiznet5k_obj;
+STATIC mp_obj_t wiznet5k_init(wiznet5k_obj_t *self);
+STATIC void wiz_dhcp_assign(void);
+STATIC void wiz_dhcp_update(void);
+STATIC void wiz_dhcp_conflict(void);
+
+STATIC void wiz_cris_enter(void) {
+    wiznet5k_obj.cris_state = MICROPY_BEGIN_ATOMIC_SECTION();
+}
+
+STATIC void wiz_cris_exit(void) {
+    MICROPY_END_ATOMIC_SECTION(wiznet5k_obj.cris_state);
+}
+
+STATIC void wiz_cs_select(void) {
+
+	mp_hal_pin_write(wiznet5k_obj.cs.id,0);
+}
+
+STATIC void wiz_cs_deselect(void) {
+
+   mp_hal_pin_write(wiznet5k_obj.cs.id,1);
+
+}
+
+
+STATIC void wiz_spi_read(uint8_t *buf, uint32_t len) {
+    //uint8_t tx_buf[100]; 
+    uint8_t tx_buf[2048];
+    machine_spi_transfer((mp_obj_base_t*)wiznet5k_obj.spi ,len, tx_buf ,buf);
+
+}
+
+STATIC void wiz_spi_write(const uint8_t *buf, uint32_t len) {
+    machine_spi_transfer((mp_obj_base_t *)wiznet5k_obj.spi ,len,buf,NULL);
+}
+
+STATIC void wiz_dhcp_assign(void)
+{ 
+    getIPfromDHCP(wiznet5k_obj.netinfo.ip);
+    getGWfromDHCP(wiznet5k_obj.netinfo.gw);
+    getSNfromDHCP(wiznet5k_obj.netinfo.sn);
+    getDNSfromDHCP(wiznet5k_obj.netinfo.dns);
+    ctlnetwork(CN_SET_NETINFO, (void *)&wiznet5k_obj.netinfo);
+}
+
+
+STATIC void wiz_dhcp_update(void)
+{
+    ;
+}
+
+
+STATIC void wiz_dhcp_conflict(void)
+{
+    ;
+}
+
+
+STATIC int wiznet5k_gethostbyname(mp_obj_t nic, const char *name, mp_uint_t len, uint8_t *out_ip) {
+    uint8_t dns_ip[MOD_NETWORK_IPADDR_BUF_SIZE] = {8, 8, 8, 8};
+  
+
+    //uint8_t dns_ip[MOD_NETWORK_IPADDR_BUF_SIZE] = {wiznet5k_obj.netinfo.dns[0],wiznet5k_obj.netinfo.dns[1],wiznet5k_obj.netinfo.dns[2],wiznet5k_obj.netinfo.dns[3]} ;
+    uint8_t *buf = m_new(uint8_t, MAX_DNS_BUF_SIZE);
+
+
+       
+    DNS_init(2, buf);
+    mp_int_t ret = DNS_run(dns_ip, (uint8_t *)name, out_ip);
+    m_del(uint8_t, buf, MAX_DNS_BUF_SIZE);
+    if (ret == 1) {
+        // success
+        return 0;
+    } else {
+        // failure
+        return -2;
+    }
+}
+
+STATIC int wiznet5k_socket_socket(mod_network_socket_obj_t *socket, int *_errno) {
+    if (socket->domain != MOD_NETWORK_AF_INET) {
+        *_errno = MP_EAFNOSUPPORT;
+        return -1;
+    }
+
+    switch (socket->type) {
+        case MOD_NETWORK_SOCK_STREAM:
+            socket->type = Sn_MR_TCP;
+            break;
+        case MOD_NETWORK_SOCK_DGRAM:
+            socket->type = Sn_MR_UDP;
+            break;
+        default:
+            *_errno = MP_EINVAL;
+            return -1;
+    }
+
+    if (socket->fileno == -1) {
+        // get first unused socket number
+        for (mp_uint_t sn = 0; sn < _WIZCHIP_SOCK_NUM_; sn++) {
+            if ((wiznet5k_obj.socket_used & (1 << sn)) == 0) {
+                wiznet5k_obj.socket_used |= (1 << sn);
+                socket->fileno = sn;
+                break;
+            }
+        }
+        if (socket->fileno == -1) {
+            // too many open sockets
+            *_errno = MP_EMFILE;
+            return -1;
+        }
+    }
+
+    // WIZNET does not have a concept of pure "open socket".  You need to know
+    // if it's a server or client at the time of creation of the socket.
+    // So, we defer the open until we know what kind of socket we want.
+
+    // use "domain" to indicate that this socket has not yet been opened
+    socket->domain = 0;
+
+    return 0;
+}
+
+STATIC void wiznet5k_socket_close(mod_network_socket_obj_t *socket) {
+    uint8_t sn = (uint8_t)socket->fileno;
+    if (sn < _WIZCHIP_SOCK_NUM_) {
+        wiznet5k_obj.socket_used &= ~(1 << sn);
+        WIZCHIP_EXPORT(close)(sn);
+    }
+}
+
+STATIC int wiznet5k_socket_bind(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {
+    // open the socket in server mode (if port != 0)
+    mp_int_t ret = WIZCHIP_EXPORT(socket)(socket->fileno, socket->type, port, 0);
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+
+    // indicate that this socket has been opened
+    socket->domain = 1;
+
+    // success
+    return 0;
+}
+
+STATIC int wiznet5k_socket_listen(mod_network_socket_obj_t *socket, mp_int_t backlog, int *_errno) {
+    mp_int_t ret = WIZCHIP_EXPORT(listen)(socket->fileno);
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return 0;
+}
+
+STATIC int wiznet5k_socket_accept(mod_network_socket_obj_t *socket, mod_network_socket_obj_t *socket2, byte *ip, mp_uint_t *port, int *_errno) {
+    for (;;) {
+        int sr = getSn_SR((uint8_t)socket->fileno);
+        if (sr == SOCK_ESTABLISHED) {
+            socket2->domain = socket->domain;
+            socket2->type = socket->type;
+            socket2->fileno = socket->fileno;
+            getSn_DIPR((uint8_t)socket2->fileno, ip);
+            *port = getSn_PORT(socket2->fileno);
+
+            // WIZnet turns the listening socket into the client socket, so we
+            // need to re-bind and re-listen on another socket for the server.
+            // TODO handle errors, especially no-more-sockets error
+            socket->domain = MOD_NETWORK_AF_INET;
+            socket->fileno = -1;
+            int _errno2;
+            if (wiznet5k_socket_socket(socket, &_errno2) != 0) {
+                // printf("(bad resocket %d)\n", _errno2);
+            } else if (wiznet5k_socket_bind(socket, NULL, *port, &_errno2) != 0) {
+                // printf("(bad rebind %d)\n", _errno2);
+            } else if (wiznet5k_socket_listen(socket, 0, &_errno2) != 0) {
+                // printf("(bad relisten %d)\n", _errno2);
+            }
+
+            return 0;
+        }
+        if (sr == SOCK_CLOSED || sr == SOCK_CLOSE_WAIT) {
+            wiznet5k_socket_close(socket);
+            *_errno = MP_ENOTCONN; // ??
+            return -1;
+        }
+        mp_hal_delay_ms(1);
+    }
+}
+
+STATIC int wiznet5k_socket_connect(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {
+    // use "bind" function to open the socket in client mode
+    if (wiznet5k_socket_bind(socket, ip, 0, _errno) != 0) {
+        return -1;
+    }
+
+    // now connect
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(connect)(socket->fileno, ip, port);
+    MP_THREAD_GIL_ENTER();
+
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+
+    // success
+    return 0;
+}
+
+STATIC mp_uint_t wiznet5k_socket_send(mod_network_socket_obj_t *socket, const byte *buf, mp_uint_t len, int *_errno) {
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(send)(socket->fileno, (byte *)buf, len);
+    MP_THREAD_GIL_ENTER();
+
+    // TODO convert Wiz errno's to POSIX ones
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC mp_uint_t wiznet5k_socket_recv(mod_network_socket_obj_t *socket, byte *buf, mp_uint_t len, int *_errno) {
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(recv)(socket->fileno, buf, len);
+    MP_THREAD_GIL_ENTER();
+
+    // TODO convert Wiz errno's to POSIX ones
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC mp_uint_t wiznet5k_socket_sendto(mod_network_socket_obj_t *socket, const byte *buf, mp_uint_t len, byte *ip, mp_uint_t port, int *_errno) {
+    if (socket->domain == 0) {
+        // socket not opened; use "bind" function to open the socket in client mode
+        if (wiznet5k_socket_bind(socket, ip, 0, _errno) != 0) {
+            return -1;
+        }
+    }
+
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(sendto)(socket->fileno, (byte *)buf, len, ip, port);
+    MP_THREAD_GIL_ENTER();
+
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC mp_uint_t wiznet5k_socket_recvfrom(mod_network_socket_obj_t *socket, byte *buf, mp_uint_t len, byte *ip, mp_uint_t *port, int *_errno) {
+    uint16_t port2;
+    MP_THREAD_GIL_EXIT();
+    mp_int_t ret = WIZCHIP_EXPORT(recvfrom)(socket->fileno, buf, len, ip, &port2);
+    MP_THREAD_GIL_ENTER();
+    *port = port2;
+    if (ret < 0) {
+        wiznet5k_socket_close(socket);
+        *_errno = -ret;
+        return -1;
+    }
+    return ret;
+}
+
+STATIC int wiznet5k_socket_setsockopt(mod_network_socket_obj_t *socket, mp_uint_t level, mp_uint_t opt, const void *optval, mp_uint_t optlen, int *_errno) {
+    // TODO
+    *_errno = MP_EINVAL;
+    return -1;
+}
+
+STATIC int wiznet5k_socket_settimeout(mod_network_socket_obj_t *socket, mp_uint_t timeout_ms, int *_errno) {
+    // TODO
+    *_errno = MP_EINVAL;
+    return -1;
+
+    /*
+    if (timeout_ms == 0) {
+        // set non-blocking mode
+        uint8_t arg = SOCK_IO_NONBLOCK;
+        WIZCHIP_EXPORT(ctlsocket)(socket->fileno, CS_SET_IOMODE, &arg);
+    }
+    */
+}
+
+STATIC int wiznet5k_socket_ioctl(mod_network_socket_obj_t *socket, mp_uint_t request, mp_uint_t arg, int *_errno) {
+    if (request == MP_STREAM_POLL) {
+        int ret = 0;
+        if (arg & MP_STREAM_POLL_RD && getSn_RX_RSR(socket->fileno) != 0) {
+            ret |= MP_STREAM_POLL_RD;
+        }
+        if (arg & MP_STREAM_POLL_WR && getSn_TX_FSR(socket->fileno) != 0) {
+            ret |= MP_STREAM_POLL_WR;
+        }
+        return ret;
+    } else {
+        *_errno = MP_EINVAL;
+        return MP_STREAM_ERROR;
+    }
+}
+
+#if 0
+STATIC void wiznet5k_socket_print(void (*print)(void *env, const char *fmt, ...), void *env, mp_obj_t self_in, mp_print_kind_t kind) {
+    wiznet5k_socket_obj_t *self = self_in;
+    print(env, "<WIZNET5K.socket sn=%u MR=0x%02x>", self->sn, getSn_MR(self->sn));
+}
+
+STATIC mp_obj_t wiznet5k_socket_disconnect(mp_obj_t self_in) {
+    mp_int_t ret = WIZCHIP_EXPORT(disconnect)(self->sn);
+    return 0;
+}
+#endif
+
+/******************************************************************************/
+// MicroPython bindings
+
+/// \classmethod \constructor(spi, pin_cs, pin_rst)
+/// Create and return a WIZNET5K object.
+STATIC mp_obj_t wiznet5k_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
+    // check arguments
+    mp_arg_check_num(n_args, n_kw, 3, 3, false);
+	
+    machine_spi_obj_t *spi = spi_from_mp_obj(args[0]);
+    mp_hal_pin_obj_t cs = mp_hal_get_pin_obj(args[1]);
+    mp_hal_pin_obj_t rst = mp_hal_get_pin_obj(args[2]);
+
+    // init the wiznet5k object
+    wiznet5k_obj.base.type = (mp_obj_type_t *)&mod_network_nic_type_wiznet5k;
+    wiznet5k_obj.cris_state = 0;
+    wiznet5k_obj.spi = spi;
+    wiznet5k_obj.cs.id= cs;
+    wiznet5k_obj.rst.id = rst;
+
+    wiznet5k_obj.socket_used = 0;
+
+    spi_init(wiznet5k_obj.spi->spi_inst, 48000);
+	
+    mp_hal_pin_output(wiznet5k_obj.cs.id);
+    mp_hal_pin_output(wiznet5k_obj.rst.id);
+
+    mp_hal_pin_write(wiznet5k_obj.rst.id,0);
+    mp_hal_delay_ms(1); // datasheet says 2us
+    mp_hal_pin_write(wiznet5k_obj.rst.id,1);
+    mp_hal_delay_ms(160); // datasheet says 150ms
+
+    reg_wizchip_cris_cbfunc(wiz_cris_enter, wiz_cris_exit);
+    reg_wizchip_cs_cbfunc(wiz_cs_select, wiz_cs_deselect);
+    reg_wizchip_spi_cbfunc(wiz_spi_read, wiz_spi_write);
+    reg_dhcp_cbfunc(wiz_dhcp_assign, wiz_dhcp_update, wiz_dhcp_conflict);
+    uint8_t sn_size[16] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; // 2k buffer for each socket
+    ctlwizchip(CW_INIT_WIZCHIP, sn_size);
+
+    // set some sensible default values; they are configurable using ifconfig method
+    wiz_NetInfo netinfo = {
+        .mac = {0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef},
+        .ip = {192, 168, 100, 18},
+        .sn = {255, 255, 255, 0},
+        .gw = {192, 168, 100, 1},
+        .dns = {8, 8, 8, 8}, // Google public DNS
+        .dhcp = NETINFO_STATIC,
+    };
+    wiznet5k_obj.netinfo = netinfo;
+    ctlnetwork(CN_SET_NETINFO, (void *)&wiznet5k_obj.netinfo);
+    // seems we need a small delay after init
+    mp_hal_delay_ms(250);
+
+    // register with network module
+    mod_network_register_nic(&wiznet5k_obj);
+
+    // return wiznet5k object
+    return &wiznet5k_obj;
+} 
+STATIC mp_obj_t wiznet5k_active(size_t n_args, const mp_obj_t *args) {
+    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);
<<<<<<< HEAD
+
=======
>>>>>>> dev
+    //wiz_NetInfo netinfo;
+    if (n_args == 1) {
+        return mp_const_none;
+    } else {
+        if (mp_obj_is_true(args[1])) {
+            self->netinfo.dhcp = NETINFO_DHCP;
+            //self->netinfo.mac = netinfo.mac;
+            wiznet5k_init((void *)self);
+
+            mp_obj_t tuple[4] = {
+                netutils_format_ipv4_addr(self->netinfo.ip, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.sn, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.gw, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.dns, NETUTILS_BIG),
+
+            };
+            
+            printf("netif changed  %d.%d.%d.%d\r\n",self->netinfo.ip[0],self->netinfo.ip[1],self->netinfo.ip[2],self->netinfo.ip[3]);
+            
+            return mp_obj_new_tuple(4, tuple); 
+        } else {
+            //self->netinfo = netinfo;
+            self->netinfo.dhcp = NETINFO_STATIC;
+                       
+            ctlnetwork(CN_SET_NETINFO, (void *)&self->netinfo);
+            ctlnetwork(CN_GET_NETINFO, (void *)&self->netinfo);
+        // get
+            mp_obj_t tuple[4] = {
+                netutils_format_ipv4_addr(self->netinfo.ip, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.sn, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.gw, NETUTILS_BIG),
+                netutils_format_ipv4_addr(self->netinfo.dns, NETUTILS_BIG),
+
+            };
+                return mp_obj_new_tuple(4, tuple);
+            
+        }
+        return mp_const_none;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_active_obj, 1, 2, wiznet5k_active);
+
+STATIC mp_obj_t wiznet5k_init(wiznet5k_obj_t *self){
+    uint8_t test_buf[2048];
+    
+    uint8_t ret =0;
+    uint8_t dhcp_retry=0;
+    DHCP_init(1, test_buf);
+    while (1)  {
+        /*if (mp_hal_ticks_ms() - start > 10000) {
+            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT("timeout waiting for DHCP to get IP address"));
+        }*/
+        ret = DHCP_run();
+        if (ret == DHCP_IP_LEASED) {
+            break;
+        }
+            else if (ret == DHCP_FAILED) {
+            dhcp_retry++;
+        }
+
+        if (dhcp_retry > 3) {
+            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT("timeout waiting for DHCP to get IP address"));
+             break;
+        }
+      }
+   
+    if(ret == DHCP_IP_LEASED){
+        ctlnetwork(CN_GET_NETINFO,&self->netinfo);
+        return  mp_const_none;
+    }
+    else {
+        
+        return  mp_const_none;
+    }
+
+}
+/// \method regs()
+/// Dump WIZNET5K registers.
+STATIC mp_obj_t wiznet5k_regs(mp_obj_t self_in) {
+    // wiznet5k_obj_t *self = self_in;
+    printf("Wiz CREG:");
+    for (int i = 0; i < 0x50; ++i) {
+        if (i % 16 == 0) {
+            printf("\n  %04x:", i);
+        }
+        #if MICROPY_PY_WIZNET5K <= 5200 
+        uint32_t reg = i;
+        #else
+        uint32_t reg = _WIZCHIP_IO_BASE_ | i << 8;
+        #endif
+        printf(" %02x", WIZCHIP_READ(reg));
+    }
+    for (int sn = 0; sn < 4; ++sn) {
+        printf("\nWiz SREG[%d]:", sn);
+        for (int i = 0; i < 0x30; ++i) {
+            if (i % 16 == 0) {
+                printf("\n  %04x:", i);
+            }
+            #if MICROPY_PY_WIZNET5K <= 5200
+            uint32_t reg = WIZCHIP_SREG_ADDR(sn, i);
+            #else
+            uint32_t reg = _WIZCHIP_IO_BASE_ | i << 8 | WIZCHIP_SREG_BLOCK(sn) << 3;
+            #endif
+            printf(" %02x", WIZCHIP_READ(reg));
+        }
+    }
+    printf("\n");
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(wiznet5k_regs_obj, wiznet5k_regs);
+
+STATIC mp_obj_t wiznet5k_isconnected(mp_obj_t self_in) {
+    (void)self_in;
+    #if MICROPY_PY_WIZNET5K == 5100
+     return mp_obj_new_bool( PHY_LINK_ON);
+    #else
+     return mp_obj_new_bool(wizphy_getphylink() == PHY_LINK_ON);
+    #endif
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(wiznet5k_isconnected_obj, wiznet5k_isconnected);
+
+/// \method ifconfig([(ip, subnet, gateway, dns)])
+/// Get/set IP address, subnet mask, gateway and DNS.
+STATIC mp_obj_t wiznet5k_ifconfig(size_t n_args, const mp_obj_t *args) {
+    wiz_NetInfo netinfo;
+    ctlnetwork(CN_GET_NETINFO, &netinfo);
+    if (n_args == 1) {
+        // get
+        mp_obj_t tuple[4] = {
+            netutils_format_ipv4_addr(netinfo.ip, NETUTILS_BIG),
+            netutils_format_ipv4_addr(netinfo.sn, NETUTILS_BIG),
+            netutils_format_ipv4_addr(netinfo.gw, NETUTILS_BIG),
+            netutils_format_ipv4_addr(netinfo.dns, NETUTILS_BIG),
+        };
+        return mp_obj_new_tuple(4, tuple);
+    } else {
+        // set
+        mp_obj_t *items;
+        mp_obj_get_array_fixed_n(args[1], 4, &items);
+        netutils_parse_ipv4_addr(items[0], netinfo.ip, NETUTILS_BIG);
+        netutils_parse_ipv4_addr(items[1], netinfo.sn, NETUTILS_BIG);
+        netutils_parse_ipv4_addr(items[2], netinfo.gw, NETUTILS_BIG);
+        netutils_parse_ipv4_addr(items[3], netinfo.dns, NETUTILS_BIG);
+        ctlnetwork(CN_SET_NETINFO, &netinfo);
+        return mp_const_none;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_ifconfig_obj, 1, 2, wiznet5k_ifconfig);
+
+STATIC const mp_rom_map_elem_t wiznet5k_locals_dict_table[] = {
+    { MP_ROM_QSTR(MP_QSTR_regs), MP_ROM_PTR(&wiznet5k_regs_obj) },
+    { MP_ROM_QSTR(MP_QSTR_ifconfig), MP_ROM_PTR(&wiznet5k_ifconfig_obj) },
+    { MP_ROM_QSTR(MP_QSTR_active), MP_ROM_PTR(&wiznet5k_active_obj) },
+    { MP_ROM_QSTR(MP_QSTR_isconnected), MP_ROM_PTR(&wiznet5k_isconnected_obj) },
+};
+
+STATIC MP_DEFINE_CONST_DICT(wiznet5k_locals_dict, wiznet5k_locals_dict_table);
+
+const mod_network_nic_type_t mod_network_nic_type_wiznet5k = {
+    .base = {
+        { &mp_type_type },
+        .name = MP_QSTR_WIZNET5K,
+        .make_new = wiznet5k_make_new,
+        .locals_dict = (mp_obj_dict_t *)&wiznet5k_locals_dict,
+    },
+    .gethostbyname = wiznet5k_gethostbyname,
+    .socket = wiznet5k_socket_socket,
+    .close = wiznet5k_socket_close,
+    .bind = wiznet5k_socket_bind,
+    .listen = wiznet5k_socket_listen,
+    .accept = wiznet5k_socket_accept,
+    .connect = wiznet5k_socket_connect,
+    .send = wiznet5k_socket_send,
+    .recv = wiznet5k_socket_recv,
+    .sendto = wiznet5k_socket_sendto,
+    .recvfrom = wiznet5k_socket_recvfrom,
+    .setsockopt = wiznet5k_socket_setsockopt,
+    .settimeout = wiznet5k_socket_settimeout,
+    .ioctl = wiznet5k_socket_ioctl,
+};
+
+#endif // MICROPY_PY_WIZNET5K && !MICROPY_PY_LWIP
\ No newline at end of file
diff --git a/ports/rp2/modrp2.c b/ports/rp2/modrp2.c
index 15c61911d..f16d6bc6c 100644
--- a/ports/rp2/modrp2.c
+++ b/ports/rp2/modrp2.c
@@ -25,7 +25,7 @@
  */
 
 #include "py/runtime.h"
-#include "drivers/dht/dht.h"
+//#include "drivers/dht/dht.h"
 #include "modrp2.h"
 
 STATIC const mp_rom_map_elem_t rp2_module_globals_table[] = {
@@ -33,8 +33,8 @@ STATIC const mp_rom_map_elem_t rp2_module_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR_Flash),               MP_ROM_PTR(&rp2_flash_type) },
     { MP_ROM_QSTR(MP_QSTR_PIO),                 MP_ROM_PTR(&rp2_pio_type) },
     { MP_ROM_QSTR(MP_QSTR_StateMachine),        MP_ROM_PTR(&rp2_state_machine_type) },
-
-    { MP_ROM_QSTR(MP_QSTR_dht_readinto),        MP_ROM_PTR(&dht_readinto_obj) },
+//    { MP_ROM_QSTR(MP_QSTR_dht_readinto),        MP_ROM_PTR(&dht_readinto_obj) },
+    { MP_ROM_QSTR(MP_QSTR_SPI),					MP_ROM_PTR(&machine_spi_type)},
 };
 STATIC MP_DEFINE_CONST_DICT(rp2_module_globals, rp2_module_globals_table);
 
diff --git a/ports/rp2/modrp2.h b/ports/rp2/modrp2.h
index 805c785f2..db19b485d 100644
--- a/ports/rp2/modrp2.h
+++ b/ports/rp2/modrp2.h
@@ -27,11 +27,12 @@
 #define MICROPY_INCLUDED_RP2_MODRP2_H
 
 #include "py/obj.h"
+#include "machine_spi.h"
 
 extern const mp_obj_type_t rp2_flash_type;
 extern const mp_obj_type_t rp2_pio_type;
 extern const mp_obj_type_t rp2_state_machine_type;
-
+extern const mp_obj_fun_builtin_fixed_t dht_readinto_obj;
 void rp2_pio_init(void);
 void rp2_pio_deinit(void);
 
diff --git a/ports/rp2/mpconfigport.h b/ports/rp2/mpconfigport.h
index 63d9818e3..296b9009e 100644
--- a/ports/rp2/mpconfigport.h
+++ b/ports/rp2/mpconfigport.h
@@ -27,6 +27,7 @@
 // Options controlling how MicroPython is built, overriding defaults in py/mpconfig.h
 
 #include <stdint.h>
+
 #include "hardware/spi.h"
 #include "hardware/sync.h"
 #include "pico/binary_info.h"
@@ -72,22 +73,32 @@
 #define MICROPY_FLOAT_IMPL                      (MICROPY_FLOAT_IMPL_FLOAT)
 #define MICROPY_USE_INTERNAL_ERRNO              (1)
 #define MICROPY_SCHEDULER_DEPTH                 (8)
+#define MICROPY_STREAMS_POSIX_API               (1)
 
 // Fine control over Python builtins, classes, modules, etc
 #define MICROPY_PY_BUILTINS_HELP_TEXT           rp2_help_text
 #define MICROPY_PY_SYS_PLATFORM                 "rp2"
+#define MICROPY_PY_UERRNO                       (1)
 #define MICROPY_PY_THREAD                       (1)
-#define MICROPY_PY_THREAD_GIL                   (0)
+#define MICROPY_PY_THREAD_GIL                   (1)
+//#define MICROPY_PY_THREAD_GIL                   (0)
 
+#define MICROPY_PY_NETWORK                      (1)
+#define MICROPY_PY_USOCKET                      (1)
+#define MICROPY_PY_USSL                         (1)
+#define MICROPY_SSL_AXTLS                       (1)
 // Extended modules
 #define MICROPY_EPOCH_IS_1970                   (1)
 #define MICROPY_PY_URE_MATCH_GROUPS             (1)
 #define MICROPY_PY_URE_MATCH_SPAN_START_END     (1)
 #define MICROPY_PY_UTIME_MP_HAL                 (1)
+#define MICROPY_PY_URANDOM                      (1)
+#define MICROPY_PY_URANDOM_EXTRA_FUNCS          (1)
 #define MICROPY_PY_URANDOM_SEED_INIT_FUNC       (rosc_random_u32())
+#define MICROPY_PY_USELECT                      (1)
 #define MICROPY_PY_MACHINE                      (1)
 #define MICROPY_PY_MACHINE_PIN_MAKE_NEW         mp_pin_make_new
-#define MICROPY_PY_MACHINE_BITSTREAM            (1)
+//#define MICROPY_PY_MACHINE_BITSTREAM            (1)
 #define MICROPY_PY_MACHINE_PULSE                (1)
 #define MICROPY_PY_MACHINE_PWM                  (1)
 #define MICROPY_PY_MACHINE_PWM_DUTY_U16_NS      (1)
@@ -128,6 +139,7 @@ extern const struct _mp_obj_module_t mp_module_rp2;
 extern const struct _mp_obj_module_t mp_module_uos;
 extern const struct _mp_obj_module_t mp_module_usocket;
 extern const struct _mp_obj_module_t mp_module_utime;
+extern const struct _mp_obj_module_t mp_module_ussl;
 
 #if MICROPY_PY_USOCKET
 #define SOCKET_BUILTIN_MODULE               { MP_ROM_QSTR(MP_QSTR_usocket), MP_ROM_PTR(&mp_module_usocket) },
@@ -142,6 +154,14 @@ extern const struct _mp_obj_module_t mp_module_utime;
 #define NETWORK_ROOT_POINTERS
 #endif
 
+#if MICROPY_PY_WIZNET5K
+extern const struct _mod_network_nic_type_t mod_network_nic_type_wiznet5k;
+#define MICROPY_HW_NIC_WIZNET5K             { MP_ROM_QSTR(MP_QSTR_WIZNET5K), MP_ROM_PTR(&mod_network_nic_type_wiznet5k) },
+#else
+#define MICROPY_HW_NIC_WIZNET5K
+#endif
+
+
 #if MICROPY_PY_BLUETOOTH
 #define MICROPY_PORT_ROOT_POINTER_BLUETOOTH struct _machine_uart_obj_t *mp_bthci_uart;
 #else
@@ -179,8 +199,15 @@ extern const struct _mod_network_nic_type_t mod_network_nic_type_nina;
     SOCKET_BUILTIN_MODULE \
     NETWORK_BUILTIN_MODULE \
 
-#define MICROPY_PORT_NETWORK_INTERFACES \
-    MICROPY_HW_NIC_NINAW10  \
+#if defined(MICROPY_PY_NETWORK_NINAW10)
+    #define MICROPY_PORT_NETWORK_INTERFACES \
+        MICROPY_HW_NIC_NINAW10  
+#elif defined(MICROPY_PY_WIZNET5K)
+    #define MICROPY_PORT_NETWORK_INTERFACES \
+        MICROPY_HW_NIC_WIZNET5K 
+#else
+    #define MICROPY_PORT_NETWORK_INTERFACES
+#endif
 
 #ifndef MICROPY_BOARD_ROOT_POINTERS
 #define MICROPY_BOARD_ROOT_POINTERS
@@ -230,6 +257,7 @@ extern const struct _mod_network_nic_type_t mod_network_nic_type_nina;
         MICROPY_HW_USBDEV_TASK_HOOK \
     } while (0);
 
+#define MICROPY_THREAD_YIELD() // mp_handle_pending(true);
 #define MICROPY_MAKE_POINTER_CALLABLE(p) ((void *)((mp_uint_t)(p) | 1))
 
 #define MP_SSIZE_MAX (0x7fffffff)
diff --git a/tools/upip.py b/tools/upip.py
index 9fb872642..34d23d2a8 100644
--- a/tools/upip.py
+++ b/tools/upip.py
@@ -16,7 +16,8 @@ import upip_utarfile as tarfile
 gc.collect()
 
 
-debug = False
+#debug = False
+debug = True
 index_urls = ["https://micropython.org/pi", "https://pypi.org/pypi"]
 install_path = None
 cleanup_files = []
@@ -112,6 +113,7 @@ def expandhome(s):
     if "~/" in s:
         h = os.getenv("HOME")
         s = s.replace("~/", h + "/")
+        print("path ",s)
     return s
 
 
@@ -134,25 +136,29 @@ def url_open(url):
             host, port = host.split(":")
             port = int(port)
         ai = usocket.getaddrinfo(host, port, 0, usocket.SOCK_STREAM)
+        print("Address infos:", ai)
+        #ai = usocket.getaddrinfo(host, port)
     except OSError as e:
         fatal("Unable to resolve %s (no Internet?)" % host, e)
-    # print("Address infos:", ai)
     ai = ai[0]
 
     s = usocket.socket(ai[0], ai[1], ai[2])
     try:
-        # print("Connect address:", addr)
-        s.connect(ai[-1])
-
+        #print("Connect address:", addr)
+        #print("Connect address:", ai[4])
+        s.connect(ai[4])
         if proto == "https:":
             s = ussl.wrap_socket(s, server_hostname=host)
             if warn_ussl:
                 print("Warning: %s SSL certificate is not validated" % host)
                 warn_ussl = False
-
+            ##211209 upip modification
+            print("HTTPS TLS established : %s " % host) 
         # MicroPython rawsocket module supports file interface directly
         s.write("GET /%s HTTP/1.0\r\nHost: %s:%s\r\n\r\n" % (urlpath, host, port))
         l = s.readline()
+        ##211209 upip modification
+        print("   " + l.decode(), end='')
         protover, status, msg = l.split(None, 2)
         if status != b"200":
             if status == b"404" or status == b"301":
@@ -192,13 +198,14 @@ def fatal(msg, exc=None):
 
 
 def install_pkg(pkg_spec, install_path):
-    package = pkg_spec.split("==")
-    data = get_pkg_metadata(package[0])
-
-    if len(package) == 1:
-        latest_ver = data["info"]["version"]
-    else:
-        latest_ver = package[1]
+   # package = pkg_spec.split("==")
+    #data = get_pkg_metadata(package[0])
+    data = get_pkg_metadata(pkg_spec)
+    
+    #if len(package) == 1:
+    latest_ver = data["info"]["version"]
+    #else:
+    #    latest_ver = package[1]
     packages = data["releases"][latest_ver]
     del data
     gc.collect()
@@ -262,8 +269,9 @@ def get_install_path():
     if install_path is None:
         # sys.path[0] is current module's path
         install_path = sys.path[1]
-        if install_path == ".frozen":
-            install_path = sys.path[2]
+        install_path = "lib"
+        #if install_path == ".frozen":
+        #    install_path = sys.path[2]
     install_path = expandhome(install_path)
     return install_path
 
@@ -353,4 +361,5 @@ def main():
 
 
 if __name__ == "__main__":
-    main()
+    #main()
+    install("ureqeust")
